<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>To-Scale Formation Map Trainer</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      display:flex;
      height:100vh;
      overflow:hidden;
      background:#020617;
      color:#e5e7eb;
    }

    /* Sidebars */
    .sidebar{
      height:100vh;
      overflow-y:auto;
      -webkit-overflow-scrolling: touch;
      width: 320px;
      background:#111827;
      color:#e5e7eb;
      padding:12px 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    #sidebarLeft{ border-right:1px solid #374151; scrollbar-width:none; -ms-overflow-style:none; }
    #sidebarLeft::-webkit-scrollbar{ width:0; height:0; }
    #sidebarRight{ border-left:1px solid #374151; }

    h1{ font-size:18px; margin:0 0 4px 0; }
    h2{ font-size:14px; margin:10px 0 4px 0; border-bottom:1px solid #374151; padding-bottom:2px; }

    .section{
      background:#111827;
      border:1px solid #1f2937;
      border-radius:6px;
      padding:8px;
      margin-bottom:4px;
    }
    .row{
      display:flex;
      gap:6px;
      align-items:center;
      margin-bottom:6px;
      flex-wrap:wrap;
    }
    label, span{ font-size:12px; }
    select, button, input[type="number"], input[type="text"], textarea{
      font-size:12px;
      padding:6px 8px;
      border-radius:6px;
      border:1px solid #4b5563;
      background:#020617;
      color:#e5e7eb;
    }
    textarea{
      width:100%;
      min-height:64px;
      resize:vertical;
      line-height:1.35;
    }
    input[type="range"]{
      width:100%;
    }
    button{ cursor:pointer; }
    button:hover{ background:#111827; }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .badge{
      display:inline-block;
      padding:1px 6px;
      border-radius:999px;
      font-size:10px;
      background:#111827;
      border:1px solid #374151;
      color:#e5e7eb;
    }
    .muted{ color:#9ca3af; font-size:11px; line-height:1.35; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 8px;
      border-radius:999px;
      border:1px solid #374151;
      background:#0b1220;
      font-size:11px;
      color:#cbd5e1;
    }
    .kv{ display:grid; grid-template-columns: 100px 1fr; gap:8px; align-items:center; margin-bottom:6px; }
    .kv > div:first-child{ color:#9ca3af; font-size:11px; }
    .kv > div:last-child{ font-size:12px; color:#e5e7eb; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

    /* Canvas */
    #canvasContainer{
      flex:1;
      position:relative;
      background:#020617;
    }
    #mapCanvas{
      width:100%;
      height:100%;
      display:block;
      background:#020617;
      cursor:crosshair;
    }

    #mapTopControls{
      position:absolute;
      top:10px;
      left:10px;
      z-index:10;
      display:flex;
      gap:8px;
      padding:6px;
      background:rgba(17,24,39,0.75);
      border:1px solid rgba(55,65,81,0.9);
      border-radius:12px;
      backdrop-filter: blur(6px);
    }
    #mapTopControls .sep{ width:1px; height:18px; background:rgba(148,163,184,0.35); display:inline-block; margin:0 6px; }
    #mapTopControls .simLbl{ font-size:11px; opacity:0.85; margin-left:4px; }
    #mapTopControls input[type="range"]{ width:110px; }
    #mapTopControls .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:11px; opacity:0.9; }

    #mapTopControls button{ white-space:nowrap; display:inline-flex; align-items:center; justify-content:center; text-align:center; }

    /* Small helpers */
    .hr{ height:1px; background:#1f2937; margin:6px 0; }
    .danger{ border-color:#7f1d1d; }
    .danger:hover{ background:#1f2937; }
    .twoCol{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
  </style>
</head>
<body>
  <!-- LEFT: tools -->
  <div id="sidebarLeft" class="sidebar">
    <h1>Formation Trainer</h1>

    <div class="section">
      <div class="row"><span class="badge">Scale: 1 px = 1 ft @ 100% zoom</span></div>
      <div class="row"><span>Pan: <strong>Drag empty space</strong></span></div>
      <div class="row"><span>Highlight: <strong>Shift + Drag</strong></span></div>
      <div class="row"><span>Select: <strong>Click</strong> (Cmd/Ctrl+Click to multi)</span></div>
      <div class="row"><span>Box select: <strong>Drag empty space</strong></span></div>
      <div class="row"><span>Move soldier: <strong>Click-drag near soldier</strong></span></div>
      <div class="row"><span>Zoom: <strong>Mouse wheel</strong> (on canvas)</span></div>
      <div class="row"><span>Delete: <strong>Del</strong> (selected, else nearest)</span></div>
    </div>

    <div class="section">
      <h2>Basic Tools</h2>
      <div class="row">
        <label for="toolSelect">Tool:</label>
        <select id="toolSelect">
          <option value="select">Select / Inspect</option>
          <option value="move-waypoints">Move (Waypoints)</option>
          <option value="add-soldier">Add Soldier</option>
          <option value="add-building">Add Building (drag)</option>
          <option value="add-road">Add Road (polyline)</option>
          <option value="add-terrain">Add Terrain (area)</option>
        </select>
      </div>

      <div class="row">
        <label for="soldierSide">Soldier side:</label>
        <select id="soldierSide">
          <option value="friendly">Friendly</option>
          <option value="enemy">Enemy</option>
        </select>
      </div>

      
      <div class="row" id="moveToolControls" style="margin-top:6px;">
        <label style="min-width:80px;">Move tool:</label>
        <div style="display:flex; flex-direction:column; gap:6px; flex:1;">
          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <label style="display:inline-flex; align-items:center; gap:6px; font-size:11px;">
              <span style="opacity:0.85;">Speed (ft/s)</span>
              <input id="moveSpeed" type="number" min="0.5" max="30" step="0.5" value="6" style="width:72px;" />
            </label>
            <label style="display:inline-flex; align-items:center; gap:6px; font-size:11px;">
              <input type="checkbox" id="moveFaceMove" checked>
              Face movement
            </label>
            <label style="display:inline-flex; align-items:center; gap:6px; font-size:11px;">
              <input type="checkbox" id="movePreserveFormation" checked>
              Preserve formation (multi)
            </label>
          </div>
          <div class="muted" style="font-size:11px;">
            In <strong>Move (Waypoints)</strong>: click to set destination, <strong>Shift+click</strong> to append, <strong>Alt+click</strong> to clear.
          </div>
        </div>
      </div>
<div class="row">
        <label>Pick layers:</label>
        <label style="display:inline-flex; align-items:center; gap:6px; font-size:11px;">
          <input type="checkbox" id="pickSoldiers" checked> Soldiers
        </label>
        <label style="display:inline-flex; align-items:center; gap:6px; font-size:11px;">
          <input type="checkbox" id="pickBuildings"> Buildings
        </label>
        <label style="display:inline-flex; align-items:center; gap:6px; font-size:11px;">
          <input type="checkbox" id="pickRoads"> Roads
        </label>
        <label style="display:inline-flex; align-items:center; gap:6px; font-size:11px;">
          <input type="checkbox" id="pickTerrains"> Terrain
        </label>
        <button id="pickOnlySoldiersBtn" title="Only soldiers selectable">Only Soldiers</button>
        <button id="pickAllLayersBtn" title="All layers selectable">All</button>
      </div>


      <div class="row">
        <button id="finishShapeBtn">Finish Road / Terrain</button>
        <button id="undoBtn">Undo</button>
        <button id="clearBtn" class="danger">Clear All</button>
      </div>

      <div class="muted">
        Place your soldiers, buildings, etc. then go back to the selector / pointer tool
      </div>
    </div>

    <div class="section">
      <h2>Group Placement</h2>
      <div class="row">
        <label for="squadSize">Size:</label>
        <input id="squadSize" type="number" min="4" max="9" step="1" value="6" />
      </div>
<div class="row">
        <label for="squadFormation">Formation:</label>
        <select id="squadFormation">
          <option value="wedge">Wedge</option>
          <option value="file">File</option>
          <option value="line">Line</option>
        </select>
      </div>
      <div class="row">
        <label for="squadSpacing">Spacing (ft):</label>
        <input id="squadSpacing" type="number" min="1" step="1" value="33" />
      </div>
      <div class="row">
        <span class="muted">Click on the map to place a group (size/spacing above), facing up-screen.</span>
      </div>
      <div class="row">
        <button id="placeSquadFormationBtn">Place Formation</button>
      </div>
    </div>

    <div class="section">
      <h2>Platoon-Size (3 groups)</h2>
      <div class="row">
        <label for="platoonFormation">Formation:</label>
        <select id="platoonFormation">
          <option value="platoon-wedge">Wedge (3×)</option>
          <option value="platoon-line">Line (3×)</option>
          <option value="platoon-column">Column (3×)</option>
        </select>
      </div>
      <div class="row">
        <label for="platoonSpacing">Group spacing (ft):</label>
        <input id="platoonSpacing" type="number" min="1" step="1" value="164" />
      </div>
      <div class="row">
        <span class="muted">Click on the map to place 3 groups (~27 soldiers), facing up-screen.</span>
      </div>
      <div class="row">
        <button id="placePlatoonFormationBtn">Place Platoon</button>
      </div>
    </div>

    <div class="section">
      <h2>Map</h2>
      <div class="twoCol">
        <button id="centerViewBtn">Center View</button>
        <button id="toggleGridBtn">Grid: Off</button>
      </div>
<div class="row" style="margin-top:8px;">
        <button id="exportMapBtn">Save Map (JS)</button>
        <button id="importMapBtn">Import Map</button>
        <input id="importMapFile" type="file" accept=".js,.json" style="display:none;" />
      </div>
      <div class="muted">
        Auto-loads <strong>formation_map_data.js</strong> if it’s in the same folder as this HTML.
      </div>
      <div class="muted">
        Zoom: <span id="zoomReadout">100%</span> ·
        Pan: <span id="panReadout">0, 0</span>
      </div>
    </div>

    <div class="muted" style="margin-top:auto;">
      This tool is about *to-scale spatial relationships*.
      It is a map editor first: add soldiers, buildings, roads, and terrain — and edit them in the inspector on the right.
    </div>
  </div>

  <!-- CENTER: canvas -->
  <div id="canvasContainer">
    <div id="mapTopControls">
      <button id="toggleRangesBtn">Ranges: Selected</button>
      <button id="toggleConesBtn">Cones: Off</button>
      <span class="sep"></span>
      <button id="toggleMovePathsBtn">Paths: Selected</button>
      <span class="sep"></span>
      <button id="simPlayBtn">Play</button>
      <button id="simResetBtn" title="Reset sim time and restore starting positions">Reset</button>
      <label class="simLbl" for="simSpeed">Speed</label>
      <input id="simSpeed" type="range" min="0.25" max="4" step="0.25" value="1" />
      <span id="simSpeedReadout" class="mono">1.00x</span>
      <span class="sep"></span>
      <span id="simTimeReadout" class="mono">t=0.0s</span>
    </div>
    <canvas id="mapCanvas"></canvas>
  </div>

  <!-- RIGHT: inspector -->
  <div id="sidebarRight" class="sidebar">
    <h1>Inspector</h1>

    <div class="section" id="inspectorSummary">
      <div class="pill" id="selectionPill">No selection</div>
      <div class="hr"></div>
      <div class="kv"><div>Tool</div><div id="toolReadout">select</div></div>
      <div class="kv"><div>Mouse</div><div id="mouseReadout">—</div></div>
    </div>

        <div class="section" id="inspectorTable" style="display:none;"></div>

<div class="section" id="inspectorBody">
      <div class="muted">
        Choose <strong>Select / Inspect</strong>, then click an object (or drag empty space to marquee-select).
        You’ll be able to edit terrain type and road width here.
      </div>
    </div>

    <div class="section">
      <h2>Selection Actions</h2>
      <div class="row">
        <button id="deleteSelectedBtn" class="danger" disabled>Delete Selected</button>
        <button id="duplicateSelectedBtn" disabled>Duplicate</button>
        <button id="deselectAllBtn" disabled>Deselect All</button>
      </div>
      <div class="muted">Keyboard: <strong>Del</strong> deletes the selected item (or nearest item if none selected).</div>
    </div>

    <div class="section">
      <h2>Notes</h2>
      <textarea id="mapNotes" placeholder="Freeform notes (stored in this file only while it’s open)"></textarea>
    </div>

    <div class="section">
      <h2>Image Overlay</h2>
      <div class="muted">Upload a map image and align it under your drawings so you can trace over it.</div>
      <div class="row">
        <input type="file" id="overlayFile" accept="image/*" style="display:none;">
        <button id="overlayUploadBtn">Upload Image</button>
        <button id="overlayClearBtn" class="danger" disabled>Remove</button>
      </div>

      <div class="row" style="flex-wrap:wrap; gap:10px;">
        <label style="display:inline-flex; align-items:center; gap:6px; font-size:11px;">
          <input type="checkbox" id="overlayVisible" checked> Visible
        </label>
        <label style="display:inline-flex; align-items:center; gap:6px; font-size:11px;">
          <input type="checkbox" id="overlayDrag"> Drag overlay
        </label>
      </div>

      <div class="row" style="align-items:center;">
        <label style="display:flex; flex:1; flex-direction:column; gap:6px; font-size:11px;">
          <span class="muted">Opacity</span>
          <input type="range" id="overlayOpacity" min="0" max="1" step="0.01" value="0.60">
        </label>
        <div id="overlayOpacityReadout" class="muted" style="min-width:44px; text-align:right; font-variant-numeric:tabular-nums;">0.60</div>
      </div>

      <div class="row">
        <label style="display:flex; flex:1; flex-direction:column; gap:6px; font-size:11px;">
          <span class="muted">Scale</span>
          <input type="number" id="overlayScale" min="0.01" step="0.01" value="1">
        </label>
        <label style="display:flex; flex:1; flex-direction:column; gap:6px; font-size:11px;">
          <span class="muted">Rotation°</span>
          <input type="number" id="overlayRotation" step="0.1" value="0">
        </label>
      </div>

      <div class="row">
        <label style="display:flex; flex:1; flex-direction:column; gap:6px; font-size:11px;">
          <span class="muted">Center X</span>
          <input type="number" id="overlayX" step="1" value="0">
        </label>
        <label style="display:flex; flex:1; flex-direction:column; gap:6px; font-size:11px;">
          <span class="muted">Center Y</span>
          <input type="number" id="overlayY" step="1" value="0">
        </label>
      </div>

      <div class="row">
        <button id="overlayCenterBtn">Center</button>
        <button id="overlayFitBtn">Fit to View</button>
        <button id="overlayResetBtn">Reset</button>
      </div>

      <div class="muted">Tip: enable <strong>Drag overlay</strong>, then drag on the map to align. Disable it to select/move units normally.</div>
    </div>
  </div>

<script>
  // Optional external map data file (same folder)
  // If present, it should set: window.FORMATION_MAP_DATA = { ... };
  window.FORMATION_MAP_DATA = window.FORMATION_MAP_DATA || null;
</script>
<script src="formation_map_data.js" onerror="console.warn('No formation_map_data.js found; starting with a blank map.');"></script>

<script>
(() => {
  "use strict";

  // ---------- utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const uid = () => Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);

  // ---------- Human-friendly IDs ----------
  // IDs are now simple, readable strings (e.g., "Soldier 1", "Building 2", "Woods 3").
  // We keep the counters in-memory and seed them from loaded map data when needed.
  const idCounters = {
    soldier: 0,
    building: 0,
    road: 0,
    terrain: { open:0, woods:0, urban:0, water:0, rough:0 }
  };

  function terrainLabelFromKey(key){
    try{
      const t = (typeof TERRAIN_TYPES !== "undefined" && Array.isArray(TERRAIN_TYPES))
        ? TERRAIN_TYPES.find(tt => tt.key === key)
        : null;
      return t ? t.label : "Terrain";
    } catch(_e){
      return "Terrain";
    }
  }

  function isHumanIdForKind(kind, id){
    if(typeof id !== "string") return false;
    const s = id.trim();
    if(kind === "soldier")  return /^Soldier\s+\d+$/i.test(s);
    if(kind === "building") return /^Building\s+\d+$/i.test(s);
    if(kind === "road")     return /^Road\s+\d+$/i.test(s);
    if(kind === "terrain")  return /^(Open|Woods|Urban|Water|Rough)\s+\d+$/i.test(s);
    return false;
  }

  function seedIdCountersFromState(){
    // IMPORTANT: only call after `state` exists (page is fully initialized or after load).
    idCounters.soldier = 0;
    idCounters.building = 0;
    idCounters.road = 0;
    idCounters.terrain = { open:0, woods:0, urban:0, water:0, rough:0 };

    const bumpSimple = (k, n) => {
      if(!Number.isFinite(n)) return;
      if(idCounters[k] < n) idCounters[k] = n;
    };
    const bumpTerrain = (k, n) => {
      if(!Number.isFinite(n)) return;
      if(!(k in idCounters.terrain)) idCounters.terrain[k] = 0;
      if(idCounters.terrain[k] < n) idCounters.terrain[k] = n;
    };

    for(const s of (state.soldiers || [])){
      if(typeof s.id !== "string") continue;
      const m = s.id.trim().match(/^Soldier\s+(\d+)$/i);
      if(m) bumpSimple("soldier", parseInt(m[1], 10));
    }
    for(const b of (state.buildings || [])){
      if(typeof b.id !== "string") continue;
      const m = b.id.trim().match(/^Building\s+(\d+)$/i);
      if(m) bumpSimple("building", parseInt(m[1], 10));
    }
    for(const r of (state.roads || [])){
      if(typeof r.id !== "string") continue;
      const m = r.id.trim().match(/^Road\s+(\d+)$/i);
      if(m) bumpSimple("road", parseInt(m[1], 10));
    }

    // Terrain: we seed by label, regardless of `terrainType`, so we never collide with already-labeled IDs.
    const labelToKey = { Open:"open", Woods:"woods", Hills:"hills", Urban:"urban", Water:"water", Rough:"rough" };
    for(const t of (state.terrains || [])){
      if(typeof t.id !== "string") continue;
      const id = t.id.trim();
      for(const lab of Object.keys(labelToKey)){
        const mm = id.match(new RegExp("^" + lab + "\\s+(\\d+)$", "i"));
        if(mm) bumpTerrain(labelToKey[lab], parseInt(mm[1], 10));
      }
    }
  }

  function allocId(kind, obj){
    if(kind === "soldier"){
      idCounters.soldier++;
      return `Soldier ${idCounters.soldier}`;
    }
    if(kind === "building"){
      idCounters.building++;
      return `Building ${idCounters.building}`;
    }
    if(kind === "road"){
      idCounters.road++;
      return `Road ${idCounters.road}`;
    }
    if(kind === "terrain"){
      const k = (obj && typeof obj.terrainType === "string") ? obj.terrainType : "open";
      if(!(k in idCounters.terrain)) idCounters.terrain[k] = 0;
      idCounters.terrain[k]++;
      return `${terrainLabelFromKey(k)} ${idCounters.terrain[k]}`;
    }
    // Fallback to an opaque id for any unknown kind
    return uid();
  }

  function makeUniqueId(kind, desired, currentId){
    const base = String(desired || "").trim();
    if(!base) return String(currentId || "");
    const list =
      (kind === "soldier") ? (state.soldiers || []) :
      (kind === "building") ? (state.buildings || []) :
      (kind === "road") ? (state.roads || []) :
      (kind === "terrain") ? (state.terrains || []) : [];
    const used = new Set(list.map(o => String(o && o.id)));
    if(currentId) used.delete(String(currentId));
    if(!used.has(base)) return base;
    let i = 2;
    while(used.has(`${base}-${i}`)) i++;
    return `${base}-${i}`;
  }

  function renameObjectId(kind, oldId, newId){
    if(!oldId || !newId || oldId === newId) return;

    if(state.selected && state.selected.kind === kind && state.selected.id === oldId){
      state.selected.id = newId;
    }
    if(state.selectedMulti && state.selectedMulti.length){
      for(const ref of state.selectedMulti){
        if(ref && ref.kind === kind && ref.id === oldId) ref.id = newId;
      }
    }
    if(state.hover && state.hover.kind === kind && state.hover.id === oldId){
      state.hover.id = newId;
    }
    if(state.draggingObj && state.draggingObj.kind === kind && state.draggingObj.id === oldId){
      state.draggingObj.id = newId;
    }

    // Rebuild sim runtime if it exists (plans are keyed by soldier id).
    if(kind === "soldier" && state.sim && state.sim.plans){
      buildSimRuntime(false);
    }
  }



  function ensureHumanId(kind, obj){
    if(!obj) return;
    if(typeof obj.id === "string" && obj.id.trim() && isHumanIdForKind(kind, obj.id)) return;
    obj.id = allocId(kind, obj);
  }

  function normalizeAllIds(){
    seedIdCountersFromState();
    for(const s of (state.soldiers  || [])) ensureHumanId("soldier",  s);
    for(const b of (state.buildings || [])) ensureHumanId("building", b);
    for(const r of (state.roads     || [])) ensureHumanId("road",     r);
    for(const t of (state.terrains  || [])) ensureHumanId("terrain",  t);
  }

  function updateSelectionId(kind, oldId, newId){
    if(state.selected && state.selected.kind === kind && state.selected.id === oldId){
      state.selected.id = newId;
    }
    if(Array.isArray(state.selectedMulti)){
      for(const ref of state.selectedMulti){
        if(ref && ref.kind === kind && ref.id === oldId){
          ref.id = newId;
        }
      }
    }
  }


  function deepClone(obj){
    return JSON.parse(JSON.stringify(obj));
  }


  
  // ---------- movement + simulation (waypoint playback) ----------

  function buildSimRuntime(captureOrigin){
    // captureOrigin: if true, store current soldier positions as the sim "start" snapshot.
    if(captureOrigin || !state.sim.origin){
      state.sim.origin = {};
      for(const s of state.soldiers){
        state.sim.origin[s.id] = {x:s.x, y:s.y, heading:(typeof s.heading==="number" ? s.heading : 0)};
      }
    }

    // Always rebuild runtime plans (so Reset rewinds without destroying authored plans).
    state.sim.plans = {};
    for(const s of state.soldiers){
      const mp = s.movePlan;
      if(!mp || !Array.isArray(mp.waypoints) || mp.waypoints.length === 0) continue;
      state.sim.plans[s.id] = {
        waypoints: deepClone(mp.waypoints),
        speedFps: (typeof mp.speedFps === "number" && mp.speedFps > 0) ? mp.speedFps : (state.moveSettings.speedFps || 6),
        face: (mp.face === "fixed" ? "fixed" : "move"),
        startAt: (typeof mp.startAt === "number" && mp.startAt >= 0) ? mp.startAt : 0
      };
    }
  }

  function playSim(){
    if(state.sim.playing) return;

    // If we are at t=0 (or no snapshot yet), treat the current layout as the sim start.
    if(!state.sim.origin || (state.sim.t || 0) === 0){
      buildSimRuntime(true);
    }
    if(!state.sim.plans) buildSimRuntime(false);
state.sim.playing = true;
    state.sim.lastTs = performance.now();
    requestAnimationFrame(tickSim);
  }

  function pauseSim(){
    state.sim.playing = false;
  }

  function resetSim(){
    // Restore start snapshot + rewind runtime waypoint cursors.
    pauseSim();

    if(!state.sim.origin){
      buildSimRuntime(true);
    }

    state.sim.t = 0;

    for(const s of state.soldiers){
      const o = state.sim.origin ? state.sim.origin[s.id] : null;
      if(o){
        s.x = o.x; s.y = o.y;
        if(typeof o.heading === "number") s.heading = o.heading;
      }
      // runtime-only facing (used for movement playback); never persist across resets
      if("simHeading" in s) delete s.simHeading;
    }

    buildSimRuntime(false);
  }

  function tickSim(ts){
    if(!state.sim.playing) return;

    const rawDt = (ts - state.sim.lastTs) / 1000;
    state.sim.lastTs = ts;

    // Clamp dt so tab-switching doesn't jump units.
    const dt = Math.min(0.05, Math.max(0, rawDt)) * (state.sim.speed || 1);

    state.sim.t = (state.sim.t || 0) + dt;

    updateSim(dt);

    if(simTimeReadout){
      simTimeReadout.textContent = "t=" + (state.sim.t || 0).toFixed(1) + "s";
    }

    draw();
    requestAnimationFrame(tickSim);
  }

  function updateSim(dt){
    const tNow = state.sim.t || 0;
    const plans = state.sim.plans || {};

    for(const s of state.soldiers){
      const rp = plans[s.id];
      if(!rp || !rp.waypoints || rp.waypoints.length === 0) continue;
      if(rp.startAt && tNow < rp.startAt) continue;

      const target = rp.waypoints[0];
      const dx = target.x - s.x;
      const dy = target.y - s.y;
      const dist = Math.hypot(dx, dy);

      // Arrived at waypoint
      if(dist < 0.75){
        rp.waypoints.shift();
        continue;
      }

      const resist = terrainResistanceFactor(s.x, s.y, state.terrains);
      const speed = (rp.speedFps || 6) * resist;

      const step = Math.min(dist, speed * dt);
      const ux = dx / dist, uy = dy / dist;

      const stepDx = ux * step;
      const stepDy = uy * step;

      const r = (typeof s.r === "number") ? s.r : 1;
      const p = resolveSoldierDragAgainstBuildings(s.x, s.y, stepDx, stepDy, r, state.buildings);
      s.x = p.x; s.y = p.y;

      if(rp.face === "move"){
        // atan2 gives 0°=right, 90°=down (canvas/world coordinates). Our UI/draw system is 0°=up, 90°=right.
        const travelDegRight0 = (Math.atan2(uy, ux) * 180 / Math.PI + 360) % 360;
        const travelHeadingUp0 = (travelDegRight0 + 90) % 360; // convert to 0°=up
        // Use a runtime-only heading for rendering so the inspector slider stays on the user-set heading.
        // For enemies, we pre-flip here so the draw-time enemy flip cancels out, and cones still face movement.
        s.simHeading = (travelHeadingUp0 + ((s.side === "enemy") ? 180 : 0)) % 360;
      } else {
        // If we're not facing movement, revert to the authored heading.
        if("simHeading" in s) delete s.simHeading;
      }
    }
  }

  function getSelectedSoldiers(){
    const ids = new Set();
    if(state.selected && state.selected.kind === "soldier") ids.add(state.selected.id);
    if(state.selectedMulti && state.selectedMulti.length){
      for(const r of state.selectedMulti){
        if(r && r.kind === "soldier") ids.add(r.id);
      }
    }
    const out = [];
    for(const s of state.soldiers){
      if(ids.has(s.id)) out.push(s);
    }
    return out;
  }

  function applyMoveWaypointClick(targetWorld, ev){
    let selected = getSelectedSoldiers();

    // If nothing selected, try selecting a soldier under the cursor first.
    if(selected.length === 0){
      const hit = hitTest(targetWorld, {cycle: ev.altKey});
      if(hit && hit.kind === "soldier"){
        setSelection(hit);
        renderInspector();
        selected = getSelectedSoldiers();
      }
    }

    const soldiers = selected;
    if(soldiers.length === 0) return;

    // Alt+click clears move plans
    if(ev.altKey){
      const action = {
        kind: "moveplan",
        label: "Clear movement",
        changes: soldiers.map(s => ({
          ref: {kind:"soldier", id:s.id},
          beforeMovePlan: s.movePlan ? deepClone(s.movePlan) : null,
          hadSimHeading: ("simHeading" in s),
          beforeSimHeading: ("simHeading" in s) ? s.simHeading : null
        }))
      };
      pushUndo(action);

      for(const s of soldiers){
        if(s.movePlan) s.movePlan.waypoints = [];
        if("simHeading" in s) delete s.simHeading;
      }
      if(state.sim.plans) buildSimRuntime(false);
      renderInspector();
      draw();
      return;
    }

    const append = !!ev.shiftKey;

    // Preserve formation for multi-select by default (centroid delta approach).
    let targets = [];
    if(soldiers.length > 1 && state.moveSettings.preserveFormation){
      let cx = 0, cy = 0;
      for(const s of soldiers){ cx += s.x; cy += s.y; }
      cx /= soldiers.length; cy /= soldiers.length;
      const ddx = targetWorld.x - cx;
      const ddy = targetWorld.y - cy;
      targets = soldiers.map(s => ({id:s.id, x: s.x + ddx, y: s.y + ddy}));
    } else {
      targets = soldiers.map(s => ({id:s.id, x: targetWorld.x, y: targetWorld.y}));
    }

    const label = append ? "Append waypoint" : "Set destination";
    const action = {
      kind: "moveplan",
      label,
      changes: soldiers.map(s => ({
        ref: {kind:"soldier", id:s.id},
        beforeMovePlan: s.movePlan ? deepClone(s.movePlan) : null,
        hadSimHeading: ("simHeading" in s),
        beforeSimHeading: ("simHeading" in s) ? s.simHeading : null
      }))
    };
    pushUndo(action);

    for(const s of soldiers){
      const tgt = targets.find(t => t.id === s.id);
      if(!tgt) continue;

      if(!s.movePlan) s.movePlan = {waypoints:[], speedFps: state.moveSettings.speedFps || 6, face: (state.moveSettings.faceMove ? "move" : "fixed"), startAt:0};

      // Apply current move-tool settings
      s.movePlan.speedFps = state.moveSettings.speedFps || 6;
      s.movePlan.face = (state.moveSettings.faceMove ? "move" : "fixed");
        if(s.movePlan.face === "fixed" && ("simHeading" in s)) delete s.simHeading;

      if(!Array.isArray(s.movePlan.waypoints)) s.movePlan.waypoints = [];

      if(append) s.movePlan.waypoints.push({x:tgt.x, y:tgt.y});
      else s.movePlan.waypoints = [{x:tgt.x, y:tgt.y}];
    }

    if(state.sim.plans) buildSimRuntime(false);

    renderInspector();
    draw();
  }

  function drawMovePaths(ctx, selectedKeys){
    if(state.movePathDisplay === "off") return;

    const showSelected = (state.movePathDisplay === "selected");

    ctx.save();
    ctx.lineWidth = 1.5 / state.zoom;
    ctx.setLineDash([6/state.zoom, 6/state.zoom]);

    for(const s of state.soldiers){
      const mp = s.movePlan;
      if(!mp || !Array.isArray(mp.waypoints) || mp.waypoints.length === 0) continue;

      const isSel = selectedKeys && selectedKeys.has("soldier:" + s.id);
      if(showSelected && !isSel) continue;

      const stroke = (s.side === "enemy") ? "rgba(239,68,68,0.55)" : "rgba(59,130,246,0.55)";
      const fill   = (s.side === "enemy") ? "rgba(239,68,68,0.35)" : "rgba(59,130,246,0.35)";
      ctx.strokeStyle = stroke;

      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      for(const wp of mp.waypoints){
        ctx.lineTo(wp.x, wp.y);
      }
      ctx.stroke();

      ctx.setLineDash([]);
      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      for(const wp of mp.waypoints){
        ctx.beginPath();
        ctx.arc(wp.x, wp.y, 0.9 / state.zoom, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      }
      ctx.setLineDash([6/state.zoom, 6/state.zoom]);
    }

    ctx.restore();
  }

// ---------- save/load (export to JS, import JS/JSON) ----------
  function getSaveData(){
    const notesEl = document.getElementById("mapNotes");
    // Do not persist runtime-only sim fields (like `simHeading`).
    const soldiersClean = (state.soldiers || []).map(s => {
      const c = deepClone(s);
      if("simHeading" in c) delete c.simHeading;
      if(typeof c.rangeFt !== "number" || !isFinite(c.rangeFt) || c.rangeFt <= 0){
        c.rangeFt = getSoldierRangeFt(c);
      }
      c.rangeFt = clamp(c.rangeFt, 1, 200000);
      if("weapon" in c) delete c.weapon;
      if("heading" in c) delete c.heading;
      return c;
    });
    return {
      version: 1,
      savedAt: new Date().toISOString(),
      view: { zoom: state.zoom, panX: state.panX, panY: state.panY },
      soldiers: soldiersClean,
      buildings: state.buildings,
      roads: state.roads,
      terrains: state.terrains,
      overlay: overlaySaveData(),
      notes: notesEl ? (notesEl.value || "") : ""
    };
  }

  function exportMapAsJS(){
    const data = getSaveData();
    const js =
`// Formation map save file
// Place this file in the same folder as the HTML as: formation_map_data.js
window.FORMATION_MAP_DATA = ${JSON.stringify(data, null, 2)};
`;

    const blob = new Blob([js], { type: "application/javascript" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "formation_map_data.js";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
  }

  function loadSaveData(data){
    if(!data || typeof data !== "object") return;

    state.soldiers  = Array.isArray(data.soldiers)  ? data.soldiers  : [];
    // Normalize soldier fields (range migration, strip runtime-only fields).
    for(const s of (state.soldiers || [])){
      if(!s || typeof s !== "object") continue;
      if("simHeading" in s) delete s.simHeading;

      if(typeof s.rangeFt !== "number" || !isFinite(s.rangeFt) || s.rangeFt <= 0){
        const wk = s.weapon;
        if(wk && LEGACY_WEAPON_RANGE_FT[wk]) s.rangeFt = LEGACY_WEAPON_RANGE_FT[wk];
        else s.rangeFt = DEFAULT_SOLDIER_RANGE_FT;
      }
      s.rangeFt = clamp(s.rangeFt, 1, 200000);

      if("weapon" in s) delete s.weapon;
      if("heading" in s) delete s.heading;

      if(typeof s.zOffsetFt !== "number" || !isFinite(s.zOffsetFt)) s.zOffsetFt = 0;
      s.zOffsetFt = clamp(s.zOffsetFt, -500, 5000);
    }
    state.buildings = Array.isArray(data.buildings) ? data.buildings : [];

    // Defaults for newer fields (floors/height, elevation)
    for(const b of (state.buildings || [])){
      if(!b || typeof b !== "object") continue;
      if(typeof b.floors !== "number" || !isFinite(b.floors)) b.floors = 1;
      b.floors = clamp(Math.round(b.floors), 1, 200);
      if(typeof b.floorHeightFt !== "number" || !isFinite(b.floorHeightFt)) b.floorHeightFt = 10;
      b.floorHeightFt = clamp(b.floorHeightFt, 6, 30);
      if(typeof b.roofExtraFt !== "number" || !isFinite(b.roofExtraFt)) b.roofExtraFt = 0;
      b.roofExtraFt = clamp(b.roofExtraFt, 0, 200);
    }
    for(const s of (state.soldiers || [])){
      if(!s || typeof s !== "object") continue;
      if(typeof s.zOffsetFt !== "number" || !isFinite(s.zOffsetFt)) s.zOffsetFt = 0;
      s.zOffsetFt = clamp(s.zOffsetFt, -500, 5000);
    }
    state.roads     = Array.isArray(data.roads)     ? data.roads     : [];
    state.terrains  = Array.isArray(data.terrains)  ? data.terrains  : [];

    // Ensure all objects have human-friendly IDs and keep counters in sync.
    normalizeAllIds();

    // view is optional
    if(data.view && typeof data.view === "object"){
      if(typeof data.view.zoom === "number") state.zoom = data.view.zoom;
      if(typeof data.view.panX === "number") state.panX = data.view.panX;
      if(typeof data.view.panY === "number") state.panY = data.view.panY;
    }

        applyOverlaySaveData(data.overlay);

    const notesEl = document.getElementById("mapNotes");
    if(notesEl && typeof data.notes === "string") notesEl.value = data.notes;

    state.selected = null;
    state.drawing = null;
    state.undo.length = 0;
    undoBtn.disabled = true;

    // Reset sim state on load
    if(state.sim){
      state.sim.playing = false;
      state.sim.t = 0;
      state.sim.origin = null;
      state.sim.plans = null;
    }
    if(typeof updateSimUI === "function") updateSimUI();

    renderInspector();
    updateCursor();
    draw();
  }

  function importMapFromText(text){
    const t = (text || "").trim();
    if(!t) return;

    // JSON file support
    if(t.startsWith("{") || t.startsWith("[")){
      loadSaveData(JSON.parse(t));
      return;
    }

    // JS file support: run the file with a sandboxed "window"
    // (imports user-selected files only)
    const sandbox = {};
    const fn = new Function("window", `${t}\n; return window.FORMATION_MAP_DATA;`);
    const data = fn(sandbox);
    loadSaveData(data);
  }

  // Distance helpers (world units)
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function distPointToSeg(p, a, b){
    const vx = b.x - a.x, vy = b.y - a.y;
    const wx = p.x - a.x, wy = p.y - a.y;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(p.x-a.x, p.y-a.y);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(p.x-b.x, p.y-b.y);
    const t = c1 / c2;
    const px = a.x + t*vx, py = a.y + t*vy;
    return Math.hypot(p.x-px, p.y-py);
  }
  function pointInPoly(pt, poly){
    // ray casting
    let inside=false;
    for (let i=0,j=poly.length-1;i<poly.length;j=i++){
      const xi=poly[i].x, yi=poly[i].y;
      const xj=poly[j].x, yj=poly[j].y;
      const intersect = ((yi>pt.y)!==(yj>pt.y)) && (pt.x < (xj-xi)*(pt.y-yi)/(yj-yi+1e-12)+xi);
      if(intersect) inside=!inside;
    }
    return inside;
  }


  // ---------- polygon helpers (centroid / bounds / ray exit) ----------
  function polyBounds(poly){
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const p of poly){
      if(p.x < minX) minX = p.x;
      if(p.y < minY) minY = p.y;
      if(p.x > maxX) maxX = p.x;
      if(p.y > maxY) maxY = p.y;
    }
    return {minX, minY, maxX, maxY, w:(maxX-minX), h:(maxY-minY), cx:(minX+maxX)/2, cy:(minY+maxY)/2};
  }

  function polyAreaCentroid(poly){
    // Area-weighted centroid for non-self-intersecting polygons.
    let a = 0, cx = 0, cy = 0;
    for(let i=0,j=poly.length-1;i<poly.length;j=i++){
      const p = poly[j], q = poly[i];
      const cross = p.x*q.y - q.x*p.y;
      a += cross;
      cx += (p.x + q.x) * cross;
      cy += (p.y + q.y) * cross;
    }
    a *= 0.5;
    if(Math.abs(a) < 1e-9){
      // Fallback: average of vertices
      let sx=0, sy=0;
      for(const p of poly){ sx += p.x; sy += p.y; }
      const n = Math.max(1, poly.length);
      return {x: sx/n, y: sy/n};
    }
    cx /= (6*a);
    cy /= (6*a);
    return {x: cx, y: cy};
  }

  function pickInteriorPoint(poly){
    // Best-effort interior point for drawing helpers.
    const c = polyAreaCentroid(poly);
    if(pointInPoly(c, poly)) return c;

    let sx=0, sy=0;
    for(const p of poly){ sx += p.x; sy += p.y; }
    const n = Math.max(1, poly.length);
    const avg = {x: sx/n, y: sy/n};
    if(pointInPoly(avg, poly)) return avg;

    const b = polyBounds(poly);
    const mid = {x: b.cx, y: b.cy};
    if(pointInPoly(mid, poly)) return mid;

    const p0 = poly[0] || avg;
    for(const k of [0.02, 0.05, 0.1, 0.2, 0.35, 0.5, 0.75]){
      const cand = {x: p0.x + (avg.x - p0.x)*k, y: p0.y + (avg.y - p0.y)*k};
      if(pointInPoly(cand, poly)) return cand;
    }
    return avg;
  }

  function cross2(ax, ay, bx, by){ return ax*by - ay*bx; }

  function rayExitDistance(origin, dir, poly){
    // Nearest positive intersection distance from origin along dir to polygon boundary.
    // Works best when origin is inside (or on) the polygon.
    let best = Infinity;
    const ox = origin.x, oy = origin.y;
    const rx = dir.x, ry = dir.y;

    for(let i=0, j=poly.length-1; i<poly.length; j=i++){
      const ax = poly[j].x, ay = poly[j].y;
      const bx = poly[i].x, by = poly[i].y;
      const sx = bx - ax, sy = by - ay;

      const denom = cross2(rx, ry, sx, sy);
      if(Math.abs(denom) < 1e-9) continue; // parallel

      const qpx = ax - ox, qpy = ay - oy;
      const t = cross2(qpx, qpy, sx, sy) / denom; // along ray
      const u = cross2(qpx, qpy, rx, ry) / denom; // along segment

      if(u < -1e-6 || u > 1+1e-6) continue;
      if(t > 1e-6 && t < best) best = t;
    }

    return isFinite(best) ? best : null;
  }

  function drawArrow(ctx, x1, y1, x2, y2, opts){
    const lw = (opts && opts.lineWidth) ? opts.lineWidth : 2;
    const colorBase = (opts && opts.strokeStyle) ? opts.strokeStyle : "rgba(15,23,42,0.90)";
    const colorTop  = (opts && opts.strokeStyleTop) ? opts.strokeStyleTop : "rgba(226,232,240,0.92)";
    const head = (opts && opts.headSize) ? opts.headSize : 10;
    const headAng = ((opts && opts.headAngleDeg) ? opts.headAngleDeg : 28) * Math.PI/180;

    const dx = x2 - x1, dy = y2 - y1;
    const a = Math.atan2(dy, dx);

    // shaft base
    ctx.beginPath();
    ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
    ctx.lineWidth = lw*2;
    ctx.strokeStyle = colorBase;
    ctx.stroke();

    // shaft top
    ctx.beginPath();
    ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
    ctx.lineWidth = lw;
    ctx.strokeStyle = colorTop;
    ctx.stroke();

    const hx1 = x2 - Math.cos(a - headAng)*head;
    const hy1 = y2 - Math.sin(a - headAng)*head;
    const hx2 = x2 - Math.cos(a + headAng)*head;
    const hy2 = y2 - Math.sin(a + headAng)*head;

    // head base
    ctx.beginPath();
    ctx.moveTo(x2, y2); ctx.lineTo(hx1, hy1);
    ctx.moveTo(x2, y2); ctx.lineTo(hx2, hy2);
    ctx.lineWidth = lw*2;
    ctx.strokeStyle = colorBase;
    ctx.stroke();

    // head top
    ctx.beginPath();
    ctx.moveTo(x2, y2); ctx.lineTo(hx1, hy1);
    ctx.moveTo(x2, y2); ctx.lineTo(hx2, hy2);
    ctx.lineWidth = lw;
    ctx.strokeStyle = colorTop;
    ctx.stroke();
  }

  // ---------- collision helpers ----------
  function circleHitsRect(cx, cy, r, rx, ry, rw, rh){
    const px = clamp(cx, rx, rx + rw);
    const py = clamp(cy, ry, ry + rh);
    return Math.hypot(cx - px, cy - py) <= r;
  }

  function soldierCollidesBuildings(x, y, r, buildings){
    for(const b of buildings){
      if(circleHitsRect(x, y, r, b.x, b.y, b.w, b.h)) return true;
    }
    return false;
  }

  function pushCircleOutOfBuildings(x, y, r, buildings){
    let px = x, py = y;
    const eps = 0.25; // world units (~3 inches if 1 unit = 1 ft)
    for(let iter=0; iter<10; iter++){
      let any = false;
      for(const b of buildings){
        const cx = clamp(px, b.x, b.x + b.w);
        const cy = clamp(py, b.y, b.y + b.h);
        const dx = px - cx;
        const dy = py - cy;
        const d = Math.hypot(dx, dy);

        if(d > r + 1e-6) continue;
        any = true;

        if(d > 1e-6){
          const push = (r - d) + eps;
          px += (dx / d) * push;
          py += (dy / d) * push;
        } else {
          // Center is inside the rect: push out to nearest edge.
          const left = px - b.x;
          const right = (b.x + b.w) - px;
          const top = py - b.y;
          const bottom = (b.y + b.h) - py;
          const m = Math.min(left, right, top, bottom);
          if(m === left) px = b.x - r - eps;
          else if(m === right) px = b.x + b.w + r + eps;
          else if(m === top) py = b.y - r - eps;
          else py = b.y + b.h + r + eps;
        }
      }
      if(!any) break;
    }
    return {x: px, y: py};
  }

  function terrainResistanceFactor(x, y, terrains){
    // Mild drag resistance (NOT a hard blocker) for woods + rough.
    let factor = 1;
    for(const t of terrains){
      const typ = (t && t.terrainType) ? t.terrainType : "open";
      if(typ !== "woods" && typ !== "rough" && typ !== "hills") continue;
      if(!t.points || t.points.length < 3) continue;
      if(pointInPoly({x, y}, t.points)){
        const f = (typ === "woods") ? 0.85 : 0.92;
        if(f < factor) factor = f;
      }
    }
    return factor;
  }

  function resolveSoldierDragAgainstBuildings(baseX, baseY, dx, dy, r, buildings){
    if(!buildings || buildings.length === 0) return {x: baseX + dx, y: baseY + dy};

    const collides = (x, y) => soldierCollidesBuildings(x, y, r, buildings);

    const sx = baseX, sy = baseY;
    const ex = baseX + dx, ey = baseY + dy;

    const sC = collides(sx, sy);
    const eC = collides(ex, ey);

    if(!sC && !eC) return {x: ex, y: ey};

    // Starting inside a building and ending clear: snap to the earliest clear point on the segment.
    if(sC && !eC){
      let lo = 0, hi = 1;
      for(let i=0; i<22; i++){
        const mid = (lo + hi) / 2;
        const x = sx + dx * mid;
        const y = sy + dy * mid;
        if(collides(x, y)) lo = mid;
        else hi = mid;
      }
      return {x: sx + dx * hi, y: sy + dy * hi};
    }

    // Moving into collision: clamp to the farthest clear point on the segment.
    if(!sC){
      let lo = 0, hi = 1;
      for(let i=0; i<22; i++){
        const mid = (lo + hi) / 2;
        const x = sx + dx * mid;
        const y = sy + dy * mid;
        if(collides(x, y)) hi = mid;
        else lo = mid;
      }
      return {x: sx + dx * lo, y: sy + dy * lo};
    }

    // Still stuck inside: nudge out so you can drag away.
    return pushCircleOutOfBuildings(sx, sy, r, buildings);
  }

  function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh){
    return (ax < bx + bw) && (ax + aw > bx) && (ay < by + bh) && (ay + ah > by);
  }

  function buildingCollidesBuildings(x, y, w, h, buildings, selfId){
    for(const b of buildings){
      if(selfId && b.id === selfId) continue;
      if(rectsOverlap(x, y, w, h, b.x, b.y, b.w, b.h)) return true;
    }
    return false;
  }

  function resolveBuildingDragAgainstBuildings(base, dx, dy, buildings){
    if(!buildings || buildings.length === 0) return {x: base.x + dx, y: base.y + dy};

    const sx = base.x, sy = base.y;
    const ex = base.x + dx, ey = base.y + dy;
    const w = base.w, h = base.h;
    const selfId = base.id;

    const collides = (x, y) => buildingCollidesBuildings(x, y, w, h, buildings, selfId);

    const sC = collides(sx, sy);
    const eC = collides(ex, ey);

    if(!sC && !eC) return {x: ex, y: ey};

    // Starting overlapped but ending clear: snap to the earliest clear point on the segment.
    if(sC && !eC){
      let lo = 0, hi = 1;
      for(let i=0; i<22; i++){
        const mid = (lo + hi) / 2;
        const x = sx + dx * mid;
        const y = sy + dy * mid;
        if(collides(x, y)) lo = mid;
        else hi = mid;
      }
      return {x: sx + dx * hi, y: sy + dy * hi};
    }

    // Moving into collision: clamp to the farthest clear point.
    if(!sC){
      let lo = 0, hi = 1;
      for(let i=0; i<22; i++){
        const mid = (lo + hi) / 2;
        const x = sx + dx * mid;
        const y = sy + dy * mid;
        if(collides(x, y)) hi = mid;
        else lo = mid;
      }
      return {x: sx + dx * lo, y: sy + dy * lo};
    }

    // Still overlapped: don't move on this frame.
    return {x: sx, y: sy};
  }


  // ---------- fire-cone occlusion helpers ----------
  function rgbaWithAlpha(rgba, a){
    const m = (rgba||"").match(/rgba\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9.]+)\s*\)/i);
    if(!m) return rgba;
    const aa = clamp(a, 0, 1);
    return `rgba(${m[1]},${m[2]},${m[3]},${aa})`;
  }

  function rayRectHitDist(ox, oy, dx, dy, rect){
    const minX = rect.x, maxX = rect.x + rect.w;
    const minY = rect.y, maxY = rect.y + rect.h;

    let tmin = -Infinity;
    let tmax = Infinity;

    if(Math.abs(dx) < 1e-12){
      if(ox < minX || ox > maxX) return Infinity;
    } else {
      let tx1 = (minX - ox) / dx;
      let tx2 = (maxX - ox) / dx;
      if(tx1 > tx2){ const tmp = tx1; tx1 = tx2; tx2 = tmp; }
      tmin = Math.max(tmin, tx1);
      tmax = Math.min(tmax, tx2);
    }

    if(Math.abs(dy) < 1e-12){
      if(oy < minY || oy > maxY) return Infinity;
    } else {
      let ty1 = (minY - oy) / dy;
      let ty2 = (maxY - oy) / dy;
      if(ty1 > ty2){ const tmp = ty1; ty1 = ty2; ty2 = tmp; }
      tmin = Math.max(tmin, ty1);
      tmax = Math.min(tmax, ty2);
    }

    if(tmax < 0 || tmax < tmin) return Infinity;
    return (tmin < 0) ? 0 : tmin;
  }

  function rayFirstBuildingHit(ox, oy, dx, dy, maxDist, buildings){
    let best = Infinity;
    for(const b of buildings || []){
      const d = rayRectHitDist(ox, oy, dx, dy, b);
      if(d < best && d <= maxDist) best = d;
    }
    return best;
  }

  function terrainTypeAtPoint(x, y, terrains){
    for(const t of terrains || []){
      const typ = (t && t.terrainType) ? t.terrainType : "open";
      if(typ !== "woods" && typ !== "rough" && typ !== "hills") continue;
      if(!t.points || t.points.length < 3) continue;
      if(pointInPoly({x, y}, t.points)) return typ;
    }
    return null;
  }

  function rayFirstTerrainEntry(ox, oy, dx, dy, maxDist, terrains){
    const step = 12; // ft
    let lastType = terrainTypeAtPoint(ox, oy, terrains);
    for(let d=step; d<=maxDist; d+=step){
      const x = ox + dx * d;
      const y = oy + dy * d;
      const typ = terrainTypeAtPoint(x, y, terrains);
      if(!lastType && typ){
        // refine entry between d-step .. d
        let lo = Math.max(0, d - step);
        let hi = d;
        for(let it=0; it<8; it++){
          const mid = (lo + hi) * 0.5;
          const mx = ox + dx * mid;
          const my = oy + dy * mid;
          const mt = terrainTypeAtPoint(mx, my, terrains);
          if(mt) hi = mid;
          else lo = mid;
        }
        return {dist: hi, type: typ};
      }
      lastType = typ;
    }
    return null;
  }
  // --- Terrain math helpers (range budget + directional hills / woods) ---
  const EYE_HEIGHT_FT = 6;

  function clamp01(v){ return (v < 0) ? 0 : ((v > 1) ? 1 : v); }

  function getHillsAtPoint(x, y, terrains){
    const out = [];
    for(const t of terrains || []){
      if(!t) continue;
      const typ = (t && t.terrainType) ? t.terrainType : "open";
      if(typ !== "hills") continue;
      if(!t.points || t.points.length < 3) continue;
      if(pointInPoly({x, y}, t.points)) out.push(t);
    }
    return out;
  }

  function getHillsOriginRangeBonus(x, y, terrains){
    let bonus = 1.0;
    for(const t of getHillsAtPoint(x, y, terrains)){
      const b = (typeof t.hillsRangeBonus === "number" && isFinite(t.hillsRangeBonus)) ? t.hillsRangeBonus : 1.25;
      if(b > bonus) bonus = b;
    }
    return bonus;
  }

  // Cache per-hill projection extents for elevation calculations.
  const _hillMetaCache = new WeakMap();
  function hillMeta(t){
    const dirDeg = (typeof t.hillsDirDeg === "number" && isFinite(t.hillsDirDeg)) ? t.hillsDirDeg : 0;
    const pts = t.points || [];
    const key = dirDeg + "|" + pts.length + "|" + (pts[0] ? (pts[0].x + "," + pts[0].y) : "");
    const prev = _hillMetaCache.get(t);
    if(prev && prev._key === key) return prev;

    // 0° = up-screen, 90° = right.
    const ang = (dirDeg - 90) * Math.PI / 180;
    const ux = Math.cos(ang), uy = Math.sin(ang);

    let minP = Infinity, maxP = -Infinity;
    for(const p of pts){
      const pr = p.x * ux + p.y * uy;
      if(pr < minP) minP = pr;
      if(pr > maxP) maxP = pr;
    }
    if(!isFinite(minP) || !isFinite(maxP) || Math.abs(maxP - minP) < 1e-6){
      minP = 0; maxP = 1;
    }
    const meta = {ux, uy, minP, maxP, _key: key};
    _hillMetaCache.set(t, meta);
    return meta;
  }

  // Simple per-point elevation contributed by any hills polygon you are inside.
  function hillsElevationAtPoint(x, y, terrains){
    let z = 0;
    for(const t of getHillsAtPoint(x, y, terrains)){
      const H = (typeof t.hillsHeightFt === "number" && isFinite(t.hillsHeightFt)) ? t.hillsHeightFt : 30;
      const shape = (typeof t.hillsShape === "string" ? t.hillsShape : "ramp");
      const m = hillMeta(t);

      const pr = x * m.ux + y * m.uy;
      const s = clamp01((pr - m.minP) / (m.maxP - m.minP)); // 0..1 across the polygon, along the slope direction

      let h = 0;
      if(shape === "ridge"){
        h = H * (1 - 2 * Math.abs(s - 0.5)); // peak at center
      } else if(shape === "bowl"){
        h = H * (2 * Math.abs(s - 0.5)); // low in center, high at edges
      } else {
        h = H * s; // ramp
      }
      if(h > z) z = h;
    }
    return z;
  }

  // Option-2 range math: budget spent = segmentLength / f(terrain).  (f<1 shrinks range, f>1 extends.)
  function terrainRangeFactorAt(x, y, terrains){
    const typ = terrainTypeAtPoint(x, y, terrains);
    if(typ === "woods") return 0.55;
    if(typ === "rough") return 0.75;
    if(typ === "hills"){
      // Optional: allow travel-factor tuning, but default is 1.0 (hills advantage is mainly the origin bonus).
      let f = 1.0;
      for(const t of getHillsAtPoint(x, y, terrains)){
        const tf = (typeof t.hillsTravelFactor === "number" && isFinite(t.hillsTravelFactor)) ? t.hillsTravelFactor : 1.0;
        if(tf > f) f = tf;
      }
      return f;
    }
    return 1.0;
  }

  function computeBudgetRangeDist(ox, oy, dx, dy, budgetFt, terrains){
    const step = 12; // ft
    let spent = 0;
    let d = 0;
    const maxD = budgetFt * 3; // safety guard (in case factors > 1)
    for(let iter=0; iter<20000 && d < maxD; iter++){
      const seg = Math.min(step, maxD - d);
      const mx = ox + dx * (d + seg * 0.5);
      const my = oy + dy * (d + seg * 0.5);
      const f = Math.max(1e-6, terrainRangeFactorAt(mx, my, terrains));
      const cost = seg / f;

      if(spent + cost >= budgetFt){
        const rem = budgetFt - spent;
        d += rem * f;
        return d;
      }
      spent += cost;
      d += seg;
    }
    return d;
  }

  
  // 2.5D LOS: horizon scan over terrain elevation + building roofs.
  // Returns farthest distance (<=maxDist) where the ground is visible from the shooter's eye height.
  function buildingVerticalHeightFt(b){
    const floors = (typeof b.floors === "number" && isFinite(b.floors)) ? b.floors : 1;
    const fh = (typeof b.floorHeightFt === "number" && isFinite(b.floorHeightFt)) ? b.floorHeightFt : 10;
    const roof = (typeof b.roofExtraFt === "number" && isFinite(b.roofExtraFt)) ? b.roofExtraFt : 0;
    return Math.max(0, floors) * fh + Math.max(0, roof);
  }

  function buildingContainsPoint(b, x, y){
    if(!b) return false;
    const x2 = b.x + b.w;
    const y2 = b.y + b.h;
    const minX = Math.min(b.x, x2), maxX = Math.max(b.x, x2);
    const minY = Math.min(b.y, y2), maxY = Math.max(b.y, y2);
    return (x >= minX && x <= maxX && y >= minY && y <= maxY);
  }

  function highestBuildingAtPoint(x, y, buildings, terrains){
    let best = null;
    let bestZ = -Infinity;
    for(const b of (buildings || [])){
      if(!buildingContainsPoint(b, x, y)) continue;
      const zGround = hillsElevationAtPoint(x, y, terrains);
      const zRoof = zGround + buildingVerticalHeightFt(b);
      if(zRoof > bestZ){
        bestZ = zRoof;
        best = b;
      }
    }
    return best;
  }

  function buildingRoofInfoAtPoint(x, y, buildings, terrains, shooterBuilding){
    let roofZ = -Infinity;
    let insideAny = false;
    let insideShooter = false;

    for(const b of (buildings || [])){
      if(!buildingContainsPoint(b, x, y)) continue;
      insideAny = true;

      if(shooterBuilding && b.id === shooterBuilding.id){
        insideShooter = true;
        // Ignore the shooter's own roof until we exit the footprint.
        continue;
      }

      const zGround = hillsElevationAtPoint(x, y, terrains);
      const z = zGround + buildingVerticalHeightFt(b);
      if(z > roofZ) roofZ = z;
    }

    return {roofZ, insideAny, insideShooter};
  }

  function rayFarthestVisibleGround(ox, oy, dx, dy, maxDist, terrains, buildings, shooterZOffsetFt){
    const step = 12; // ft
    if(maxDist <= 0) return 0;

    // If the shooter is inside a building, ignore that building's roof until we exit it.
    const shooterBuilding = highestBuildingAtPoint(ox, oy, buildings, terrains);

    const z0 = hillsElevationAtPoint(ox, oy, terrains) + (isFinite(shooterZOffsetFt) ? shooterZOffsetFt : 0) + EYE_HEIGHT_FT;
    let maxSlopeObs = -Infinity;
    let farthestVisible = 0;

    for(let d=step; d<=maxDist; d+=step){
      const x = ox + dx * d;
      const y = oy + dy * d;

      const zGround = hillsElevationAtPoint(x, y, terrains);
      const info = buildingRoofInfoAtPoint(x, y, buildings, terrains, shooterBuilding);
      const zObs = Math.max(zGround, info.roofZ);

      const slopeGround = (zGround - z0) / d;
      let visible = slopeGround >= (maxSlopeObs - 1e-6);

      // Ground points inside opaque buildings (except the shooter's own building) are not valid targets.
      if(info.insideAny && !info.insideShooter) visible = false;

      if(visible) farthestVisible = d;

      const slopeObs = (zObs - z0) / d;
      if(slopeObs > maxSlopeObs) maxSlopeObs = slopeObs;
    }
    return farthestVisible;
  }

  // Backward-compatible name (older code called this "hill occlusion")
  function rayFirstHillOcclusion(ox, oy, dx, dy, maxDist, terrains, buildings, shooterZOffsetFt){
    return rayFarthestVisibleGround(ox, oy, dx, dy, maxDist, terrains, buildings, shooterZOffsetFt);
  }


  // Directional woods cover (0..1), based on how deep the target is from the shooter-facing edge.
  // (Utility for future hit/cover previews.)
  function woodsCoverFraction(shooterX, shooterY, targetX, targetY, terrains){
    const dx = targetX - shooterX;
    const dy = targetY - shooterY;
    const dist = Math.hypot(dx, dy);
    if(dist < 1e-6) return 0;

    const ux = dx / dist, uy = dy / dist;
    let best = 0;

    for(const t of terrains || []){
      if(!t) continue;
      const typ = (t && t.terrainType) ? t.terrainType : "open";
      if(typ !== "woods") continue;
      if(!t.points || t.points.length < 3) continue;
      if(!pointInPoly({x: targetX, y: targetY}, t.points)) continue;

      const front = rayDistToPolyBoundary(targetX, targetY, -ux, -uy, t.points);
      const back  = rayDistToPolyBoundary(targetX, targetY,  ux,  uy, t.points);
      const total = front + back;

      if(total > 1e-6){
        const frac = clamp01(front / total);
        if(frac > best) best = frac;
      }
    }
    return best;
  }

  function rayDistToPolyBoundary(px, py, dx, dy, poly){
    let best = Infinity;
    const n = poly.length;
    for(let i=0;i<n;i++){
      const a = poly[i];
      const b = poly[(i+1)%n];
      const t = raySegIntersect(px, py, dx, dy, a.x, a.y, b.x, b.y);
      if(t != null && t > 1e-6 && t < best) best = t;
    }
    return isFinite(best) ? best : 0;
  }

  // Ray (p + d*t) vs segment (a->b). Returns t on ray, or null.
  function raySegIntersect(px, py, dx, dy, ax, ay, bx, by){
    const rx = dx, ry = dy;
    const sx = bx - ax, sy = by - ay;
    const rxs = rx * sy - ry * sx;
    if(Math.abs(rxs) < 1e-12) return null; // parallel
    const qpx = ax - px, qpy = ay - py;
    const t = (qpx * sy - qpy * sx) / rxs;
    const u = (qpx * ry - qpy * rx) / rxs;
    if(u < -1e-9 || u > 1 + 1e-9) return null;
    return t;
  }


  function drawConeAttenuationRuns(ctx, ox, oy, dirs, outerD, entryD, entryT, typeKey, fillStyle){
    const eps = 1e-3;
    let i = 0;
    while(i < dirs.length){
      while(i < dirs.length && !(entryT[i] === typeKey && entryD[i] < outerD[i] - eps)) i++;
      if(i >= dirs.length) break;
      let j = i;
      while(j < dirs.length && (entryT[j] === typeKey && entryD[j] < outerD[j] - eps)) j++;
      const i0 = i, i1 = j - 1;
      if(i1 - i0 >= 1){
        ctx.beginPath();
        // outer edge
        ctx.moveTo(ox + dirs[i0].x * outerD[i0], oy + dirs[i0].y * outerD[i0]);
        for(let k=i0+1; k<=i1; k++){
          ctx.lineTo(ox + dirs[k].x * outerD[k], oy + dirs[k].y * outerD[k]);
        }
        // inner edge (back)
        for(let k=i1; k>=i0; k--){
          ctx.lineTo(ox + dirs[k].x * entryD[k], oy + dirs[k].y * entryD[k]);
        }
        ctx.closePath();
        ctx.fillStyle = fillStyle;
        ctx.fill();
      }
      i = j;
    }
  }


  // ---------- DOM ----------
  const canvas = document.getElementById("mapCanvas");
  const container = document.getElementById("canvasContainer");

  const toolSelect = document.getElementById("toolSelect");
  const soldierSide = document.getElementById("soldierSide");
  const pickSoldiers = document.getElementById("pickSoldiers");
  const pickBuildings = document.getElementById("pickBuildings");
  const pickRoads = document.getElementById("pickRoads");
  const pickTerrains = document.getElementById("pickTerrains");
  const pickOnlySoldiersBtn = document.getElementById("pickOnlySoldiersBtn");
  const pickAllLayersBtn = document.getElementById("pickAllLayersBtn");
  const finishShapeBtn = document.getElementById("finishShapeBtn");
  const undoBtn = document.getElementById("undoBtn");
  const clearBtn = document.getElementById("clearBtn");

  const placeSquadFormationBtn = document.getElementById("placeSquadFormationBtn");
  const squadSizeEl = document.getElementById("squadSize");
const squadFormation = document.getElementById("squadFormation");
  const squadSpacingEl = document.getElementById("squadSpacing");

  const placePlatoonFormationBtn = document.getElementById("placePlatoonFormationBtn");
  const platoonFormation = document.getElementById("platoonFormation");
  const platoonSpacingEl = document.getElementById("platoonSpacing");

  const centerViewBtn = document.getElementById("centerViewBtn");
  const toggleGridBtn = document.getElementById("toggleGridBtn");
  const zoomReadout = document.getElementById("zoomReadout");
  const panReadout = document.getElementById("panReadout");

  const selectionPill = document.getElementById("selectionPill");
  const inspectorBody = document.getElementById("inspectorBody");
  const inspectorTable = document.getElementById("inspectorTable");
  const toolReadout = document.getElementById("toolReadout");
  const mouseReadout = document.getElementById("mouseReadout");

  const deleteSelectedBtn = document.getElementById("deleteSelectedBtn");
  const duplicateSelectedBtn = document.getElementById("duplicateSelectedBtn");
  const deselectAllBtn = document.getElementById("deselectAllBtn");

  const exportMapBtn = document.getElementById("exportMapBtn");
  const importMapBtn = document.getElementById("importMapBtn");
  const importMapFile = document.getElementById("importMapFile");
  const toggleRangesBtn = document.getElementById("toggleRangesBtn");
  const toggleConesBtn = document.getElementById("toggleConesBtn");
  const toggleMovePathsBtn = document.getElementById("toggleMovePathsBtn");
  const simPlayBtn = document.getElementById("simPlayBtn");
  const simResetBtn = document.getElementById("simResetBtn");
  const simSpeed = document.getElementById("simSpeed");
  const simSpeedReadout = document.getElementById("simSpeedReadout");
  const simTimeReadout = document.getElementById("simTimeReadout");

  const moveSpeed = document.getElementById("moveSpeed");
  const moveFaceMove = document.getElementById("moveFaceMove");

  const movePreserveFormation = document.getElementById("movePreserveFormation");

  // --- image overlay UI ---
  const overlayUploadBtn = document.getElementById("overlayUploadBtn");
  const overlayFile = document.getElementById("overlayFile");
  const overlayClearBtn = document.getElementById("overlayClearBtn");
  const overlayVisible = document.getElementById("overlayVisible");
  const overlayDrag = document.getElementById("overlayDrag");
  const overlayOpacity = document.getElementById("overlayOpacity");
  const overlayOpacityReadout = document.getElementById("overlayOpacityReadout");
  const overlayScale = document.getElementById("overlayScale");
  const overlayRotation = document.getElementById("overlayRotation");
  const overlayX = document.getElementById("overlayX");
  const overlayY = document.getElementById("overlayY");
  const overlayCenterBtn = document.getElementById("overlayCenterBtn");
  const overlayFitBtn = document.getElementById("overlayFitBtn");
  const overlayResetBtn = document.getElementById("overlayResetBtn");
// ---------- state ----------
  const state = {
    zoom: 1,
    panX: 0, // css px
    panY: 0,
    showGrid: false,

    overlay: {
      dataUrl: null,   // data: URL of the image
      visible: true,
      opacity: 0.6,
      cx: 0,           // center in world units
      cy: 0,
      scale: 1,
      rotation: 0,     // degrees
      dragMode: false, // when true, dragging on canvas moves the overlay
      dragging: false,
      _dragStart: null
    },


    rangeDisplay: "selected", // off | selected | all
        coneDisplay: "off",      // off | selected | all

    movePathDisplay: "selected", // off | selected | all
    moveSettings: { speedFps: 6, faceMove: true, preserveFormation: true },

    sim: { playing:false, speed:1, t:0, lastTs:0, origin:null, plans:null, lastInspectorUpdate:0 },

    tool: "select",

    // Which kinds are selectable (click / marquee). Helps when layers overlap.
    pickFilter: {soldier:true, building:false, road:false, terrain:false},

    soldiers: [], // {id, x,y, side, label, r}
    buildings: [], // {id, x,y,w,h, name}
    roads: [], // {id, points:[{x,y}], width, roadType, name}
    terrains: [], // {id, points:[{x,y}], terrainType, name, opacity}

    selected: null, // primary selection {kind, id}
    selectedMulti: [], // multi-selection refs (when marquee-selecting)
    boxSelect: null, // {active,sx0,sy0,sx1,sy1,previewRefs:[]}
    hover: null,

    drawing: null, // {kind:'road'|'terrain'|'building', ...}
    lastMouse: {sx:0, sy:0, x:0, y:0}, // screen + world
    isPanning: false,
    
    panPending: false,
isDraggingSelection: false,
    dragStart: null, // {sx,sy, panX,panY} or {x,y} world
    spaceDown: false,

    
    shiftDown: false,
undo: [] // stack of actions
  };

  const TERRAIN_TYPES = [
    {key:"open",  label:"Open",  fill:"rgba(34,197,94,OP)"},
    {key:"woods", label:"Woods", fill:"rgba(16,185,129,OP)"},
    {key:"hills", label:"Hills", fill:"rgba(168,85,247,OP)"},
    {key:"urban", label:"Urban", fill:"rgba(148,163,184,OP)"},
    {key:"water", label:"Water", fill:"rgba(56,189,248,OP)"},
    {key:"rough", label:"Rough", fill:"rgba(250,204,21,OP)"}
  ];

  const ROAD_TYPES = [
    {key:"paved", label:"Paved", stroke:"rgba(148,163,184,1)"},
    {key:"dirt", label:"Dirt", stroke:"rgba(217,119,6,1)"},
    {key:"trail", label:"Trail", stroke:"rgba(234,179,8,1)"},
    {key:"track", label:"Track", stroke:"rgba(203,213,225,1)"}
  ];

  
  // Soldier range (ft). Guns/loadouts removed: range is set directly per soldier.
  const DEFAULT_SOLDIER_RANGE_FT = 1312;

  // Legacy weapon ranges for importing older save files only (older maps stored `soldier.weapon`).
  const LEGACY_WEAPON_RANGE_FT = {
    pistol: 164,
    smg: 492,
    carbine: 1312,
    dmr: 1969,
    lmg: 1969,
    gpmg: 2625,
    sniper: 3281,
    akm: 984,
    ak74: 1312,
    rpk: 1969,
    pkm: 2625,
    svd: 1969
  };

  function getSoldierRangeFt(s){
    const r = (s && typeof s.rangeFt === "number" && isFinite(s.rangeFt) && s.rangeFt > 0) ? s.rangeFt : null;
    if(r) return r;
    const wk = s && s.weapon;
    if(wk && LEGACY_WEAPON_RANGE_FT[wk]) return LEGACY_WEAPON_RANGE_FT[wk];
    return DEFAULT_SOLDIER_RANGE_FT;
  }



  // ---------- world/screen transforms ----------
  let dpr = window.devicePixelRatio || 1;
  function resize(){
    dpr = window.devicePixelRatio || 1;
    const w = container.clientWidth;
    const h = container.clientHeight;
    canvas.width  = Math.max(1, Math.floor(w * dpr));
    canvas.height = Math.max(1, Math.floor(h * dpr));
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    updateCursor();
    draw();
  }

  function screenToWorld(sx, sy){
    // sx,sy are CSS pixels relative to canvas top-left
    return {
      x: (sx - state.panX) / state.zoom,
      y: (sy - state.panY) / state.zoom
    };
  }
  function worldToScreen(x, y){
    return {
      sx: x * state.zoom + state.panX,
      sy: y * state.zoom + state.panY
    };
  }

  // ---------- data helpers ----------
  function getByRef(ref){
    if(!ref) return null;
    const {kind, id} = ref;
    const list = kind==="soldier" ? state.soldiers :
                 kind==="building"? state.buildings :
                 kind==="road"    ? state.roads :
                 kind==="terrain" ? state.terrains : null;
    if(!list) return null;
    return list.find(o => o.id === id) || null;
  }

  function removeByRef(ref){
    if(!ref) return false;
    const {kind, id} = ref;
    const key = kind==="soldier" ? "soldiers" :
                kind==="building"? "buildings" :
                kind==="road"    ? "roads" :
                kind==="terrain" ? "terrains" : null;
    if(!key) return false;
    const idx = state[key].findIndex(o => o.id === id);
    if(idx>=0){ state[key].splice(idx,1); return true; }
    return false;
  }

  function pushUndo(action){
    state.undo.push(action);
    if(state.undo.length > 200) state.undo.shift();
    updateUndoButton();
  }

  function canUndoDrawing(){
    if(!state.drawing) return false;
    if(state.drawing.kind === "road" || state.drawing.kind === "terrain"){
      return Array.isArray(state.drawing.points) && state.drawing.points.length > 0;
    }
    // building: allow cancel while drawing
    if(state.drawing.kind === "building"){
      return !!state.drawing.start;
    }
    return false;
  }

  function updateUndoButton(){
    undoBtn.disabled = (state.undo.length === 0) && !canUndoDrawing();
  }


  function addObjects(objs){
    // objs: [{kind, data}]
    const ids = [];
    for (const o of objs){
      ensureHumanId(o.kind, o.data);
      if(o.kind==="soldier"){ state.soldiers.push(o.data); ids.push({kind:"soldier", id:o.data.id}); }
      if(o.kind==="building"){ state.buildings.push(o.data); ids.push({kind:"building", id:o.data.id}); }
      if(o.kind==="road"){ state.roads.push(o.data); ids.push({kind:"road", id:o.data.id}); }
      if(o.kind==="terrain"){ state.terrains.push(o.data); ids.push({kind:"terrain", id:o.data.id}); }
    }
    pushUndo({kind:"add", refs: ids});
    return ids;
  }

  function deleteSelected(){
    const refs = (state.selectedMulti && state.selectedMulti.length) ? state.selectedMulti.slice()
               : (state.selected ? [deepClone(state.selected)] : []);
    if(!refs.length) return;

    const items = [];
    for(const ref of refs){
      const obj = getByRef(ref);
      if(!obj) continue;
      items.push({ref: deepClone(ref), data: deepClone(obj)});
    }
    if(!items.length) return;

    // remove
    for(const it of items){
      removeByRef(it.ref);
    }
    pushUndo({kind:"delete", items});
    state.selected = null;
    state.selectedMulti = [];
    renderInspector();
    updateCursor();
    draw();
  }

  
  // ---------- layering (within type: terrain < roads < buildings < soldiers) ----------
  function arrayForKind(kind){
    if(kind==="soldier") return state.soldiers;
    if(kind==="building") return state.buildings;
    if(kind==="road") return state.roads;
    if(kind==="terrain") return state.terrains;
    return null;
  }

  function setIdOrderForKind(kind, ids){
    const arr = arrayForKind(kind);
    if(!arr) return;
    const byId = new Map(arr.map(o=>[o.id, o]));
    const newArr = [];
    for(const id of ids){
      const o = byId.get(id);
      if(o){ newArr.push(o); byId.delete(id); }
    }
    // Append any objects that weren't in the saved order (new ones, etc)
    for(const o of arr){
      if(byId.has(o.id)) newArr.push(o);
    }
    arr.splice(0, arr.length, ...newArr);
  }

  function reorderWithinKind(kind, selectedIds, action){
    const arr = arrayForKind(kind);
    if(!arr) return null;
    const before = arr.map(o=>o.id);

    const sel = new Set(selectedIds || []);
    if(sel.size===0) return null;

    if(action==="front"){
      const keep = arr.filter(o=>!sel.has(o.id));
      const moved = arr.filter(o=>sel.has(o.id));
      arr.splice(0, arr.length, ...keep, ...moved);
    } else if(action==="back"){
      const keep = arr.filter(o=>!sel.has(o.id));
      const moved = arr.filter(o=>sel.has(o.id));
      arr.splice(0, arr.length, ...moved, ...keep);
    } else if(action==="forward"){
      // one step towards front (end of array)
      for(let i=arr.length-2;i>=0;i--){
        if(sel.has(arr[i].id) && !sel.has(arr[i+1].id)){
          const tmp = arr[i]; arr[i]=arr[i+1]; arr[i+1]=tmp;
        }
      }
    } else if(action==="backward"){
      // one step towards back (start of array)
      for(let i=1;i<arr.length;i++){
        if(sel.has(arr[i].id) && !sel.has(arr[i-1].id)){
          const tmp = arr[i]; arr[i]=arr[i-1]; arr[i-1]=tmp;
        }
      }
    }

    const after = arr.map(o=>o.id);
    const same = (before.length===after.length) && before.every((x,i)=>x===after[i]);
    if(same) return null;

    return {before, after};
  }

  function reorderSelection(refs, action){
    // action: back | backward | forward | front
    const refsList = (refs && refs.length) ? refs : [];
    if(refsList.length===0) return;

    // Snapshot per-kind BEFORE orders so Undo can restore exactly
    const groups = {soldier:[], building:[], road:[], terrain:[]};
    for(const r of refsList){
      if(groups[r.kind]) groups[r.kind].push(r.id);
    }

    const orders = [];
    let changed = false;
    for(const kind of ["soldier","building","road","terrain"]){
      const ids = groups[kind];
      if(!ids || ids.length===0) continue;
      const res = reorderWithinKind(kind, ids, action);
      if(res){
        orders.push({kind, before: res.before});
        changed = true;
      }
    }

    if(changed){
      pushUndo({kind:"reorder", orders});
      renderInspector();
      updateCursor();
      draw();
    }
  }

  function setupLayerButtons(){
    const btnBack   = document.getElementById("layerToBackBtn");
    const btnBwd    = document.getElementById("layerBackwardBtn");
    const btnFwd    = document.getElementById("layerForwardBtn");
    const btnFront  = document.getElementById("layerToFrontBtn");

    const getRefs = ()=>{
      return (state.selectedMulti && state.selectedMulti.length) ? state.selectedMulti
           : (state.selected ? [state.selected] : []);
    };

    if(btnBack)  btnBack.onclick  = ()=> reorderSelection(getRefs(), "back");
    if(btnBwd)   btnBwd.onclick   = ()=> reorderSelection(getRefs(), "backward");
    if(btnFwd)   btnFwd.onclick   = ()=> reorderSelection(getRefs(), "forward");
    if(btnFront) btnFront.onclick = ()=> reorderSelection(getRefs(), "front");
  }

function duplicateSelected(){
    const refs = (state.selectedMulti && state.selectedMulti.length) ? state.selectedMulti.slice()
               : (state.selected ? [deepClone(state.selected)] : []);
    if(!refs.length) return;

    const offset = 10; // ft (so duplicates don't overlap exactly)
    const toAdd = [];
    const newRefs = [];

    for(const ref of refs){
      const obj = getByRef(ref);
      if(!obj) continue;

      const kind = ref.kind;
      const copy = deepClone(obj);
      copy.id = allocId(kind, copy);

      if(kind==="soldier" || kind==="building"){
        copy.x += offset;
        copy.y += offset;
      } else if(kind==="road" || kind==="terrain"){
        if(Array.isArray(copy.points)){
          copy.points = copy.points.map(p => ({x:p.x + offset, y:p.y + offset}));
        }
      }

      toAdd.push({kind, data: copy});
      newRefs.push({kind, id: copy.id});
    }

    if(!toAdd.length) return;

    addObjects(toAdd);

    // Select the duplicates (single or multi)
    if(newRefs.length === 1){
      setSelection(newRefs[0]);
    } else {
      setMultiSelection(newRefs);
    }

    renderInspector();
    updateCursor();
    draw();
  }

  function undo(){
    // If we are mid-draw (road/terrain/building), undo should remove the most recent point / cancel drawing,
    // BEFORE touching the global undo stack.
    if(canUndoDrawing()){
      if(state.drawing.kind === "road" || state.drawing.kind === "terrain"){
        state.drawing.points.pop();
        if(state.drawing.points.length === 0){
          state.drawing = null;
        }
      } else if(state.drawing.kind === "building"){
        state.drawing = null;
      }
      updateUndoButton();
      renderInspector();
      updateCursor();
      draw();
      return;
    }

    const action = state.undo.pop();
    updateUndoButton();
    if(!action) return;

    if(action.kind === "add"){
      // remove all refs that were added as one action (fixes "undo removes 1 soldier" for formations)
      for (const ref of action.refs){
        if(state.selected && state.selected.kind===ref.kind && state.selected.id===ref.id){
          state.selected = null;
        }
        removeByRef(ref);
      }
    } else if(action.kind === "delete"){
      // restore deleted items
      for (const it of action.items){
        const {kind} = it.ref;
        if(kind==="soldier") state.soldiers.push(it.data);
        if(kind==="building") state.buildings.push(it.data);
        if(kind==="road") state.roads.push(it.data);
        if(kind==="terrain") state.terrains.push(it.data);
      }
    } else if(action.kind === "move"){
      // restore positions
      for (const m of action.moves){
        const obj = getByRef(m.ref);
        if(!obj) continue;
        if(m.ref.kind==="soldier"){ obj.x = m.before.x; obj.y = m.before.y; }
        if(m.ref.kind==="building"){ obj.x = m.before.x; obj.y = m.before.y; obj.w=m.before.w; obj.h=m.before.h; }
        if(m.ref.kind==="road"){ obj.points = deepClone(m.before.points); }
        if(m.ref.kind==="terrain"){ obj.points = deepClone(m.before.points); }
      }
    } else if(action.kind === "moveplan"){
      for(const ch of (action.changes || [])){
        const s = getByRef(ch.ref);
        if(!s) continue;

        if(ch.beforeMovePlan){
          s.movePlan = deepClone(ch.beforeMovePlan);
        } else {
          if("movePlan" in s) delete s.movePlan;
        }

        if(ch.hadSimHeading){
          s.simHeading = ch.beforeSimHeading;
        } else {
          if("simHeading" in s) delete s.simHeading;
        }
      }
      if(state.sim && state.sim.plans) buildSimRuntime(false);
    } else if(action.kind === "reorder"){
      if(action.orders && Array.isArray(action.orders)){
        for(const o of action.orders){
          if(o && o.kind && Array.isArray(o.before)){
            setIdOrderForKind(o.kind, o.before);
          }
        }
      }

    }
    renderInspector();
    updateCursor();
    draw();
  }

  // ---------- hit testing ----------

  function pickEnabled(kind, opts){
    // opts.ignorePickFilter can bypass the filter if we ever want a modifier key.
    if(opts && opts.ignorePickFilter) return true;
    const f = state.pickFilter;
    if(!f) return true;
    return f[kind] !== false;
  }

  function hitTestAll(worldPt, opts){
    const screenHitPx = 10;
    const hitWorld = screenHitPx / state.zoom;

    const hits = [];

    // Soldiers (top)
    if(pickEnabled("soldier", opts)){
    for (let i = state.soldiers.length - 1; i >= 0; i--){
      const s = state.soldiers[i];
      const d = Math.hypot(worldPt.x - s.x, worldPt.y - s.y);
      const thresh = (s.r||1) + hitWorld;
      if(d <= thresh){
        hits.push({kind:"soldier", id:s.id, _d:d});
      }
    }

    }

    // Buildings
    if(pickEnabled("building", opts)){
    for (let i = state.buildings.length - 1; i >= 0; i--){
      const b = state.buildings[i];
      const inside = (worldPt.x >= b.x && worldPt.x <= b.x + b.w && worldPt.y >= b.y && worldPt.y <= b.y + b.h);
      let d = Infinity;
      if(inside){
        d = 0.001; // prefer inside
      } else {
        const cx = clamp(worldPt.x, b.x, b.x + b.w);
        const cy = clamp(worldPt.y, b.y, b.y + b.h);
        d = Math.hypot(worldPt.x - cx, worldPt.y - cy);
      }
      if(d <= hitWorld*1.5){
        hits.push({kind:"building", id:b.id, _d:d});
      }
    }

    }

    // Roads
    if(pickEnabled("road", opts)){
    for (let i = state.roads.length - 1; i >= 0; i--){
      const r = state.roads[i];
      if(!r.points || r.points.length < 2) continue;
      let dMin = Infinity;
      for (let j=0;j<r.points.length-1;j++){
        dMin = Math.min(dMin, distPointToSeg(worldPt, r.points[j], r.points[j+1]));
      }
      const half = (r.width || 10) / 2;
      const thresh = half + hitWorld*1.2;
      if(dMin <= thresh){
        hits.push({kind:"road", id:r.id, _d:dMin});
      }
    }

    }

    // Terrain (bottom; weaker / non-blocking)
    if(pickEnabled("terrain", opts)){
    for (let i = state.terrains.length - 1; i >= 0; i--){
      const t = state.terrains[i];
      if(!t.points || t.points.length < 3) continue;
      const tType = t.terrainType || "open";
      const insideWeight = (tType==="woods" || tType==="rough") ? 2.0 : 0.6;
      const edgeWeight = (tType==="woods" || tType==="rough") ? 1.0 : 1.5;

      if(pointInPoly(worldPt, t.points)){
        // Inside: terrain should NOT block selecting things above it. Still selectable via Alt-cycle.
        const d = hitWorld * insideWeight;
        hits.push({kind:"terrain", id:t.id, _d:d});
      } else {
        // Edge hit
        let dMin = Infinity;
        for(let j=0;j<t.points.length;j++){
          const a = t.points[j];
          const b = t.points[(j+1) % t.points.length];
          dMin = Math.min(dMin, distPointToSeg(worldPt, a, b));
        }
        if(dMin <= hitWorld*edgeWeight){
          hits.push({kind:"terrain", id:t.id, _d:dMin});
        }
      }
    }

    }

    return hits; // already ordered top-to-bottom by our iteration
  }

  
  function hitTestSoldierTight(worldPt, bufferPx){
    const buf = (typeof bufferPx === "number") ? bufferPx : 6;
    // Screen-space tight hit: lets you drag soldiers only when you start close to them.
    for (let i = state.soldiers.length - 1; i >= 0; i--){
      const s = state.soldiers[i];
      const dx = (worldPt.x - s.x) * state.zoom;
      const dy = (worldPt.y - s.y) * state.zoom;
      const d = Math.hypot(dx, dy);
      const rPx = (s.r || 1) * state.zoom;
      if(d <= rPx + buf){
        return {kind:"soldier", id:s.id};
      }
    }
    return null;
  }

function hitTest(worldPt, opts){
    const hits = hitTestAll(worldPt, opts);
    if(!hits.length) return null;

    if(opts && opts.cycle){
      const cur = (state.selectedMulti && state.selectedMulti.length===1) ? state.selectedMulti[0] : state.selected;
      if(cur){
        const key = `${cur.kind}:${cur.id}`;
        const idx = hits.findIndex(h => `${h.kind}:${h.id}` === key);
        if(idx >= 0){
          const nxt = hits[(idx + 1) % hits.length];
          return {kind:nxt.kind, id:nxt.id};
        }
      }
    }

    return {kind:hits[0].kind, id:hits[0].id};
  }

  function nearestAnything(worldPt){
    // Used for Del when no selection.
    let best = null;
    let bestD = Infinity;

    for(const s of state.soldiers){
      const d = Math.hypot(worldPt.x-s.x, worldPt.y-s.y);
      if(d < bestD){ bestD = d; best = {kind:"soldier", id:s.id}; }
    }
    for(const b of state.buildings){
      const cx = clamp(worldPt.x, b.x, b.x+b.w);
      const cy = clamp(worldPt.y, b.y, b.y+b.h);
      const d = Math.hypot(worldPt.x-cx, worldPt.y-cy);
      if(d < bestD){ bestD = d; best = {kind:"building", id:b.id}; }
    }
    for(const r of state.roads){
      if(!r.points || r.points.length<2) continue;
      let dMin = Infinity;
      for(let i=0;i<r.points.length-1;i++){
        dMin = Math.min(dMin, distPointToSeg(worldPt, r.points[i], r.points[i+1]));
      }
      if(dMin < bestD){ bestD = dMin; best = {kind:"road", id:r.id}; }
    }
    for(const t of state.terrains){
      if(!t.points || t.points.length<3) continue;
      let dMin = Infinity;
      for(let i=0;i<t.points.length;i++){
        const a=t.points[i], b=t.points[(i+1)%t.points.length];
        dMin = Math.min(dMin, distPointToSeg(worldPt, a, b));
      }
      if(dMin < bestD){ bestD = dMin; best = {kind:"terrain", id:t.id}; }
    }
    return best;
  }

  // ---------- marquee selection helpers ----------
  function normRect(a){
    const x0 = Math.min(a.sx0, a.sx1);
    const y0 = Math.min(a.sy0, a.sy1);
    const x1 = Math.max(a.sx0, a.sx1);
    const y1 = Math.max(a.sy0, a.sy1);
    return {x0,y0,x1,y1,w:x1-x0,h:y1-y0};
  }
  function rectIntersects(r, b){
    return !(b.x1 < r.x0 || b.x0 > r.x1 || b.y1 < r.y0 || b.y0 > r.y1);
  }
  function boundsFromPointsScreen(points){
    let x0=Infinity,y0=Infinity,x1=-Infinity,y1=-Infinity;
    for(const p of points){
      const s = worldToScreen(p.x, p.y);
      x0 = Math.min(x0, s.sx); y0 = Math.min(y0, s.sy);
      x1 = Math.max(x1, s.sx); y1 = Math.max(y1, s.sy);
    }
    if(!isFinite(x0)) return null;
    return {x0,y0,x1,y1};
  }
  function getScreenBoundsForRef(ref){
    const obj = getByRef(ref);
    if(!obj) return null;

    if(ref.kind === "soldier"){
      const s = worldToScreen(obj.x, obj.y);
      const r = ((obj.r||1) * state.zoom) + 6; // pad
      return {x0:s.sx-r, y0:s.sy-r, x1:s.sx+r, y1:s.sy+r};
    }
    if(ref.kind === "building"){
      const a = worldToScreen(obj.x, obj.y);
      const b = worldToScreen(obj.x + obj.w, obj.y + obj.h);
      return {x0:Math.min(a.sx,b.sx), y0:Math.min(a.sy,b.sy), x1:Math.max(a.sx,b.sx), y1:Math.max(a.sy,b.sy)};
    }
    if(ref.kind === "road"){
      return boundsFromPointsScreen(obj.points || []);
    }
    if(ref.kind === "terrain"){
      return boundsFromPointsScreen(obj.points || []);
    }
    return null;
  }


  // ---- precise road selection for box-select ----
  function _orient(ax, ay, bx, by, cx, cy){
    return (bx-ax)*(cy-ay) - (by-ay)*(cx-ax);
  }
  function _onSeg(ax, ay, bx, by, cx, cy){
    const eps = 1e-9;
    return (Math.min(ax,bx) - eps <= cx && cx <= Math.max(ax,bx) + eps &&
            Math.min(ay,by) - eps <= cy && cy <= Math.max(ay,by) + eps);
  }
  function _segsIntersect(ax, ay, bx, by, cx, cy, dx, dy){
    const o1 = _orient(ax, ay, bx, by, cx, cy);
    const o2 = _orient(ax, ay, bx, by, dx, dy);
    const o3 = _orient(cx, cy, dx, dy, ax, ay);
    const o4 = _orient(cx, cy, dx, dy, bx, by);
    const eps = 1e-9;

    // Proper intersection
    if(((o1 > eps) !== (o2 > eps)) && ((o3 > eps) !== (o4 > eps))) return true;

    // Collinear touches
    if(Math.abs(o1) <= eps && _onSeg(ax, ay, bx, by, cx, cy)) return true;
    if(Math.abs(o2) <= eps && _onSeg(ax, ay, bx, by, dx, dy)) return true;
    if(Math.abs(o3) <= eps && _onSeg(cx, cy, dx, dy, ax, ay)) return true;
    if(Math.abs(o4) <= eps && _onSeg(cx, cy, dx, dy, bx, by)) return true;

    return false;
  }
  function _segIntersectsRect(ax, ay, bx, by, rect){
    const x0 = rect.x0, y0 = rect.y0, x1 = rect.x1, y1 = rect.y1;

    const aIn = (ax>=x0 && ax<=x1 && ay>=y0 && ay<=y1);
    const bIn = (bx>=x0 && bx<=x1 && by>=y0 && by<=y1);
    if(aIn || bIn) return true;

    // Edges (top, right, bottom, left)
    if(_segsIntersect(ax, ay, bx, by, x0, y0, x1, y0)) return true;
    if(_segsIntersect(ax, ay, bx, by, x1, y0, x1, y1)) return true;
    if(_segsIntersect(ax, ay, bx, by, x1, y1, x0, y1)) return true;
    if(_segsIntersect(ax, ay, bx, by, x0, y1, x0, y0)) return true;
    return false;
  }
  function roadIntersectsScreenRect(road, rect){
    if(!road.points || road.points.length < 2) return false;

    // Expand rect by half the road stroke in SCREEN px so selection matches visuals.
    const widthWorld = Math.max(2, road.width || 10);
    const halfPx = Math.max(3, (widthWorld * state.zoom) / 2);
    const r = {x0: rect.x0 - halfPx, y0: rect.y0 - halfPx, x1: rect.x1 + halfPx, y1: rect.y1 + halfPx};

    // Check each segment in screen space.
    for(let i=0;i<road.points.length-1;i++){
      const a = worldToScreen(road.points[i].x, road.points[i].y);
      const b = worldToScreen(road.points[i+1].x, road.points[i+1].y);
      if(_segIntersectsRect(a.sx, a.sy, b.sx, b.sy, r)) return true;
    }
    return false;
  }

  function refsInScreenRect(rect){
    const out = [];

    if(pickEnabled("soldier")){
    for(const s of state.soldiers){
      const ref = {kind:"soldier", id:s.id};
      const b = getScreenBoundsForRef(ref);
      if(b && rectIntersects(rect, b)) out.push(ref);
    }
    }
    if(pickEnabled("building")){
    for(const bld of state.buildings){
      const ref = {kind:"building", id:bld.id};
      const b = getScreenBoundsForRef(ref);
      if(b && rectIntersects(rect, b)) out.push(ref);
    }
    }
    if(pickEnabled("road")){
    for(const r of state.roads){
      const ref = {kind:"road", id:r.id};
      // Don't use the road's full bounding box (it feels like a giant hit box).
      // Instead, test segment intersection against the selection rect (padded by stroke width).
      if(roadIntersectsScreenRect(r, rect)) out.push(ref);
    }
    }
    if(pickEnabled("terrain")){
    for(const t of state.terrains){
      const ref = {kind:"terrain", id:t.id};
      const b = getScreenBoundsForRef(ref);
      if(b && rectIntersects(rect, b)) out.push(ref);
    }
    }

    return out;
  }

  // ---------- drawing ----------
  function terrainFill(typeKey, opacity){
    const t = TERRAIN_TYPES.find(x => x.key===typeKey) || TERRAIN_TYPES[0];
    const op = clamp(opacity ?? 0.35, 0.05, 0.95).toFixed(2);
    return t.fill.replace("OP", op);
  }
  function roadStroke(typeKey){
    const r = ROAD_TYPES.find(x => x.key===typeKey) || ROAD_TYPES[0];
    return r.stroke;
  }

  function drawGrid(ctx){
    const w = canvas.width / dpr;
    const h = canvas.height / dpr;
    const gridFt = 50; // 50ft squares
    const minPx = 18;
    const stepPx = gridFt * state.zoom;
    if(stepPx < minPx) return;

    const leftWorld = screenToWorld(0,0).x;
    const topWorld = screenToWorld(0,0).y;
    const rightWorld = screenToWorld(w,h).x;
    const bottomWorld = screenToWorld(w,h).y;

    const x0 = Math.floor(leftWorld / gridFt) * gridFt;
    const y0 = Math.floor(topWorld / gridFt) * gridFt;

    ctx.save();
    ctx.lineWidth = 1 / state.zoom;
    ctx.strokeStyle = "rgba(148,163,184,0.15)";
    ctx.beginPath();
    for(let x=x0; x<=rightWorld; x+=gridFt){
      ctx.moveTo(x, topWorld);
      ctx.lineTo(x, bottomWorld);
    }
    for(let y=y0; y<=bottomWorld; y+=gridFt){
      ctx.moveTo(leftWorld, y);
      ctx.lineTo(rightWorld, y);
    }
    ctx.stroke();
    ctx.restore();
  }

  
  // ---------- image overlay ----------
  let overlayImg = null;

  function hasOverlayImage(){
    return !!(state.overlay && state.overlay.dataUrl && overlayImg && overlayImg.complete && (overlayImg.naturalWidth||0) > 0);
  }

  function viewWorldRect(){
    const wCss = canvas.width / dpr;
    const hCss = canvas.height / dpr;
    const wWorld = wCss / state.zoom;
    const hWorld = hCss / state.zoom;

    const cx = (-state.panX / state.zoom) + (wWorld / 2);
    const cy = (-state.panY / state.zoom) + (hWorld / 2);
    return {cx, cy, wWorld, hWorld};
  }

  function syncOverlayUI(){
    if(!state.overlay) return;
    if(overlayClearBtn) overlayClearBtn.disabled = !state.overlay.dataUrl;
    if(overlayVisible) overlayVisible.checked = !!state.overlay.visible;
    if(overlayDrag) overlayDrag.checked = !!state.overlay.dragMode;

    const op = (typeof state.overlay.opacity === "number") ? clamp(state.overlay.opacity, 0, 1) : 0.6;
    if(overlayOpacity) overlayOpacity.value = String(op);
    if(overlayOpacityReadout) overlayOpacityReadout.textContent = op.toFixed(2);

    if(overlayScale) overlayScale.value = String((typeof state.overlay.scale === "number" && isFinite(state.overlay.scale)) ? state.overlay.scale : 1);
    if(overlayRotation) overlayRotation.value = String((typeof state.overlay.rotation === "number" && isFinite(state.overlay.rotation)) ? state.overlay.rotation : 0);

    if(overlayX) overlayX.value = String((typeof state.overlay.cx === "number" && isFinite(state.overlay.cx)) ? state.overlay.cx.toFixed(1) : "0.0");
    if(overlayY) overlayY.value = String((typeof state.overlay.cy === "number" && isFinite(state.overlay.cy)) ? state.overlay.cy.toFixed(1) : "0.0");
  }

  function overlayFitToView(){
    if(!overlayImg || !state.overlay) return;
    const {cx, cy, wWorld, hWorld} = viewWorldRect();
    const iw = overlayImg.naturalWidth || 1;
    const ih = overlayImg.naturalHeight || 1;
    const s = Math.min(wWorld / iw, hWorld / ih) * 0.95;
    state.overlay.scale = Math.max(0.0001, s);
    state.overlay.cx = cx;
    state.overlay.cy = cy;
    syncOverlayUI();
    draw();
  }

  function overlayCenterToView(){
    if(!state.overlay) return;
    const {cx, cy} = viewWorldRect();
    state.overlay.cx = cx;
    state.overlay.cy = cy;
    syncOverlayUI();
    draw();
  }

  function overlayResetTransform(){
    if(!state.overlay) return;
    const {cx, cy} = viewWorldRect();
    state.overlay.visible = true;
    state.overlay.opacity = 0.6;
    state.overlay.scale = 1;
    state.overlay.rotation = 0;
    state.overlay.cx = cx;
    state.overlay.cy = cy;
    syncOverlayUI();
    draw();
  }

  function setOverlayImageDataUrl(dataUrl){
    if(!state.overlay) return;

    if(!dataUrl){
      state.overlay.dataUrl = null;
      overlayImg = null;
      state.overlay.dragMode = false;
      state.overlay.dragging = false;
      state.overlay._dragStart = null;
      syncOverlayUI();
      updateCursor();
      draw();
      return;
    }

    state.overlay.dataUrl = dataUrl;
    overlayImg = new Image();
    overlayImg.onload = ()=>{
      // If the overlay hasn't been intentionally positioned yet, default to fit-to-view.
      const hasCustomPos = (typeof state.overlay.cx === "number" && typeof state.overlay.cy === "number" &&
                           (Math.abs(state.overlay.cx) > 1e-6 || Math.abs(state.overlay.cy) > 1e-6));
      if(!hasCustomPos){
        overlayFitToView();
      } else {
        syncOverlayUI();
        draw();
      }
    };
    overlayImg.onerror = ()=>{
      console.warn("Overlay image failed to load.");
      state.overlay.dataUrl = null;
      overlayImg = null;
      syncOverlayUI();
      updateCursor();
      draw();
    };
    overlayImg.src = dataUrl;
  }

  function drawOverlay(ctx){
    if(!hasOverlayImage()) return;
    const ov = state.overlay;
    if(!ov || !ov.visible) return;

    const iw = overlayImg.naturalWidth || 0;
    const ih = overlayImg.naturalHeight || 0;
    if(iw <= 0 || ih <= 0) return;

    const a = clamp((typeof ov.opacity === "number") ? ov.opacity : 0.6, 0, 1);
    const s = (typeof ov.scale === "number" && isFinite(ov.scale)) ? ov.scale : 1;
    const r = (typeof ov.rotation === "number" && isFinite(ov.rotation)) ? ov.rotation : 0;

    ctx.save();
    ctx.globalAlpha = a;
    ctx.translate(ov.cx || 0, ov.cy || 0);
    ctx.rotate(r * Math.PI / 180);
    ctx.scale(s, s);
    ctx.drawImage(overlayImg, -iw/2, -ih/2, iw, ih);
    ctx.restore();
  }

  function overlaySaveData(){
    const ov = state.overlay;
    if(!ov) return null;
    // IMPORTANT: we intentionally do NOT save the overlay image data (dataUrl).
    // Only alignment + display settings are stored, so the user can reload the image manually.
    return {
      visible: !!ov.visible,
      opacity: (typeof ov.opacity === "number") ? clamp(ov.opacity,0,1) : 0.6,
      cx: (typeof ov.cx === "number" && isFinite(ov.cx)) ? ov.cx : 0,
      cy: (typeof ov.cy === "number" && isFinite(ov.cy)) ? ov.cy : 0,
      scale: (typeof ov.scale === "number" && isFinite(ov.scale)) ? ov.scale : 1,
      rotation: (typeof ov.rotation === "number" && isFinite(ov.rotation)) ? ov.rotation : 0
    };
  }

  function applyOverlaySaveData(ov){
    if(!state.overlay) return;

    // If there's no overlay config in the file, keep current overlay image (if any)
    // and just reset drag state.
    if(!ov || typeof ov !== "object"){
      state.overlay.dragMode = false;
      state.overlay.dragging = false;
      state.overlay._dragStart = null;
      syncOverlayUI();
      updateCursor();
      return;
    }

    state.overlay.visible = (ov.visible !== false);
    state.overlay.opacity = (typeof ov.opacity === "number") ? clamp(ov.opacity,0,1) : 0.6;
    state.overlay.cx = (typeof ov.cx === "number" && isFinite(ov.cx)) ? ov.cx : 0;
    state.overlay.cy = (typeof ov.cy === "number" && isFinite(ov.cy)) ? ov.cy : 0;
    state.overlay.scale = (typeof ov.scale === "number" && isFinite(ov.scale) && ov.scale>0) ? ov.scale : 1;
    state.overlay.rotation = (typeof ov.rotation === "number" && isFinite(ov.rotation)) ? ov.rotation : 0;
    state.overlay.dragMode = false;
    state.overlay.dragging = false;
    state.overlay._dragStart = null;

    syncOverlayUI();

    // Back-compat: if an older save included embedded image data, we still load it,
    // but we won't export it again.
    if(typeof ov.dataUrl === "string" && ov.dataUrl.startsWith("data:image/")){
      setOverlayImageDataUrl(ov.dataUrl);
    } else {
      updateCursor();
      draw();
    }
  }

function draw(){
    const ctx = canvas.getContext("2d");
    const wCss = canvas.width / dpr;
    const hCss = canvas.height / dpr;

    // clear in screen space
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // world transform
    ctx.setTransform(dpr*state.zoom, 0, 0, dpr*state.zoom, dpr*state.panX, dpr*state.panY);

    // Build a quick lookup of selected refs (supports multi-select).
    const _selectedKeys = new Set();
    if(state.selected && state.selected.kind && state.selected.id){
      _selectedKeys.add(`${state.selected.kind}:${state.selected.id}`);
    }
    if(state.selectedMulti && state.selectedMulti.length){
      for(const ref of state.selectedMulti){
        if(ref && ref.kind && ref.id) _selectedKeys.add(`${ref.kind}:${ref.id}`);
      }
    }


    // Overlay image (bottom)
    drawOverlay(ctx);

    // Grid (world space)
    if(state.showGrid) drawGrid(ctx);

    // Terrain (below)
    for (const t of state.terrains){
      if(!t.points || t.points.length < 3) continue;

      // polygon fill
      ctx.beginPath();
      ctx.moveTo(t.points[0].x, t.points[0].y);
      for(let i=1;i<t.points.length;i++) ctx.lineTo(t.points[i].x, t.points[i].y);
      ctx.closePath();
      ctx.fillStyle = terrainFill(t.terrainType, t.opacity);
      ctx.fill();
      ctx.lineWidth = 1 / state.zoom;
      ctx.strokeStyle = "rgba(15,23,42,0.65)";
      ctx.stroke();

      // Hills slope direction arrow (points "uphill" as defined by Slope dir (deg))
      if(t.terrainType === "hills"){
        const dirDeg = (typeof t.hillsDirDeg === "number" && isFinite(t.hillsDirDeg)) ? t.hillsDirDeg : 0;
        const rad = (dirDeg - 90) * Math.PI / 180; // 0° = up-screen
        const dir = {x: Math.cos(rad), y: Math.sin(rad)};

        const p0 = pickInteriorPoint(t.points);
        const exit = rayExitDistance(p0, dir, t.points);
        const b = polyBounds(t.points);

        // Arrow length roughly scales with polygon size, but stays within the hills shape when possible.
        const sizeBased = clamp(0.35 * Math.min(b.w, b.h), 18, 80);
        let lenWorld = sizeBased;
        if(exit && exit > 10){
          lenWorld = clamp(exit * 0.65, 14, Math.min(120, sizeBased*1.25));
        }

        const headWorld = clamp(lenWorld * 0.25, 6 / state.zoom, 18 / state.zoom);
        const usableLen = Math.max(10 / state.zoom, lenWorld - headWorld * 0.7);

        const x2 = p0.x + dir.x * usableLen;
        const y2 = p0.y + dir.y * usableLen;

        ctx.save();
        drawArrow(ctx, p0.x, p0.y, x2, y2, {
          lineWidth: 2.5 / state.zoom,
          headSize: headWorld,
          headAngleDeg: 28,
          strokeStyle: "rgba(15,23,42,0.92)",
          strokeStyleTop: "rgba(226,232,240,0.92)"
        });
        ctx.restore();
      }
    }

    // Roads
    for (const r of state.roads){
      if(!r.points || r.points.length < 2) continue;
      ctx.beginPath();
      ctx.moveTo(r.points[0].x, r.points[0].y);
      for(let i=1;i<r.points.length;i++) ctx.lineTo(r.points[i].x, r.points[i].y);
      ctx.lineWidth = Math.max(2, r.width || 10);
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = roadStroke(r.roadType);
      ctx.stroke();

      // centerline
      ctx.lineWidth = 1 / state.zoom;
      ctx.setLineDash([6/state.zoom, 8/state.zoom]);
      ctx.strokeStyle = "rgba(15,23,42,0.35)";
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Buildings
    for (const b of state.buildings){
      ctx.fillStyle = "rgba(148,163,184,0.25)";
      ctx.strokeStyle = "rgba(148,163,184,0.7)";
      ctx.lineWidth = 2 / state.zoom;
      ctx.fillRect(b.x, b.y, b.w, b.h);
      ctx.strokeRect(b.x, b.y, b.w, b.h);
    }

    // Movement paths
    drawMovePaths(ctx, _selectedKeys);

    // Soldiers
    for (const s of state.soldiers){
      const baseRangeFt = getSoldierRangeFt(s);
      const isSelected = _selectedKeys.has("soldier:" + s.id);
      const showRange = (state.rangeDisplay === "all") || (state.rangeDisplay === "selected" && isSelected);
      const showCone  = (state.coneDisplay  === "all") || (state.coneDisplay  === "selected" && isSelected);

      const coneStroke = (s.side === "enemy") ? "rgba(239,68,68,0.40)" : "rgba(59,130,246,0.40)";
      const coneFill   = (s.side === "enemy") ? "rgba(239,68,68,0.14)" : "rgba(59,130,246,0.14)";
      const ringStroke = (s.side === "enemy") ? "rgba(248,113,113,0.28)" : "rgba(147,197,253,0.28)";

      // Cone (draw first, behind the soldier)
      if(showCone){
        // 360° fire arc (direction-independent)
        const coneDeg = 360;
        const a0 = 0;
        const a1 = Math.PI * 2;

        const maxRange = baseRangeFt;

        // Higher resolution only when the UI is set to "Selected" AND this soldier is selected.
        // (Keeps the "All" mode performant.)
        const hiRes = (state.coneDisplay === "selected" && isSelected);
        const steps = clamp(hiRes ? 180 : 120, 72, 240);

        // Terrain + elevation effect:
        // - Range uses an "open-distance budget" (Option 2): budget spent = segmentLength / f(terrain).
        // - Woods / Rough shrink effective range via f < 1 along the ray.
        // - Hills: if the shooter is inside a Hills area, the budget is multiplied by its Range bonus.
        // - LOS uses a horizon scan over hill elevation + building roofs.
        const hillsBonus = getHillsOriginRangeBonus(s.x, s.y, state.terrains);
        const maxBudget = maxRange * hillsBonus;

        const dirs = [];
        const outerD = [];
        const outerPts = [];

        for(let i=0;i<=steps;i++){
          const t = i / steps;
          const ang = a0 + (a1 - a0) * t;
          const dir = {x: Math.cos(ang), y: Math.sin(ang)};
          dirs.push(dir);

          // 1) Terrain-budget limited distance (Option 2)
          const dBudget = computeBudgetRangeDist(s.x, s.y, dir.x, dir.y, maxBudget, state.terrains);

          // 2) 2.5D LOS (terrain + building roofs), using the shooter's eye height
          const d = rayFarthestVisibleGround(s.x, s.y, dir.x, dir.y, dBudget, state.terrains, state.buildings, (typeof s.zOffsetFt === "number" ? s.zOffsetFt : 0));

          outerD.push(d);
          outerPts.push({x: s.x + dir.x * d, y: s.y + dir.y * d});
        }

// Fire area (360°), clipped by LOS + terrain budget
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(outerPts[0].x, outerPts[0].y);
        for(let i=1;i<outerPts.length;i++) ctx.lineTo(outerPts[i].x, outerPts[i].y);
        ctx.closePath();
        ctx.fillStyle = coneFill;
        ctx.fill();
        ctx.lineWidth = 1.5 / state.zoom;
        ctx.strokeStyle = coneStroke;
        ctx.stroke();


        ctx.restore();
      }

      // Range ring
      if(showRange){
        ctx.save();
        ctx.beginPath();
        const hillsBonus = getHillsOriginRangeBonus(s.x, s.y, state.terrains);
        ctx.arc(s.x, s.y, baseRangeFt * hillsBonus, 0, Math.PI*2);
        ctx.lineWidth = 1.5 / state.zoom;
        ctx.strokeStyle = ringStroke;
        ctx.stroke();
        ctx.restore();
      }

      // Soldier dot (fixed 3px diameter)
      const rDraw = 1.5 / state.zoom;
      ctx.beginPath();
      ctx.arc(s.x, s.y, rDraw, 0, Math.PI*2);
      ctx.fillStyle = (s.side === "enemy") ? "rgba(239,68,68,0.95)" : "rgba(59,130,246,0.95)";
      ctx.fill();
      // subtle dark outline so the tiny dot stays visible on any background
      ctx.lineWidth = 1 / state.zoom;
      ctx.strokeStyle = "rgba(15,23,42,0.85)";
      ctx.stroke();

      // Always-on team ring (constant on-screen size)
      const rTeam = 3.75 / state.zoom;
      ctx.beginPath();
      ctx.arc(s.x, s.y, rTeam, 0, Math.PI*2);
      ctx.lineWidth = 1.25 / state.zoom;
      ctx.strokeStyle = (s.side === "enemy") ? "rgba(239,68,68,0.85)" : "rgba(59,130,246,0.85)";
      ctx.stroke();

    }

    // Previews
    if(state.drawing){
      const d = state.drawing;
      ctx.save();
      ctx.lineWidth = 2 / state.zoom;
      ctx.strokeStyle = "rgba(226,232,240,0.9)";
      ctx.fillStyle = "rgba(226,232,240,0.12)";

      if(d.kind === "building" && d.start && d.end){
        const x = Math.min(d.start.x, d.end.x);
        const y = Math.min(d.start.y, d.end.y);
        const w = Math.abs(d.end.x - d.start.x);
        const h = Math.abs(d.end.y - d.start.y);
        ctx.fillRect(x,y,w,h);
        ctx.strokeRect(x,y,w,h);
      }

      if((d.kind === "road" || d.kind === "terrain") && d.points && d.points.length){
        ctx.beginPath();
        ctx.moveTo(d.points[0].x, d.points[0].y);
        for(let i=1;i<d.points.length;i++) ctx.lineTo(d.points[i].x, d.points[i].y);
        if(d.previewTo){
          ctx.lineTo(d.previewTo.x, d.previewTo.y);
        }
        if(d.kind === "terrain" && d.points.length >= 2){
          ctx.closePath();
          ctx.fill();
        }
        ctx.stroke();
      }

      ctx.restore();
    }

    // Selection highlight (world space)
    function drawHighlight(ref, stroke, fill){
      const obj = getByRef(ref);
      if(!obj) return;
      ctx.save();
      ctx.strokeStyle = stroke;
      ctx.fillStyle = fill;
      ctx.lineWidth = 2 / state.zoom;

      if(ref.kind==="soldier"){
        // Smaller on-screen selection ring (soldier dots are 3px diameter)
        const r = 4.0 / state.zoom;
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, r, 0, Math.PI*2);
        ctx.stroke();
      }
      if(ref.kind==="building"){
        ctx.strokeRect(obj.x-2/state.zoom, obj.y-2/state.zoom, obj.w+4/state.zoom, obj.h+4/state.zoom);
      }
      if(ref.kind==="road"){
        if(obj.points && obj.points.length>=2){
          // Subtle selection: thin dashed centerline (not a fat yellow bar)
          ctx.beginPath(); ctx.moveTo(obj.points[0].x, obj.points[0].y);
          for(let i=1;i<obj.points.length;i++) ctx.lineTo(obj.points[i].x, obj.points[i].y);

          ctx.strokeStyle = "rgba(253,224,71,0.55)";
          ctx.lineWidth = Math.max(2/state.zoom, 0.25*(obj.width||10));
          ctx.setLineDash([10/state.zoom, 8/state.zoom]);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
      if(ref.kind==="terrain"){
        if(obj.points && obj.points.length>=3){
          ctx.beginPath();
          ctx.moveTo(obj.points[0].x, obj.points[0].y);
          for(let i=1;i<obj.points.length;i++) ctx.lineTo(obj.points[i].x, obj.points[i].y);
          ctx.closePath();
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    const selectedRefs = (state.selectedMulti && state.selectedMulti.length) ? state.selectedMulti : (state.selected ? [state.selected] : []);
    for(const r of selectedRefs){
      drawHighlight(r, "rgba(253,224,71,0.95)", "rgba(253,224,71,0.08)");
    }

    // Marquee preview highlight (while box-selecting)
    if(state.boxSelect && state.boxSelect.active && state.boxSelect.previewRefs){
      for(const r of state.boxSelect.previewRefs){
        drawHighlight(r, "rgba(226,232,240,0.65)", "rgba(226,232,240,0.05)");
      }
    }

    // HUD text in screen space
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.fillStyle = "rgba(226,232,240,0.75)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, sans-serif";
    // (removed) top-left label moved to DOM controls
// Marquee rectangle (screen space)
    if(state.boxSelect && state.boxSelect.active){
      const r = normRect(state.boxSelect);
      ctx.save();
      ctx.strokeStyle = "rgba(253,224,71,0.95)";
      ctx.fillStyle = "rgba(253,224,71,0.08)";
      ctx.lineWidth = 1;
      ctx.setLineDash([6,4]);
      ctx.fillRect(r.x0, r.y0, r.w, r.h);
      ctx.strokeRect(r.x0 + 0.5, r.y0 + 0.5, r.w, r.h);
      ctx.setLineDash([]);
      ctx.restore();
    }

    // readouts
    zoomReadout.textContent = Math.round(state.zoom*100) + "%";
    panReadout.textContent = Math.round(state.panX) + ", " + Math.round(state.panY);
  }

  // ---------- inspector ----------
  function setSelection(ref){
    state.selected = ref;
    state.selectedMulti = [];
    renderInspector();
    updateCursor();
    draw();
  }

  function setMultiSelection(refs){
    state.selectedMulti = Array.isArray(refs) ? refs : [];
    state.selected = state.selectedMulti.length ? state.selectedMulti[0] : null;
    renderInspector();
    updateCursor();
    draw();
  }

  function clearSelection(){
    state.selected = null;
    state.selectedMulti = [];
    renderInspector();
    updateCursor();
    draw();
  }

  function renderInspector(){
    toolReadout.textContent = state.tool;

    inspectorTable.style.display = "none";
    inspectorTable.innerHTML = "";


    const selectionRefs = (state.selectedMulti && state.selectedMulti.length) ? state.selectedMulti : (state.selected ? [state.selected] : []);
    setTimeout(setupLayerButtons, 0);

    const isMulti = selectionRefs.length > 1;

    if(isMulti){
      // Multi-selection summary + (optional) bulk edit
      deleteSelectedBtn.disabled = false;
      duplicateSelectedBtn.disabled = false;
      deselectAllBtn.disabled = false;

      const counts = {soldier:0, building:0, road:0, terrain:0};
      for(const r of selectionRefs) counts[r.kind] = (counts[r.kind]||0) + 1;

      // Soldier table (always keep this when soldiers are part of the selection)
      const soldiersSelected = selectionRefs
        .filter(r => r.kind === "soldier")
        .map(r => getByRef(r))
        .filter(Boolean);

      const soldierRows = soldiersSelected.map(s => {
        const rangeFt = getSoldierRangeFt(s);
        const name = (s.label && String(s.label).trim()) ? String(s.label).trim() : (isHumanIdForKind("soldier", s.id) ? String(s.id) : ((String(s.id).length > 10) ? (String(s.id).slice(0,10) + "…") : String(s.id)));
        const side = (s.side === "enemy") ? "E" : "F";
        return `<div class="msRow">
          <div class="msName" title="${name.replaceAll('"','&quot;')}">${name.replaceAll('<','&lt;').replaceAll('>','&gt;')}</div>
          <div class="msRange">${Math.round(rangeFt)}ft</div>
          <div class="msSide">${side}</div>
        </div>`;
      }).join("");

      selectionPill.textContent = `MULTI · ${selectionRefs.length}`;

      inspectorTable.style.display = "block";
      inspectorTable.innerHTML = `
        <div class="muted">
          <div><strong>${selectionRefs.length}</strong> objects selected.</div>
          <div class="hr"></div>
          <ul style="margin:6px 0 0 18px; padding:0; font-size:11px; color:#9ca3af;">
            ${counts.soldier ? `<li>Soldiers: ${counts.soldier}</li>` : ``}
            ${counts.building ? `<li>Buildings: ${counts.building}</li>` : ``}
            ${counts.road ? `<li>Roads: ${counts.road}</li>` : ``}
            ${counts.terrain ? `<li>Terrain areas: ${counts.terrain}</li>` : ``}
          </ul>

          <div class="hr"></div>
          <div style="font-size:11px; color:#cbd5e1; margin-bottom:4px;">Layers</div>
          <div style="display:flex; gap:6px; flex-wrap:wrap;">
            <button id="layerToBackBtn" title="Send selected (within their type) to back">Back</button>
            <button id="layerBackwardBtn" title="Move selected (within their type) one step back">◀</button>
            <button id="layerForwardBtn" title="Move selected (within their type) one step forward">▶</button>
            <button id="layerToFrontBtn" title="Bring selected (within their type) to front">Front</button>
          </div>

          ${counts.soldier ? `
            <div class="hr"></div>
            <div style="font-size:11px; color:#cbd5e1; margin-bottom:4px;">Soldiers</div>
            <div style="display:grid; grid-template-columns: 1.1fr 1.6fr 0.7fr 0.4fr; gap:6px; font-size:10px; color:#9ca3af; margin-bottom:4px;">
              <div>Name</div><div>Range</div><div>Side</div>
            </div>
            <div style="max-height:220px; overflow:auto; border:1px solid #1f2937; border-radius:6px; padding:6px; background:#0b1220;">
              <style>
                .msRow{ display:grid; grid-template-columns: 1.4fr 0.8fr 0.5fr; gap:6px; align-items:center; padding:2px 0; font-size:10px; color:#e5e7eb; }
                .msRow + .msRow{ border-top:1px solid rgba(31,41,55,0.7); }
                .msName,.msRange,.msSide{ text-align:right; font-variant-numeric: tabular-nums; }
                .msSide{ text-align:center; }
              </style>
              ${soldierRows || `<div class="muted">No soldiers in selection.</div>`}
            </div>
          ` : ``}
        </div>
      `;

      // Bulk edit is only available when ALL selected objects are the same kind.
      const kinds = [...new Set(selectionRefs.map(r => r.kind))];
      const singleKind = (kinds.length === 1);
      const kind = singleKind ? kinds[0] : null;

      // helper: detect shared values
      function shared(getter, isNum=false){
        if(!singleKind) return {same:false, value:null};
        const objs = selectionRefs.map(r => getByRef(r)).filter(Boolean);
        if(objs.length === 0) return {same:false, value:null};
        const v0 = getter(objs[0]);
        for(let i=1;i<objs.length;i++){
          const v = getter(objs[i]);
          if(isNum){
            if(Math.abs((v??0) - (v0??0)) > 1e-6) return {same:false, value:null};
          } else {
            if(v !== v0) return {same:false, value:null};
          }
        }
        return {same:true, value:v0};
      }

      // Signed heading helper for UI (-180..180)
      function toSigned(deg360){
        const d = ((deg360 % 360) + 360) % 360;
        return (d > 180) ? (d - 360) : d;
      }

      if(!singleKind){
        inspectorBody.innerHTML = `
          <div class="muted">
            Bulk edit works when your selection is all the <strong>same type</strong> (all soldiers, all roads, etc).
            <div class="hr"></div>
            Tip: <strong>⌘+Click</strong> toggles items. Drag empty space to pan. <strong>Shift</strong> + drag highlights (marquee-select).
          </div>
        `;
        return;
      }

      // ---------- bulk edit UI (compact) ----------
      if(kind === "soldier"){
        const sideV = shared(o => o.side || "friendly", false);
        const rangeV = shared(o => getSoldierRangeFt(o), true);
        const radiusV = shared(o => (typeof o.r==="number"? o.r : 1), true);

        const sideVal = sideV.same ? sideV.value : "";
        const rangeVal = rangeV.same ? Math.round(rangeV.value) : "";
        const radiusVal = radiusV.same ? radiusV.value : "";

        inspectorBody.innerHTML = `
          <div style="font-size:11px; color:#cbd5e1; margin-bottom:6px;">Bulk edit · Soldiers (${selectionRefs.length})</div>

          <div class="row">
            <label>Side</label>
            <select id="bulkSoldierSide">
              <option value="" ${sideVal===""?"selected":""} disabled>— mixed —</option>
              <option value="friendly" ${sideVal==="friendly"?"selected":""}>Friendly</option>
              <option value="enemy" ${sideVal==="enemy"?"selected":""}>Enemy</option>
            </select>
          </div>

          <div class="row">
            <label>Range (ft)</label>
            <input id="bulkSoldierRange" type="number" min="1" step="1" value="${rangeVal}">
          </div>


          <div class="row">
            <label>Radius (ft)</label>
            <input id="bulkSoldierRadius" type="number" min="0.1" step="0.1"
              placeholder="${radiusVal===""?"mixed":""}" value="${radiusVal}">
          </div>

          <div class="muted" style="margin-top:6px;">
            Leaving a field as <strong>mixed</strong> will not change that property.
          </div>
        `;

        const sideEl = document.getElementById("bulkSoldierSide");
        const rangeEl = document.getElementById("bulkSoldierRange");
        const radEl = document.getElementById("bulkSoldierRadius");

        sideEl.addEventListener("change", ()=>{
          const v = sideEl.value;
          if(!v) return;
          for(const r of selectionRefs){ const o = getByRef(r); if(o) o.side = v; }
          renderInspector(); draw();
        });

        if(rangeEl){
          rangeEl.addEventListener("change", ()=>{
            const raw = rangeEl.value;
            if(raw === "") return;
            const v = parseFloat(raw);
            if(!isFinite(v)) return;
            for(const r of selectionRefs){ const o = getByRef(r); if(o) o.rangeFt = clamp(v, 1, 200000); }
            renderInspector(); draw();
          });
        }


        radEl.addEventListener("change", ()=>{
          const raw = radEl.value;
          if(raw === "") return;
          const v = parseFloat(raw);
          if(!isFinite(v)) return;
          for(const r of selectionRefs){ const o = getByRef(r); if(o) o.r = v; }
          renderInspector(); draw();
        });

        return;
      }

if(kind === "road"){
        const typeV = shared(o => o.type || "road", false);
        const widthV = shared(o => (typeof o.width==="number"? o.width : 10), true);
        const typeVal = typeV.same ? typeV.value : "";
        const widthVal = widthV.same ? widthV.value : "";

        inspectorBody.innerHTML = `
          <div style="font-size:11px; color:#cbd5e1; margin-bottom:6px;">Bulk edit · Roads (${selectionRefs.length})</div>

          <div class="row">
            <label>Type</label>
            <select id="bulkRoadType">
              <option value="" ${typeVal===""?"selected":""} disabled>— mixed —</option>
              <option value="road" ${typeVal==="road"?"selected":""}>Road</option>
              <option value="trail" ${typeVal==="trail"?"selected":""}>Trail</option>
              <option value="river" ${typeVal==="river"?"selected":""}>River</option>
            </select>
          </div>

          <div class="row">
            <label>Width (ft)</label>
            <input id="bulkRoadWidth" type="number" min="1" step="1"
              placeholder="${widthVal===""?"mixed":""}" value="${widthVal}">
          </div>

          <div class="muted" style="margin-top:6px;">Leaving a field as <strong>mixed</strong> will not change that property.</div>
        `;

        const typeEl = document.getElementById("bulkRoadType");
        const widthEl = document.getElementById("bulkRoadWidth");

        typeEl.addEventListener("change", ()=>{
          const v = typeEl.value;
          if(!v) return;
          for(const r of selectionRefs){ const o = getByRef(r); if(o) o.type = v; }
          renderInspector(); draw();
        });

        widthEl.addEventListener("change", ()=>{
          const raw = widthEl.value;
          if(raw === "") return;
          const v = parseFloat(raw);
          if(!isFinite(v)) return;
          for(const r of selectionRefs){ const o = getByRef(r); if(o) o.width = v; }
          renderInspector(); draw();
        });

        return;
      }

      if(kind === "terrain"){
        const typeV = shared(o => o.type || "open", false);
        const typeVal = typeV.same ? typeV.value : "";

        inspectorBody.innerHTML = `
          <div style="font-size:11px; color:#cbd5e1; margin-bottom:6px;">Bulk edit · Terrain (${selectionRefs.length})</div>

          <div class="row">
            <label>Type</label>
            <select id="bulkTerrainType">
              <option value="" ${typeVal===""?"selected":""} disabled>— mixed —</option>
              <option value="open" ${typeVal==="open"?"selected":""}>Open</option>
              <option value="forest" ${typeVal==="forest"?"selected":""}>Forest</option>
              <option value="urban" ${typeVal==="urban"?"selected":""}>Urban</option>
              <option value="water" ${typeVal==="water"?"selected":""}>Water</option>
            </select>
          </div>

          <div class="muted" style="margin-top:6px;">Leaving a field as <strong>mixed</strong> will not change that property.</div>
        `;

        const typeEl = document.getElementById("bulkTerrainType");
        typeEl.addEventListener("change", ()=>{
          const v = typeEl.value;
          if(!v) return;
          for(const r of selectionRefs){ const o = getByRef(r); if(o) o.type = v; }
          renderInspector(); draw();
        });

        return;
      }

      if(kind === "building"){
        const typeV = shared(o => o.type || "building", false);
        const wV = shared(o => (typeof o.w==="number"? o.w : 40), true);
        const hV = shared(o => (typeof o.h==="number"? o.h : 30), true);

        const typeVal = typeV.same ? typeV.value : "";
        const wVal = wV.same ? wV.value : "";
        const hVal = hV.same ? hV.value : "";

        inspectorBody.innerHTML = `
          <div style="font-size:11px; color:#cbd5e1; margin-bottom:6px;">Bulk edit · Buildings (${selectionRefs.length})</div>

          <div class="row">
            <label>Type</label>
            <select id="bulkBuildingType">
              <option value="" ${typeVal===""?"selected":""} disabled>— mixed —</option>
              <option value="building" ${typeVal==="building"?"selected":""}>Building</option>
              <option value="wall" ${typeVal==="wall"?"selected":""}>Wall</option>
              <option value="cover" ${typeVal==="cover"?"selected":""}>Cover</option>
            </select>
          </div>

          <div class="row">
            <label>Width (ft)</label>
            <input id="bulkBuildingW" type="number" min="1" step="1"
              placeholder="${wVal===""?"mixed":""}" value="${wVal}">
          </div>

          <div class="row">
            <label>Height (ft)</label>
            <input id="bulkBuildingH" type="number" min="1" step="1"
              placeholder="${hVal===""?"mixed":""}" value="${hVal}">
          </div>

          <div class="muted" style="margin-top:6px;">Leaving a field as <strong>mixed</strong> will not change that property.</div>
        `;

        const typeEl = document.getElementById("bulkBuildingType");
        const wEl = document.getElementById("bulkBuildingW");
        const hEl = document.getElementById("bulkBuildingH");

        typeEl.addEventListener("change", ()=>{
          const v = typeEl.value;
          if(!v) return;
          for(const r of selectionRefs){ const o = getByRef(r); if(o) o.type = v; }
          renderInspector(); draw();
        });
        wEl.addEventListener("change", ()=>{
          const raw = wEl.value;
          if(raw === "") return;
          const v = parseFloat(raw);
          if(!isFinite(v)) return;
          for(const r of selectionRefs){ const o = getByRef(r); if(o) o.w = v; }
          renderInspector(); draw();
        });
        hEl.addEventListener("change", ()=>{
          const raw = hEl.value;
          if(raw === "") return;
          const v = parseFloat(raw);
          if(!isFinite(v)) return;
          for(const r of selectionRefs){ const o = getByRef(r); if(o) o.h = v; }
          renderInspector(); draw();
        });

        return;
      }

      // fallback
      inspectorBody.innerHTML = `<div class="muted">Bulk edit not available for this selection.</div>`;
      return;
    }

    const ref = selectionRefs.length === 1 ? selectionRefs[0] : null;
    const obj = ref ? getByRef(ref) : null;

    deleteSelectedBtn.disabled = !obj;
    duplicateSelectedBtn.disabled = !obj;
    deselectAllBtn.disabled = !obj;

    if(!obj){
      selectionPill.textContent = "No selection";
      inspectorBody.innerHTML = `
        <div class="muted">
          Choose <strong>Select / Inspect</strong>, then click an object (or drag empty space to marquee-select).
          <div class="hr"></div>
          <div>Editable here:</div>
          <ul style="margin:6px 0 0 18px; padding:0; font-size:11px; color:#9ca3af;">
            <li>Road: width + type</li>
            <li>Terrain: type + opacity</li>
            <li>Building: size</li>
            <li>Soldier: side + radius</li>
          </ul>
        </div>
      `;
      return;
    }

    selectionPill.textContent = `${ref.kind.toUpperCase()} · ${obj.id}`;

    const common = `
      <div class="kv"><div>ID</div><div title="${obj.id}">${obj.id}</div></div>
      <div class="row">
        <label>Layer</label>
        <div style="display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end;">
          <button id="layerToBackBtn" title="Send to back (within its type)">Back</button>
          <button id="layerBackwardBtn" title="Move back one step (within its type)">◀</button>
          <button id="layerForwardBtn" title="Move forward one step (within its type)">▶</button>
          <button id="layerToFrontBtn" title="Bring to front (within its type)">Front</button>
        </div>
      </div>
    `;

    if(ref.kind === "soldier"){
      // Ensure defaults exist on older saves
      if(typeof obj.rangeFt !== "number" || !isFinite(obj.rangeFt) || obj.rangeFt <= 0){
        const wk = obj.weapon;
        if(wk && LEGACY_WEAPON_RANGE_FT[wk]) obj.rangeFt = LEGACY_WEAPON_RANGE_FT[wk];
        else obj.rangeFt = DEFAULT_SOLDIER_RANGE_FT;
      }
      obj.rangeFt = clamp(obj.rangeFt, 1, 200000);
      // Strip deprecated fields if present
      if("weapon" in obj) delete obj.weapon;
      if("heading" in obj) delete obj.heading;

      if(typeof obj.zOffsetFt !== "number" || !isFinite(obj.zOffsetFt)) obj.zOffsetFt = 0;
      obj.zOffsetFt = clamp(obj.zOffsetFt, -500, 5000);

      inspectorBody.innerHTML = `
        <div class="section" style="border:none; padding:0; margin:0;">
          ${common}

          <div class="row">
            <label>Side</label>
            <select id="inspSoldierSide">
              <option value="friendly">Friendly</option>
              <option value="enemy">Enemy</option>
            </select>
          </div>

          <div class="row">
            <label>ID</label>
            <input id="inspSoldierId" type="text" value="${String(obj.id).replaceAll('"','&quot;')}">
          </div>

          <div class="row">
            <label>Range (ft)</label>
            <input id="inspSoldierRange" type="number" min="1" step="1" value="${Math.round(getSoldierRangeFt(obj))}">
          </div>

          <div class="row">
            <label>Radius (ft)</label>
            <input id="inspSoldierR" type="number" min="1" step="1" value="${obj.r||1}">
          </div>

          
          <div class="row">
            <label>Elevation offset (ft)</label>
            <input id="inspSoldierZ" type="number" step="1" value="${Math.round(obj.zOffsetFt||0)}">
          </div>
<div class="row">
            <label>Label</label>
            <input id="inspSoldierLabel" type="text" placeholder="(optional)" value="${(obj.label||"").replaceAll('"','&quot;')}">
          </div>

          <div class="muted">Effective range: <strong>${Math.round(getSoldierRangeFt(obj)).toLocaleString()} ft</strong> · Fire arc: <strong>360°</strong></div>
          <div class="muted">Pos: ${obj.x.toFixed(1)}, ${obj.y.toFixed(1)}</div>
        </div>
      `;

      const sideEl = document.getElementById("inspSoldierSide");
      const idEl = document.getElementById("inspSoldierId");
      const rangeEl = document.getElementById("inspSoldierRange");
      const rEl = document.getElementById("inspSoldierR");
      const zEl = document.getElementById("inspSoldierZ");
      const labelEl = document.getElementById("inspSoldierLabel");


      sideEl.value = obj.side || "friendly";
      if(idEl) idEl.value = String(obj.id || "");
      if(rangeEl) rangeEl.value = String(Math.round(getSoldierRangeFt(obj)));

      sideEl.addEventListener("change", (e)=>{
        obj.side = e.target.value;
        draw();
      });

      if(rangeEl){
        rangeEl.addEventListener("input", (e)=>{
          obj.rangeFt = clamp(parseFloat(e.target.value)||DEFAULT_SOLDIER_RANGE_FT, 1, 200000);
          draw();
        });
      }

      if(idEl){
        idEl.addEventListener("change", ()=>{
          const oldId = String(obj.id || "").trim();
          let desired = String(idEl.value || "").trim();
          if(!desired){ idEl.value = oldId; return; }
          const newId = makeUniqueId("soldier", desired, oldId);
          if(newId !== oldId){
            renameObjectId("soldier", oldId, newId);
            obj.id = newId;
            renderInspector();
            draw();
          }else{
            idEl.value = oldId;
          }
        });
      }

      rEl.addEventListener("input", (e)=>{
        obj.r = clamp(parseFloat(e.target.value)||1, 1, 50);
        draw();
      });

      zEl.addEventListener("input", (e)=>{
        obj.zOffsetFt = clamp(parseFloat(e.target.value)||0, -500, 5000);
        draw();
      });


      labelEl.addEventListener("input", (e)=>{
        obj.label = e.target.value;
        draw();
      });

      return;
    }

    if(ref.kind === "building"){
      // Defaults for newer building fields
      if(typeof obj.floors !== "number" || !isFinite(obj.floors)) obj.floors = 1;
      obj.floors = clamp(Math.round(obj.floors), 1, 200);
      if(typeof obj.floorHeightFt !== "number" || !isFinite(obj.floorHeightFt)) obj.floorHeightFt = 10;
      obj.floorHeightFt = clamp(obj.floorHeightFt, 6, 30);
      if(typeof obj.roofExtraFt !== "number" || !isFinite(obj.roofExtraFt)) obj.roofExtraFt = 0;
      obj.roofExtraFt = clamp(obj.roofExtraFt, 0, 200);

      inspectorBody.innerHTML = `
        <div class="section" style="border:none; padding:0; margin:0;">
          ${common}
          <div class="row">
            <label>Name</label>
            <input id="inspBName" type="text" placeholder="Building" value="${(obj.name||"Building").replaceAll('"','&quot;')}">
          </div>
          <div class="row">
            <label>Width (ft)</label>
            <input id="inspBW" type="number" min="1" step="1" value="${Math.round(obj.w)}">
          </div>
          <div class="row">
            <label>Height (ft)</label>
            <input id="inspBH" type="number" min="1" step="1" value="${Math.round(obj.h)}">
          </div>
          
          <div class="row">
            <label>Floors</label>
            <input id="inspBFloors" type="number" min="1" max="200" step="1" value="${obj.floors}">
          </div>
          <div class="row">
            <label>Floor height (ft)</label>
            <input id="inspBFloorHeight" type="number" min="6" max="30" step="1" value="${Math.round(obj.floorHeightFt)}">
          </div>
          <div class="row">
            <label>Roof extra (ft)</label>
            <input id="inspBRoofExtra" type="number" min="0" max="200" step="1" value="${Math.round(obj.roofExtraFt)}">
          </div>
          <div class="muted">Total height: <strong id="inspBTotalHeight">${Math.round(obj.floors * obj.floorHeightFt + obj.roofExtraFt)} ft</strong></div>

          <div class="muted">Pos (top-left): ${obj.x.toFixed(1)}, ${obj.y.toFixed(1)}</div>
        </div>
      `;
      document.getElementById("inspBName").addEventListener("input",(e)=>{ obj.name = e.target.value; draw(); });
      document.getElementById("inspBW").addEventListener("input",(e)=>{ obj.w = clamp(parseFloat(e.target.value)||obj.w, 1, 10000); draw(); });
      document.getElementById("inspBH").addEventListener("input",(e)=>{ obj.h = clamp(parseFloat(e.target.value)||obj.h, 1, 10000); draw(); });
      
      const updateBuildingTotalHeight = ()=>{
        const el = document.getElementById("inspBTotalHeight");
        if(!el) return;
        const total = Math.round(obj.floors * obj.floorHeightFt + obj.roofExtraFt);
        el.textContent = `${total.toLocaleString()} ft`;
      };

      document.getElementById("inspBFloors").addEventListener("input",(e)=>{
        obj.floors = clamp(Math.round(parseFloat(e.target.value)||obj.floors), 1, 200);
        updateBuildingTotalHeight();
        draw();
      });
      document.getElementById("inspBFloorHeight").addEventListener("input",(e)=>{
        obj.floorHeightFt = clamp(parseFloat(e.target.value)||obj.floorHeightFt, 6, 30);
        updateBuildingTotalHeight();
        draw();
      });
      document.getElementById("inspBRoofExtra").addEventListener("input",(e)=>{
        obj.roofExtraFt = clamp(parseFloat(e.target.value)||obj.roofExtraFt, 0, 200);
        updateBuildingTotalHeight();
        draw();
      });
      return;
    }

    if(ref.kind === "road"){
      const pts = obj.points || [];
      inspectorBody.innerHTML = `
        <div class="section" style="border:none; padding:0; margin:0;">
          ${common}
          <div class="row">
            <label>Name</label>
            <input id="inspRName" type="text" placeholder="Road" value="${(obj.name||"Road").replaceAll('"','&quot;')}">
          </div>
          <div class="row">
            <label>Type</label>
            <select id="inspRType">
              ${ROAD_TYPES.map(r=>`<option value="${r.key}">${r.label}</option>`).join("")}
            </select>
          </div>
          <div class="row">
            <label>Width (ft)</label>
            <input id="inspRWidth" type="number" min="1" step="1" value="${Math.round(obj.width||10)}">
          </div>
          <div class="muted">Points: ${pts.length} (drag to move whole road)</div>
          <textarea readonly>${pts.map(p=>`${p.x.toFixed(1)}, ${p.y.toFixed(1)}`).join("\n")}</textarea>
        </div>
      `;
      document.getElementById("inspRType").value = obj.roadType || "paved";
      document.getElementById("inspRName").addEventListener("input",(e)=>{ obj.name = e.target.value; draw(); });
      document.getElementById("inspRType").addEventListener("change",(e)=>{ obj.roadType = e.target.value; draw(); });
      document.getElementById("inspRWidth").addEventListener("input",(e)=>{ obj.width = clamp(parseFloat(e.target.value)||10, 1, 1000); draw(); });
      return;
    }

    if(ref.kind === "terrain"){
      const pts = obj.points || [];

      // Hills: initialize defaults on older saves / type switches.
      const isHills = (obj.terrainType === "hills");
      if(isHills){
        if(typeof obj.hillsRangeBonus !== "number" || !isFinite(obj.hillsRangeBonus)) obj.hillsRangeBonus = 1.25;
        if(typeof obj.hillsHeightFt   !== "number" || !isFinite(obj.hillsHeightFt))   obj.hillsHeightFt   = 30;
        if(typeof obj.hillsDirDeg     !== "number" || !isFinite(obj.hillsDirDeg))     obj.hillsDirDeg     = 0;
        if(typeof obj.hillsShape      !== "string")                                   obj.hillsShape      = "ramp";
        if(typeof obj.hillsTravelFactor !== "number" || !isFinite(obj.hillsTravelFactor)) obj.hillsTravelFactor = 1.0;
      }

      const hillsExtra = isHills ? `
          <div class="row">
            <label>Range bonus</label>
            <input id="inspHillRangeBonus" type="number" min="1" max="3" step="0.05" value="${(obj.hillsRangeBonus ?? 1.25).toFixed(2)}">
          </div>
          <div class="row">
            <label>Height (ft)</label>
            <input id="inspHillHeight" type="number" min="0" max="500" step="1" value="${Math.round(obj.hillsHeightFt ?? 30)}">
          </div>
          <div class="row">
            <label>Slope dir (deg)</label>
            <input id="inspHillDir" type="number" min="0" max="359" step="1" value="${Math.round(obj.hillsDirDeg ?? 0)}">
          </div>
          <div class="row">
            <label>Shape</label>
            <select id="inspHillShape">
              <option value="ramp">Ramp (one-sided)</option>
              <option value="ridge">Ridge (two-sided)</option>
              <option value="bowl">Bowl (low center)</option>
            </select>
          </div>
          <div class="row">
            <label>Travel factor</label>
            <input id="inspHillTravel" type="number" min="0.5" max="2" step="0.05" value="${(obj.hillsTravelFactor ?? 1.0).toFixed(2)}">
          </div>
      ` : "";

      inspectorBody.innerHTML = `
        <div class="section" style="border:none; padding:0; margin:0;">
          ${common}
          <div class="row">
            <label>Name</label>
            <input id="inspTName" type="text" placeholder="Terrain" value="${(obj.name||"Terrain").replaceAll('"','&quot;')}">
          </div>
          <div class="row">
            <label>Type</label>
            <select id="inspTType">
              ${TERRAIN_TYPES.map(t=>`<option value="${t.key}">${t.label}</option>`).join("")}
            </select>
          </div>
          <div class="row">
            <label>Opacity</label>
            <input id="inspTOp" type="number" min="0.05" max="0.95" step="0.05" value="${(obj.opacity ?? 0.35).toFixed(2)}">
          </div>

          ${hillsExtra}

          <div class="muted">Vertices: ${pts.length} (drag to move whole area)</div>
          <textarea readonly>${pts.map(p=>`${p.x.toFixed(1)}, ${p.y.toFixed(1)}`).join("\n")}</textarea>
        </div>
      `;
      document.getElementById("inspTType").value = obj.terrainType || "open";
      document.getElementById("inspTName").addEventListener("input",(e)=>{ obj.name = e.target.value; draw(); });
      document.getElementById("inspTType").addEventListener("change",(e)=>{
        const oldId = obj.id;
        obj.terrainType = e.target.value;
        if(obj.terrainType === "hills"){
          if(typeof obj.hillsRangeBonus !== "number" || !isFinite(obj.hillsRangeBonus)) obj.hillsRangeBonus = 1.25;
          if(typeof obj.hillsHeightFt   !== "number" || !isFinite(obj.hillsHeightFt))   obj.hillsHeightFt   = 30;
          if(typeof obj.hillsDirDeg     !== "number" || !isFinite(obj.hillsDirDeg))     obj.hillsDirDeg     = 0;
          if(typeof obj.hillsShape      !== "string")                                   obj.hillsShape      = "ramp";
          if(typeof obj.hillsTravelFactor !== "number" || !isFinite(obj.hillsTravelFactor)) obj.hillsTravelFactor = 1.0;
        }
        // If this terrain already uses the human ID scheme, keep the ID prefix consistent with the new type.
        if(isHumanIdForKind("terrain", oldId)){
          const newId = allocId("terrain", obj);
          obj.id = newId;
          updateSelectionId("terrain", oldId, newId);
          renderInspector();
        }
        draw();
      });
      document.getElementById("inspTOp").addEventListener("input",(e)=>{ obj.opacity = clamp(parseFloat(e.target.value)||0.35, 0.05, 0.95); draw(); });

      if(obj.terrainType === "hills"){
        // Ensure dropdown reflects current value
        const shapeEl = document.getElementById("inspHillShape");
        if(shapeEl) shapeEl.value = obj.hillsShape || "ramp";

        const rbEl = document.getElementById("inspHillRangeBonus");
        if(rbEl) rbEl.addEventListener("input",(e)=>{ obj.hillsRangeBonus = clamp(parseFloat(e.target.value)||1.25, 1.0, 3.0); draw(); });

        const hEl = document.getElementById("inspHillHeight");
        if(hEl) hEl.addEventListener("input",(e)=>{ obj.hillsHeightFt = clamp(parseFloat(e.target.value)||30, 0, 500); draw(); });

        const dEl = document.getElementById("inspHillDir");
        if(dEl) dEl.addEventListener("input",(e)=>{ obj.hillsDirDeg = ((parseFloat(e.target.value)||0)%360+360)%360; draw(); });

        if(shapeEl) shapeEl.addEventListener("change",(e)=>{ obj.hillsShape = e.target.value; draw(); });

        const tfEl = document.getElementById("inspHillTravel");
        if(tfEl) tfEl.addEventListener("input",(e)=>{ obj.hillsTravelFactor = clamp(parseFloat(e.target.value)||1.0, 0.5, 2.0); draw(); });
      }

      return;
    }
  }

  // ---------- object creation ----------
  function addSoldierAt(x, y, side){
    const r = 1;
    const pos = pushCircleOutOfBuildings(x, y, r, state.buildings);
    const s = {id: allocId("soldier"), x: pos.x, y: pos.y, side: side || "friendly", label:"", r, rangeFt: DEFAULT_SOLDIER_RANGE_FT, zOffsetFt:0};
    addObjects([{kind:"soldier", data:s}]);
    setSelection({kind:"soldier", id:s.id});
  }

  function addSoldiersBulk(list){
    // list: [{x,y,side,label,r,rangeFt,zOffsetFt}]
    const objs = list.map(p => {
      const r = (typeof p.r === "number") ? p.r : 1;
      const pos = pushCircleOutOfBuildings(p.x, p.y, r, state.buildings);
      return {kind:"soldier", data:{
        id: allocId("soldier"),
        x: pos.x,
        y: pos.y,
        side: p.side || "friendly",
        label: p.label || "",
        r,
        rangeFt: (typeof p.rangeFt === "number" && isFinite(p.rangeFt) && p.rangeFt > 0) ? p.rangeFt : DEFAULT_SOLDIER_RANGE_FT,
        zOffsetFt: (typeof p.zOffsetFt === "number" && isFinite(p.zOffsetFt)) ? p.zOffsetFt : 0
      }};
    });
    const refs = addObjects(objs);
    // select all newly added soldiers
    if(refs.length) setMultiSelection(refs);
  }

  function addBuildingRect(x, y, w, h){
    const b = {id: allocId("building"), x, y, w, h, name:"Building", floors:1, floorHeightFt:10, roofExtraFt:0};
    addObjects([{kind:"building", data:b}]);
    setSelection({kind:"building", id:b.id});
  }

  function addRoad(points){
    const r = {id: allocId("road"), points, width:10, roadType:"paved", name:"Road"};
    addObjects([{kind:"road", data:r}]);
    setSelection({kind:"road", id:r.id});
  }

  function addTerrain(points){
    const t = {id: allocId("terrain", {terrainType:"open"}), points, terrainType:"open", name:"Terrain", opacity:0.35};
    addObjects([{kind:"terrain", data:t}]);
    setSelection({kind:"terrain", id:t.id});
  }

  // ---------- formations (geometry only) ----------
  function formationPoints(origin, formationKey, spacingFt, n){
    const s = spacingFt;
    const pts = [];

    if(formationKey === "file"){
      for(let i=0;i<n;i++){
        pts.push({x: origin.x, y: origin.y + i*s});
      }
      return pts;
    }

    if(formationKey === "line"){
      const startX = origin.x - ((n-1) * s)/2;
      for(let i=0;i<n;i++){
        pts.push({x: startX + i*s, y: origin.y});
      }
      return pts;
    }

    // wedge (tip at origin, rows behind)
    pts.push({x: origin.x, y: origin.y});
    let remaining = n - 1;
    let row = 1;
    while(remaining > 0){
      const desired = row + 1; // 2,3,4,...
      const count = Math.min(remaining, desired);
      const y = origin.y + row * s;
      const spread = (count - 1) * s;
      for(let i=0;i<count;i++){
        const x = origin.x - spread/2 + i*s;
        pts.push({x, y});
      }
      remaining -= count;
      row++;
    }
    pts.length = n;
    return pts;
  }

    function placeGroupFormation(origin, formationKey, spacingFt, side, groupSize){
    const n = clamp(groupSize||6, 4, 9);
    const pts = formationPoints(origin, formationKey, spacingFt, n);
    addSoldiersBulk(pts.map(p => ({...p, side})));
  }

  function placePlatoon(origin, formationKey, squadFormationKey, squadSpacing, squadGap, side, groupSize){
    // 3 groups arranged
    const s = squadGap;
    const offsets = [];

    if(formationKey === "platoon-column"){
      offsets.push({dx:0, dy:0});
      offsets.push({dx:0, dy:s});
      offsets.push({dx:0, dy:2*s});
    } else if(formationKey === "platoon-line"){
      offsets.push({dx:-s, dy:0});
      offsets.push({dx:0, dy:0});
      offsets.push({dx:s, dy:0});
    } else { // wedge
      offsets.push({dx:0, dy:0});
      offsets.push({dx:-s*0.75, dy:s});
      offsets.push({dx:s*0.75, dy:s});
    }

    const n = clamp(groupSize||6, 4, 9);
    const soldiers = [];
    for(const off of offsets){
      const o = {x: origin.x + off.dx, y: origin.y + off.dy};
      const pts = formationPoints(o, squadFormationKey, squadSpacing, n);
      for(let i=0;i<pts.length;i++){
        soldiers.push({x: pts[i].x, y: pts[i].y, side});
      }
    }
    addSoldiersBulk(soldiers);
  }


  // ---------- interactions ----------

  function updateCursor(){
    if(state.overlay && state.overlay.dragMode && state.overlay.dataUrl){
      canvas.style.cursor = state.overlay.dragging ? "grabbing" : "grab";
      return;
    }
    if(state.tool === "select"){
      if(state.isPanning || state.panPending || state.isDraggingSelection || state.draggingObj){
        canvas.style.cursor = "grabbing";
      } else if(state.shiftDown){
        // Shift = marquee (highlight) mode
        canvas.style.cursor = "crosshair";
      } else {
        // normal select / inspect
        canvas.style.cursor = "default";
      }
    } else if(state.tool === "add-building"){
      canvas.style.cursor = "crosshair";
    } else {
      canvas.style.cursor = "crosshair";
    }
  }

  function setTool(t){
    state.tool = t;
    toolReadout.textContent = t;
    // end any partial drawing when switching away
    if(state.drawing && t !== "add-road" && t !== "add-terrain" && t !== "add-building"){
      state.drawing = null;
    }
    updateCursor();
    draw();
  }

  toolSelect.addEventListener("change", (e)=>{
    setTool(e.target.value);
  });


  function syncPickLayerUI(){
    if(!state.pickFilter) state.pickFilter = {soldier:true, building:true, road:true, terrain:true};
    if(pickSoldiers)  pickSoldiers.checked  = state.pickFilter.soldier !== false;
    if(pickBuildings) pickBuildings.checked = state.pickFilter.building !== false;
    if(pickRoads)     pickRoads.checked     = state.pickFilter.road !== false;
    if(pickTerrains)  pickTerrains.checked  = state.pickFilter.terrain !== false;
  }
  function applyPickLayerFromUI(){
    if(!state.pickFilter) state.pickFilter = {soldier:true, building:true, road:true, terrain:true};
    if(pickSoldiers)  state.pickFilter.soldier  = !!pickSoldiers.checked;
    if(pickBuildings) state.pickFilter.building = !!pickBuildings.checked;
    if(pickRoads)     state.pickFilter.road     = !!pickRoads.checked;
    if(pickTerrains)  state.pickFilter.terrain  = !!pickTerrains.checked;
    updateCursor();
    draw();
  }

  if(pickSoldiers)  pickSoldiers.addEventListener("change", applyPickLayerFromUI);
  if(pickBuildings) pickBuildings.addEventListener("change", applyPickLayerFromUI);
  if(pickRoads)     pickRoads.addEventListener("change", applyPickLayerFromUI);
  if(pickTerrains)  pickTerrains.addEventListener("change", applyPickLayerFromUI);

  if(pickOnlySoldiersBtn){
    pickOnlySoldiersBtn.addEventListener("click", ()=>{
      state.pickFilter = {soldier:true, building:false, road:false, terrain:false};
      syncPickLayerUI();
      updateCursor();
      draw();
    });
  }
  if(pickAllLayersBtn){
    pickAllLayersBtn.addEventListener("click", ()=>{
      state.pickFilter = {soldier:true, building:true, road:true, terrain:true};
      syncPickLayerUI();
      updateCursor();
      draw();
    });
  }

  // Initialize UI from state
  syncPickLayerUI();

  placeSquadFormationBtn.addEventListener("click", ()=>{
    setTool("place-squad");
  });

  placePlatoonFormationBtn.addEventListener("click", ()=>{
    setTool("place-platoon");
  });

  finishShapeBtn.addEventListener("click", ()=>{
    finishDrawing();
  });

  undoBtn.addEventListener("click", undo);

  clearBtn.addEventListener("click", ()=>{
    if(!confirm("Clear all soldiers, buildings, roads, and terrain?")) return;
    state.soldiers.length = 0;
    state.buildings.length = 0;
    state.roads.length = 0;
    state.terrains.length = 0;
    state.selected = null;
    state.undo.length = 0;
    undoBtn.disabled = true;
    renderInspector();
    updateCursor();
    draw();
  });

  deleteSelectedBtn.addEventListener("click", deleteSelected);
  duplicateSelectedBtn.addEventListener("click", duplicateSelected);
  deselectAllBtn.addEventListener("click", clearSelection);

  // Save / Import
  exportMapBtn.addEventListener("click", exportMapAsJS);

  importMapBtn.addEventListener("click", ()=>{
    importMapFile.click();
  });

  importMapFile.addEventListener("change", async (e)=>{
    const file = e.target.files && e.target.files[0];
    if(!file) return;
    const text = await file.text();
    try{
      importMapFromText(text);
    }catch(err){
      console.error(err);
      alert("Import failed. Make sure the file is valid JSON, or a JS save file that sets window.FORMATION_MAP_DATA.");
    }
    importMapFile.value = ""; // allow re-importing same file
  });

  // --- Image overlay controls ---
  if(overlayUploadBtn && overlayFile){
    overlayUploadBtn.addEventListener("click", ()=> overlayFile.click());
  }

  if(overlayFile){
    overlayFile.addEventListener("change", (e)=>{
      const file = e.target.files && e.target.files[0];
      if(!file) return;
      if(file.type && !file.type.startsWith("image/")){
        alert("Please choose an image file.");
        overlayFile.value = "";
        return;
      }
      const reader = new FileReader();
      reader.onload = ()=>{
        const url = String(reader.result || "");
        setOverlayImageDataUrl(url);
        syncOverlayUI();
        draw();
        overlayFile.value = "";
      };
      reader.readAsDataURL(file);
    });
  }

  if(overlayClearBtn){
    overlayClearBtn.addEventListener("click", ()=>{
      if(!state.overlay || !state.overlay.dataUrl) return;
      if(!confirm("Remove the overlay image?")) return;
      setOverlayImageDataUrl(null);
      syncOverlayUI();
      draw();
    });
  }

  if(overlayVisible){
    overlayVisible.addEventListener("change", ()=>{
      if(!state.overlay) return;
      state.overlay.visible = !!overlayVisible.checked;
      draw();
    });
  }

  if(overlayDrag){
    overlayDrag.addEventListener("change", ()=>{
      if(!state.overlay) return;
      state.overlay.dragMode = !!overlayDrag.checked;
      if(!state.overlay.dragMode){
        state.overlay.dragging = false;
        state.overlay._dragStart = null;
      }
      updateCursor();
      draw();
    });
  }

  if(overlayOpacity){
    overlayOpacity.addEventListener("input", ()=>{
      if(!state.overlay) return;
      const v = parseFloat(overlayOpacity.value);
      state.overlay.opacity = isFinite(v) ? clamp(v, 0, 1) : 0.6;
      if(overlayOpacityReadout) overlayOpacityReadout.textContent = state.overlay.opacity.toFixed(2);
      draw();
    });
  }

  if(overlayScale){
    const applyScale = ()=>{
      if(!state.overlay) return;
      const v = parseFloat(overlayScale.value);
      state.overlay.scale = (isFinite(v) && v > 0) ? v : 1;
      draw();
    };
    overlayScale.addEventListener("input", applyScale);
    overlayScale.addEventListener("change", ()=>{ applyScale(); syncOverlayUI(); });
  }

  if(overlayRotation){
    const applyRot = ()=>{
      if(!state.overlay) return;
      const v = parseFloat(overlayRotation.value);
      state.overlay.rotation = isFinite(v) ? v : 0;
      draw();
    };
    overlayRotation.addEventListener("input", applyRot);
    overlayRotation.addEventListener("change", ()=>{ applyRot(); syncOverlayUI(); });
  }

  const applyXY = ()=>{
    if(!state.overlay) return;
    const x = overlayX ? parseFloat(overlayX.value) : NaN;
    const y = overlayY ? parseFloat(overlayY.value) : NaN;
    if(isFinite(x)) state.overlay.cx = x;
    if(isFinite(y)) state.overlay.cy = y;
    draw();
  };
  if(overlayX) overlayX.addEventListener("input", applyXY);
  if(overlayY) overlayY.addEventListener("input", applyXY);

  if(overlayCenterBtn) overlayCenterBtn.addEventListener("click", overlayCenterToView);
  if(overlayFitBtn) overlayFitBtn.addEventListener("click", overlayFitToView);
  if(overlayResetBtn) overlayResetBtn.addEventListener("click", overlayResetTransform);

  syncOverlayUI();


  centerViewBtn.addEventListener("click", ()=>{
    state.panX = (container.clientWidth/2);
    state.panY = (container.clientHeight/2);
    state.zoom = 1;
    updateCursor();
    draw();
  });

  toggleGridBtn.addEventListener("click", ()=>{
    state.showGrid = !state.showGrid;
    toggleGridBtn.textContent = "Grid: " + (state.showGrid ? "On" : "Off");
    updateCursor();
    draw();
  });


  function cycleDisplayMode(current){
    // off -> selected -> all -> off
    if(current === "off") return "selected";
    if(current === "selected") return "all";
    return "off";
  }


  // Keep cycling/toggle buttons from shifting layout when their labels change
  function lockCycleButtonWidth(btn, labels){
    if(!btn || !labels || !labels.length) return;
    const cs = window.getComputedStyle(btn);

    const span = document.createElement("span");
    span.style.position = "absolute";
    span.style.visibility = "hidden";
    span.style.whiteSpace = "nowrap";
    span.style.fontFamily = cs.fontFamily;
    span.style.fontSize = cs.fontSize;
    span.style.fontWeight = cs.fontWeight;
    span.style.letterSpacing = cs.letterSpacing;
    span.style.textTransform = cs.textTransform;
    span.style.fontVariant = cs.fontVariant;

    document.body.appendChild(span);
    let max = 0;
    for(const t of labels){
      span.textContent = t;
      max = Math.max(max, span.getBoundingClientRect().width);
    }
    document.body.removeChild(span);

    const padL = parseFloat(cs.paddingLeft) || 0;
    const padR = parseFloat(cs.paddingRight) || 0;
    const borderL = parseFloat(cs.borderLeftWidth) || 0;
    const borderR = parseFloat(cs.borderRightWidth) || 0;
    const w = Math.ceil(max + padL + padR + borderL + borderR + 2);

    btn.style.boxSizing = "border-box";
    btn.style.width = w + "px";
  }

  function lockAllCyclingButtonWidths(){
    lockCycleButtonWidth(toggleGridBtn, ["Grid: Off", "Grid: On"]);
    lockCycleButtonWidth(toggleRangesBtn, ["Ranges: Off", "Ranges: Selected", "Ranges: All"]);
    lockCycleButtonWidth(toggleConesBtn, ["Cones: Off", "Cones: Selected", "Cones: All"]);
    lockCycleButtonWidth(toggleMovePathsBtn, ["Paths: Off", "Paths: Selected", "Paths: All"]);
    lockCycleButtonWidth(simPlayBtn, ["Play", "Pause"]);
  }

  function updateSoldierVizButtons(){
    const r = state.rangeDisplay;
    const c = state.coneDisplay;
    toggleRangesBtn.textContent = "Ranges: " + (r === "off" ? "Off" : (r === "all" ? "All" : "Selected"));
    toggleConesBtn.textContent = "Cones: " + (c === "off" ? "Off" : (c === "all" ? "All" : "Selected"));
  }

  toggleRangesBtn.addEventListener("click", ()=>{
    state.rangeDisplay = cycleDisplayMode(state.rangeDisplay);
    updateSoldierVizButtons();
    updateCursor();
    draw();
  });

  toggleConesBtn.addEventListener("click", ()=>{
    state.coneDisplay = cycleDisplayMode(state.coneDisplay);
    updateSoldierVizButtons();
    updateCursor();
    draw();
  });

  // --- Movement path + Sim controls ---
  function updateMovePathButton(){
    const m = state.movePathDisplay;
    toggleMovePathsBtn.textContent = "Paths: " + (m === "off" ? "Off" : (m === "all" ? "All" : "Selected"));
  }

  toggleMovePathsBtn.addEventListener("click", ()=>{
    state.movePathDisplay = cycleDisplayMode(state.movePathDisplay);
    updateMovePathButton();
    updateCursor();
    draw();
  });

  function updateSimUI(){
    if(simSpeedReadout){
      simSpeedReadout.textContent = (state.sim.speed || 1).toFixed(2) + "x";
    }
    if(simTimeReadout){
      simTimeReadout.textContent = "t=" + (state.sim.t || 0).toFixed(1) + "s";
    }
    if(simPlayBtn){
      simPlayBtn.textContent = (state.sim.playing ? "Pause" : "Play");
    }
  }

  simPlayBtn.addEventListener("click", ()=>{
    if(state.sim.playing){
      pauseSim();
    }else{
      playSim();
    }
    updateSimUI();
    draw();
  });

  simResetBtn.addEventListener("click", ()=>{
    resetSim();
    updateSimUI();
    draw();
  });

  simSpeed.addEventListener("input", ()=>{
    const v = parseFloat(simSpeed.value);
    state.sim.speed = (isFinite(v) && v > 0) ? v : 1;
    updateSimUI();
  });

  // Initial button labels/readouts
  updateMovePathButton();
  updateSimUI();

  function finishDrawing(){
    const d = state.drawing;
    if(!d) return;

    if(d.kind === "road"){
      if(d.points.length >= 2){
        addRoad(d.points);
      }
      state.drawing = null;
      updateUndoButton();
      draw();
    }
    if(d.kind === "terrain"){
      if(d.points.length >= 3){
        addTerrain(d.points);
      }
      state.drawing = null;
      updateUndoButton();
      draw();
    }
    if(d.kind === "building"){
      if(d.start && d.end){
        const x = Math.min(d.start.x, d.end.x);
        const y = Math.min(d.start.y, d.end.y);
        const w = Math.abs(d.end.x - d.start.x);
        const h = Math.abs(d.end.y - d.start.y);
        if(w >= 5 && h >= 5){
          addBuildingRect(x,y,w,h);
        }
      }
      state.drawing = null;
      updateUndoButton();
      draw();
    }
  }

  function setMouseFromEvent(ev){
    const rect = canvas.getBoundingClientRect();
    const sx = ev.clientX - rect.left;
    const sy = ev.clientY - rect.top;
    const w = screenToWorld(sx, sy);
    state.lastMouse = {sx, sy, x:w.x, y:w.y};
    mouseReadout.textContent = `${w.x.toFixed(1)}, ${w.y.toFixed(1)}`;
  }

  canvas.addEventListener("mousemove", (ev)=>{
    setMouseFromEvent(ev);

    if(state.overlay && state.overlay.dragging && state.overlay._dragStart){
      const dsx = state.lastMouse.sx - state.overlay._dragStart.sx;
      const dsy = state.lastMouse.sy - state.overlay._dragStart.sy;
      const dxWorld = dsx / state.zoom;
      const dyWorld = dsy / state.zoom;
      state.overlay.cx = state.overlay._dragStart.cx + dxWorld;
      state.overlay.cy = state.overlay._dragStart.cy + dyWorld;
      syncOverlayUI();
      draw();
      return;
    }

    // drawing previews
    if(state.drawing && (state.drawing.kind==="road" || state.drawing.kind==="terrain")){
      state.drawing.previewTo = {x: state.lastMouse.x, y: state.lastMouse.y};
      draw();
    }
    if(state.drawing && state.drawing.kind==="building" && state.drawing.start){
      state.drawing.end = {x: state.lastMouse.x, y: state.lastMouse.y};
      draw();
    }
    // box select (drag empty area)
    if(state.boxSelect && state.boxSelect.active){
      state.boxSelect.sx1 = state.lastMouse.sx;
      state.boxSelect.sy1 = state.lastMouse.sy;
      const r = normRect(state.boxSelect);
      state.boxSelect.previewRefs = refsInScreenRect(r);
      updateCursor();
      draw();
      return;
    }

    // pending pan (started by dragging empty space in Select tool)
    if(state.panPending && state.dragStart && !state.isPanning){
      const dx = state.lastMouse.sx - state.dragStart.sx;
      const dy = state.lastMouse.sy - state.dragStart.sy;
      if(Math.hypot(dx, dy) >= 3){
        state.isPanning = true;
        state.panPending = false;
        updateCursor();
      } else {
        return;
      }
    }

    // panning
    if(state.isPanning && state.dragStart){
      const dx = state.lastMouse.sx - state.dragStart.sx;
      const dy = state.lastMouse.sy - state.dragStart.sy;
      state.panX = state.dragStart.panX + dx;
      state.panY = state.dragStart.panY + dy;
      draw();
      return;
    }

// dragging selection (single or multi)
if(state.isDraggingSelection && state.dragStart){
  const dxWorld = (state.lastMouse.sx - state.dragStart.sx) / state.zoom;
  const dyWorld = (state.lastMouse.sy - state.dragStart.sy) / state.zoom;

  const group = state.dragStart.groupBefore;

  if(Array.isArray(group) && group.length){
    for(const g of group){
      const ref = g.ref;
      const obj = getByRef(ref);
      if(!obj) continue;

      if(ref.kind==="soldier"){
        const base = g.before;
        let dx = dxWorld, dy = dyWorld;

        // Soft / "weaker" collision effect for woods + rough: drag-resistance (object lags behind the mouse).
        const resist = terrainResistanceFactor(base.x + dx, base.y + dy, state.terrains);
        dx *= resist;
        dy *= resist;

        // Hard collision vs buildings: soldier stops at the building edge.
        const r = (typeof obj.r === "number") ? obj.r : 1;
        const p = resolveSoldierDragAgainstBuildings(base.x, base.y, dx, dy, r, state.buildings);
        obj.x = p.x;
        obj.y = p.y;
      } else if(ref.kind==="building"){
        const base = g.before;
        // Buildings collide with other buildings (hard).
        const p = resolveBuildingDragAgainstBuildings(base, dxWorld, dyWorld, state.buildings);
        obj.x = p.x;
        obj.y = p.y;
      } else if(ref.kind==="road"){
        obj.points = g.before.points.map(p => ({x:p.x + dxWorld, y:p.y + dyWorld}));
      } else if(ref.kind==="terrain"){
        obj.points = g.before.points.map(p => ({x:p.x + dxWorld, y:p.y + dyWorld}));
      }
    }

    renderInspector();
    draw();
    return;
  }

  // Fallback: single-object drag (older dragStart format)
  if(state.selected){
    const ref = state.selected;
    const obj = getByRef(ref);
    if(!obj) return;

    if(ref.kind==="soldier"){
      const base = state.dragStart.objBefore;
      let dx = dxWorld, dy = dyWorld;

      const resist = terrainResistanceFactor(base.x + dx, base.y + dy, state.terrains);
      dx *= resist;
      dy *= resist;

      const r = (typeof obj.r === "number") ? obj.r : 1;
      const p = resolveSoldierDragAgainstBuildings(base.x, base.y, dx, dy, r, state.buildings);
      obj.x = p.x;
      obj.y = p.y;
    } else if(ref.kind==="building"){
      const base = state.dragStart.objBefore;
      const p = resolveBuildingDragAgainstBuildings(base, dxWorld, dyWorld, state.buildings);
      obj.x = p.x;
      obj.y = p.y;
    } else if(ref.kind==="road"){
      obj.points = state.dragStart.objBefore.points.map(p => ({x:p.x + dxWorld, y:p.y + dyWorld}));
    } else if(ref.kind==="terrain"){
      obj.points = state.dragStart.objBefore.points.map(p => ({x:p.x + dxWorld, y:p.y + dyWorld}));
    }

    renderInspector();
    draw();
    return;
  }
}

  });

  canvas.addEventListener("mousedown", (ev)=>{
    setMouseFromEvent(ev);

    // Overlay drag mode: left-drag moves the overlay image (no selecting/moving units).
    if(state.overlay && state.overlay.dragMode && state.overlay.dataUrl && overlayImg){
      if(ev.button === 0){
        state.overlay.dragging = true;
        state.overlay._dragStart = {
          sx: state.lastMouse.sx,
          sy: state.lastMouse.sy,
          cx: state.overlay.cx || 0,
          cy: state.overlay.cy || 0
        };
        updateCursor();
        draw();
        return;
      }
    }

    // SELECT TOOL: Drag empty space pans; Shift+drag highlights (marquee-select)
    if(state.tool === "select"){
      const wpt = {x: state.lastMouse.x, y: state.lastMouse.y};

      // Highlight (marquee-select): Shift + drag
      if(ev.shiftKey){
        state.boxSelect = {active:true, sx0:state.lastMouse.sx, sy0:state.lastMouse.sy, sx1:state.lastMouse.sx, sy1:state.lastMouse.sy, previewRefs:[]};
        updateCursor();
        draw();
        return;
      }

      const hit = hitTest(wpt, {cycle: ev.altKey});

      // Cmd/Ctrl + click toggles selection membership
      if(ev.metaKey || ev.ctrlKey){
        if(hit){
          const current = (state.selectedMulti && state.selectedMulti.length) ? state.selectedMulti.slice()
                        : (state.selected ? [deepClone(state.selected)] : []);
          const has = (arr, r)=> arr.some(x => x.kind===r.kind && x.id===r.id);
          let next = current.slice();
          if(has(next, hit)){
            next = next.filter(x => !(x.kind===hit.kind && x.id===hit.id));
          } else {
            next.push(hit);
          }
          if(next.length === 0) clearSelection();
          else if(next.length === 1) setSelection(next[0]);
          else setMultiSelection(next);
        }
        updateCursor();
        draw();
        return;
      }

      // Soldiers: move with click-drag ONLY if you start within a tight screen-pixel radius.
if(hit && hit.kind === "soldier"){
  const tight = hitTestSoldierTight(wpt, 6);
  if(tight && tight.id === hit.id){

    // If we already have a multi-selection of ONLY soldiers, and this soldier is in it,
    // dragging moves the whole selected group.
    const curRefs = (state.selectedMulti && state.selectedMulti.length) ? state.selectedMulti.slice()
                 : (state.selected ? [deepClone(state.selected)] : []);
    const allSoldiers = (curRefs.length > 1) && curRefs.every(r => r.kind === "soldier");
    const inGroup = allSoldiers && curRefs.some(r => r.id === tight.id);

    if(allSoldiers && inGroup){
      // Make the clicked soldier the "primary" selection without collapsing the multi list.
      state.selected = {kind:"soldier", id: tight.id};

      if(state.sim && state.sim.playing){
        // Selection only while sim is running (no drag editing).
        updateCursor();
        draw();
        return;
      }

      state.isDraggingSelection = true;
      state.dragStart = {
        sx: state.lastMouse.sx,
        sy: state.lastMouse.sy,
        groupBefore: curRefs
          .map(r => ({ref: deepClone(r), before: deepClone(getByRef(r))}))
          .filter(g => !!g.before)
      };

      updateCursor();
      draw();
      return;
    }

    // Otherwise drag just this soldier.
    setSelection(tight);
    const obj = getByRef(state.selected);
    if(obj){
      if(state.sim && state.sim.playing){
        // Selection only while sim is running (no drag editing).
        updateCursor();
        draw();
        return;
      }
      state.isDraggingSelection = true;
      state.dragStart = {
        sx: state.lastMouse.sx,
        sy: state.lastMouse.sy,
        objBefore: deepClone(obj),
        ref: deepClone(state.selected),
        groupBefore: [{ref: deepClone(state.selected), before: deepClone(obj)}]
      };
    }
    updateCursor();
    draw();
    return;
  }

  // If you're not close enough to start a drag, still allow click-to-select.
  // Preserve multi-selection if this soldier is already selected.
  if(state.selectedMulti && state.selectedMulti.length){
    const already = state.selectedMulti.some(r => r.kind==="soldier" && r.id===hit.id);
    if(already){
      state.selected = {kind:"soldier", id: hit.id};
      renderInspector();
      updateCursor();
      draw();
      return;
    }
  }

  setSelection(hit);
  updateCursor();
  draw();
  return;
}


      // Other objects: click selects; click-drag moves the selected object.
      if(hit){
        setSelection(hit);
        const obj = getByRef(state.selected);
        if(obj){
          state.isDraggingSelection = true;
          state.dragStart = {
            sx: state.lastMouse.sx,
            sy: state.lastMouse.sy,
            objBefore: deepClone(obj),
            ref: deepClone(state.selected),
            groupBefore: [{ref: deepClone(state.selected), before: deepClone(obj)}]
          };
        }
        updateCursor();
        draw();
        return;
      }

      // Empty space: click clears; drag pans (start as pending so a click doesn't accidentally pan)
      state.panPending = true;
      state.dragStart = {sx: state.lastMouse.sx, sy: state.lastMouse.sy, panX: state.panX, panY: state.panY};
      updateCursor();
      return;
    }

    // Building drag start (unchanged)
    if(state.tool === "add-building"){
      state.drawing = {kind:"building", start:{x:state.lastMouse.x, y:state.lastMouse.y}, end:{x:state.lastMouse.x, y:state.lastMouse.y}};
      updateUndoButton();
      draw();
      return;
    }
  });

  canvas.addEventListener("mouseup", (ev)=>{
    setMouseFromEvent(ev);

    if(state.overlay && state.overlay.dragging){
      state.overlay.dragging = false;
      state.overlay._dragStart = null;
      syncOverlayUI();
      updateCursor();
      draw();
      return;
    }


    // Finish marquee selection
    if(state.boxSelect && state.boxSelect.active){
      const r = normRect(state.boxSelect);
      const refs = refsInScreenRect(r);
      state.boxSelect = null;

      if(refs.length > 0){
        // Union with existing selection (additive multi-select)
        const current = (state.selectedMulti && state.selectedMulti.length) ? state.selectedMulti.slice()
                      : (state.selected ? [deepClone(state.selected)] : []);
        const has = (arr, rr)=> arr.some(x => x.kind===rr.kind && x.id===rr.id);

        const next = current.slice();
        for(const rr of refs){
          if(!has(next, rr)) next.push(rr);
        }

        if(next.length === 1){
          setSelection(next[0]);
        } else {
          setMultiSelection(next);
        }
      } else {
        // Empty marquee: keep current selection (no change)
        renderInspector();
        draw();
      }

      updateCursor();
      draw();
      return;
    }

    if(state.panPending){
      // Treat as a click on empty space (no pan movement) -> clear selection
      state.panPending = false;
      state.dragStart = null;
      clearSelection();
      renderInspector();
      updateCursor();
      draw();
      return;
    }

    if(state.isPanning){
      state.isPanning = false;
      state.panPending = false;
      state.dragStart = null;
      updateCursor();
      return;
    }

if(state.isDraggingSelection && state.dragStart){
  const moves = [];

  const group = state.dragStart.groupBefore;

  if(Array.isArray(group) && group.length){
    for(const g of group){
      const ref = g.ref;
      const obj = getByRef(ref);
      if(!obj) continue;

      const before = g.before;
      let changed = false;

      if(ref.kind==="soldier" || ref.kind==="building"){
        changed = (Math.abs(obj.x - before.x) > 0.001) || (Math.abs(obj.y - before.y) > 0.001);
      } else {
        changed = JSON.stringify(obj.points) !== JSON.stringify(before.points);
      }

      if(changed){
        moves.push({ref: deepClone(ref), before: deepClone(before)});
      }
    }

    if(moves.length){
      pushUndo({kind:"move", moves});
    }
  } else if(state.selected && state.dragStart.ref && state.dragStart.objBefore){
    // Fallback: older single-object dragStart format
    const ref = state.dragStart.ref;
    const obj = getByRef(ref);
    if(obj){
      const before = state.dragStart.objBefore;
      let changed = false;

      if(ref.kind==="soldier" || ref.kind==="building"){
        changed = (Math.abs(obj.x - before.x) > 0.001) || (Math.abs(obj.y - before.y) > 0.001);
      } else {
        changed = JSON.stringify(obj.points) !== JSON.stringify(before.points);
      }

      if(changed){
        pushUndo({kind:"move", moves:[{ref: deepClone(ref), before: deepClone(before)}]});
      }
    }
  }

  state.isDraggingSelection = false;
  state.dragStart = null;
  updateCursor();
  return;
}


    // Finish building if in building mode and had drawing
    if(state.drawing && state.drawing.kind==="building"){
      finishDrawing();
      return;
    }
  });

  canvas.addEventListener("dblclick", (ev)=>{
    // Double click to finish road/terrain
    if(state.drawing && (state.drawing.kind==="road" || state.drawing.kind==="terrain")){
      finishDrawing();
    }
  });

  canvas.addEventListener("click", (ev)=>{
    setMouseFromEvent(ev);

    // If you start editing while the sim is running, pause first.
    if(state.sim && state.sim.playing && state.tool !== "select"){
      pauseSim();
      if(typeof updateSimUI === "function") updateSimUI();
    }

    const w = {x: state.lastMouse.x, y: state.lastMouse.y};
    const side = soldierSide.value || "friendly";

    if(state.tool === "select"){
      // Selection is Space+click (handled on mousedown/mouseup).
      return;
    }

    if(state.tool === "move-waypoints"){
      if(state.sim && state.sim.playing) return;
      applyMoveWaypointClick(w, ev);
      return;
    }

    if(state.tool === "add-soldier"){
      addSoldierAt(w.x, w.y, side);
      return;
    }

    if(state.tool === "add-road"){
      if(!state.drawing || state.drawing.kind!=="road"){
        state.drawing = {kind:"road", points:[{x:w.x, y:w.y}], previewTo:null};
      } else {
        state.drawing.points.push({x:w.x, y:w.y});
      }
      updateUndoButton();
      draw();
      return;
    }

    if(state.tool === "add-terrain"){
      if(!state.drawing || state.drawing.kind!=="terrain"){
        state.drawing = {kind:"terrain", points:[{x:w.x, y:w.y}], previewTo:null};
      } else {
        state.drawing.points.push({x:w.x, y:w.y});
      }
      updateUndoButton();
      draw();
      return;
    }

    if(state.tool === "place-squad"){
      const formationKey = squadFormation.value;
      const spacingFt = clamp(parseFloat(squadSpacingEl.value)||33, 1, 1000);
      const groupSize = clamp(parseInt(squadSizeEl.value,10)||6, 4, 9);
      placeGroupFormation(w, formationKey, spacingFt, side, groupSize);
      setTool("select");
      return;
    }

    if(state.tool === "place-platoon"){
      const formationKey = platoonFormation.value;
      const squadForm = squadFormation.value;
      const squadSpacing = clamp(parseFloat(squadSpacingEl.value)||33, 1, 1000);
      const platoonSpacing = clamp(parseFloat(platoonSpacingEl.value)||220, 10, 5000);
      const groupSize = clamp(parseInt(squadSizeEl.value,10)||6, 4, 9);
      placePlatoon(w, formationKey, squadForm, squadSpacing, platoonSpacing, side, groupSize);
      setTool("select");
      return;
    }
  });

  // Zoom on canvas only (prevents sidebar scroll lock)
  canvas.addEventListener("wheel", (ev)=>{
    ev.preventDefault();

    setMouseFromEvent(ev);
    const oldZoom = state.zoom;

    // moderate trackpad-friendly zoom
    const scale = Math.pow(1.0015, -ev.deltaY);
    const newZoom = Math.max(oldZoom * scale, 0.02); // no max zoom cap; keep a tiny minimum

    // zoom around cursor
    const mx = state.lastMouse.sx;
    const my = state.lastMouse.sy;

    const worldBefore = screenToWorld(mx, my);
    state.zoom = newZoom;
    const worldAfter = screenToWorld(mx, my);

    // Adjust pan so world point under cursor stays stable
    state.panX += (worldAfter.x - worldBefore.x) * state.zoom;
    state.panY += (worldAfter.y - worldBefore.y) * state.zoom;

    updateCursor();
    draw();
  }, {passive:false});

  // keyboard
  window.addEventListener("keydown", (ev)=>{
    if(ev.code === "Space"){
      state.spaceDown = true;
      updateCursor();
      // prevent page scroll/jank when holding space, unless typing
      const t = (ev.target && ev.target.tagName) ? ev.target.tagName.toLowerCase() : "";
      if(t !== "input" && t !== "textarea") ev.preventDefault();
    }
    if(ev.code === "ShiftLeft" || ev.code === "ShiftRight"){
      state.shiftDown = true;
      updateCursor();
    }

    if(ev.key === "Escape"){
      state.drawing = null;
      updateUndoButton();
      draw();
    }
    if(ev.key === "Delete" || ev.key === "Backspace"){
      if(state.selected){
        deleteSelected();
      } else {
        const ref = nearestAnything({x:state.lastMouse.x, y:state.lastMouse.y});
        if(ref){
          const obj = getByRef(ref);
          if(obj){
            removeByRef(ref);
            pushUndo({kind:"delete", items:[{ref: deepClone(ref), data: deepClone(obj)}]});
            renderInspector();
            draw();
          }
        }
      }
    }
    if((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === "z"){
      ev.preventDefault();
      undo();
    }
  });

  window.addEventListener("keyup", (ev)=>{
    if(ev.code === "Space"){
      state.spaceDown = false;
      updateCursor();
    }
    if(ev.code === "ShiftLeft" || ev.code === "ShiftRight"){
      state.shiftDown = false;
      updateCursor();
    }

  });

  // Keep tool readout fresh
  setTool("select");
  updateUndoButton();
  renderInspector();
  updateCursor();
  updateSoldierVizButtons();
  lockAllCyclingButtonWidths();

  window.addEventListener("resize", resize);
  resize();

  // Start centered
  state.panX = container.clientWidth / 2;
  state.panY = container.clientHeight / 2;

  // Auto-load map data if formation_map_data.js is present and sets window.FORMATION_MAP_DATA
  if (window.FORMATION_MAP_DATA && typeof window.FORMATION_MAP_DATA === "object") {
    loadSaveData(window.FORMATION_MAP_DATA);
  } else {
    updateCursor();
    draw();
  }

})();
</script>
</body>
</html>