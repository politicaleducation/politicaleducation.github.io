<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Neighborhood Map — Single-file (Dark)</title>
<style>
    /* Collapsible STREET sections */
    details#streetSetup, details#streetInfo{
      margin-top:12px;
      padding:10px;
      border:1px solid rgba(255,255,255,0.06);
      border-radius:10px;
      background:var(--glass);
    }
    details#streetInfo summary, details#streetSetup summary{
      list-style:none;
      cursor:pointer;
      font-weight:600;
      color:#e6eef3;
      margin:-4px 0 8px 0;
    }
    details#streetInfo summary::-webkit-details-marker,
    details#streetSetup summary::-webkit-details-marker{ display:none; }
    /* Tracing Image collapsible section styled like Street Info / Street Set Up */
    details#traceTools{
      margin-top:12px;
      padding:10px;
      border:1px solid rgba(255,255,255,0.06);
      border-radius:10px;
      background:var(--glass);
    }
    details#traceTools summary{
      list-style:none;
      cursor:pointer;
      font-weight:600;
      color:#e6eef3;
      margin:-4px 0 8px 0;
    }
    details#traceTools summary::-webkit-details-marker{ display:none; }


    /* Collapsible inspector sections */
    details#setup, details#fill{
      margin-top:12px;
      padding:10px;
      border:1px solid rgba(255,255,255,0.06);
      border-radius:10px;
      background:var(--glass);
    }
    details summary{
      list-style:none;
      cursor:pointer;
      font-weight:600;
      color:#e6eef3;
      margin:-4px 0 8px 0;
    }
    details summary::-webkit-details-marker{ display:none; }

    :root{
      --bg:#0b0f13;--panel:#0f1418;--muted:#9aa3ad;--accent:#6ee7b7;--card:#111418;--danger:#ff6b6b;
      --glass:rgba(255,255,255,0.03);
      font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;
      --stopAccent:#fbbf24;
}
    html,body{height:100%;background:linear-gradient(180deg,#051018 0%,var(--bg)100%);color:#e6eef3;margin:0;overflow:auto;scrollbar-width:none;-ms-overflow-style:none}
    html::-webkit-scrollbar,body::-webkit-scrollbar{display:none}
    .app{position:relative;display:block;min-height:100vh;padding:18px}
    header{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;padding:10px 0}
    h1{font-size:18px;margin:0;color:white}
    main{background:transparent;border-radius:0;padding:0;box-shadow:none}
    .map-wrap{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:8px;padding:12px}
    svg{width:100%;height:72vh;display:block;border-radius:6px;background:linear-gradient(180deg, rgba(0,0,0,0.18), rgba(255,255,255,0.02));cursor:grab;outline:none}
    svg.dragging{cursor:grabbing}
    .sidebar{background:var(--panel);border-radius:12px;padding:14px;height:calc(100vh - 88px);box-shadow:0 6px 20px rgba(0,0,0,0.6);overflow:auto}
    label{display:block;font-size:12px;color:var(--muted);margin-top:10px}
    input[type=text],input[type=color],select,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
    button{margin-top:12px;padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#052018;font-weight:600;cursor:pointer}
    .muted-btn{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px}
    .drag-on{background:var(--accent);color:#052018}
    .small{font-size:13px;color:var(--muted)}
    .building{cursor:pointer;transition:opacity .08s ease,transform .08s ease}
    .building:hover{opacity:0.96}
    .building.selected{stroke:var(--accent);stroke-width:3}
    .building.stop-highlight{stroke:var(--stopAccent);stroke-width:4;filter:drop-shadow(0 0 6px var(--stopAccent));fill:var(--stopFill);}
    .legend{display:flex;gap:8px;align-items:center;margin-top:8px}
    .chip{padding:6px 8px;border-radius:10px;background:var(--glass);font-size:12px;color:var(--muted)}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
     .layer-controls{display:flex;gap:6px;align-items:center;flex-wrap:wrap;margin-left:8px}
     .layer-controls span{font-size:12px;color:var(--muted);margin-right:4px}

    .node-handle{
    cursor:pointer;
    stroke:#020617;
    stroke-width:2px;
    filter:drop-shadow(0 0 3px rgba(0,0,0,0.8));
  }
    footer{grid-column:1/-1;padding-top:8px;color:var(--muted);font-size:13px}
    .rotate-control{display:flex;gap:8px;align-items:center;margin-left:8px}
    #controlsPanel .controls{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    #mapToolsGrid{
      display:grid;
      grid-template-columns:repeat(4,minmax(0,1fr));
      column-gap:2px;
      row-gap:0;
      width:100%;
      margin-top:2px;
    }
    #mapToolsGrid .tool-label{
      grid-column:1/-1;
      font-size:10px;
      text-transform:uppercase;
      letter-spacing:0.08em;
      color:var(--muted);
      margin-top:4px;
    }
    .tool-btn{
      margin:0 0 2px 0;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:4px 6px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.08);
      background:var(--glass);
      color:#e6eef3;
      font-size:11px;
      font-weight:500;
      min-height:26px;
      cursor:pointer;
      text-decoration:none;
      white-space:nowrap;
    }
    #mapToolsGrid .tool-btn:hover{
      background:rgba(255,255,255,0.12);
    }
    .tool-btn:disabled{
      opacity:0.45;
      cursor:not-allowed;
    }
    
/* Map tools search */
#mapSearchWrap{
  grid-column:1/-1;
  position:relative;
  margin:0 0 2px 0;
}
#mapSearchInput{
  width:100%;
  box-sizing:border-box;
  padding:4px 8px;
  border-radius:6px;
  border:1px solid rgba(255,255,255,0.08);
  background:var(--glass);
  color:#e6eef3;
  font-size:12px;
  min-height:26px;
  outline:none;
}
#mapSearchInput::placeholder{ color:rgba(154,163,173,0.9); }
#mapSearchInput:focus{
  border-color:rgba(255,255,255,0.18);
  background:rgba(255,255,255,0.08);
}
#mapSearchResults{
  position:absolute;
  top:30px;
  left:0;
  right:0;
  z-index:9999;
  background:rgba(15,20,24,0.98);
  border:1px solid rgba(255,255,255,0.10);
  border-radius:10px;
  box-shadow:0 10px 24px rgba(0,0,0,0.55);
  overflow:auto;
  max-height:260px;
  padding:4px;
}
.search-item{
  display:flex;
  flex-direction:column;
  gap:2px;
  padding:7px 8px;
  border-radius:8px;
  cursor:pointer;
  user-select:none;
}
.search-item:hover,.search-item.active{
  background:rgba(255,255,255,0.10);
}
.search-item .title{ font-size:12px; color:#e6eef3; }
.search-item .meta{ font-size:11px; color:var(--muted); }
.search-empty{ padding:8px; color:var(--muted); font-size:12px; }
#mapToolsGrid .tool-btn-file{
      background:rgba(56,189,248,0.12);
      border-color:rgba(56,189,248,0.55);
    }
    #mapToolsGrid .tool-btn-edit{
      background:rgba(52,211,153,0.14);
      border-color:rgba(52,211,153,0.55);
    }
    #mapToolsGrid .tool-btn-zoom{
      background:rgba(251,191,36,0.14);
      border-color:rgba(251,191,36,0.55);
    }
    #mapToolsGrid .tool-btn-layer{
      background:rgba(129,140,248,0.16);
      border-color:rgba(129,140,248,0.60);
    }
    #mapToolsGrid .tool-btn-orient{
      background:rgba(248,113,113,0.16);
      border-color:rgba(248,113,113,0.60);
    }
    #controlsPanel .header-left h1{
      font-size:14px;
    }


    /* Make inspector content scrollable within the resizable infoPanel */
    #inspector{
      flex:1;
      min-height:0;
      overflow-y:auto;
      padding:10px;

      /* Hide scrollbars but keep scrolling */
      scrollbar-width:none;          /* Firefox */
      -ms-overflow-style:none;       /* IE / Edge legacy */
    }
    #inspector::-webkit-scrollbar{   /* Chrome, Safari, Edge (Blink/WebKit) */
      display:none;
    }


    /* Mobile-only quick edit bar (selection label/info) is hidden on desktop */
    #quickEditBar{ display:none; }

@media (max-width: 900px){
  /* MOBILE LAYOUT: fullscreen map + TOP tools bar + BOTTOM quick-edit bar + overlay panes */

  /* Stop the page itself from scrolling while you pan/zoom the SVG */
  html, body { height: 100%; overflow: hidden; overscroll-behavior: none; }
  .app { padding: 0; min-height: 100vh; }

  /* Fullscreen map */
  #mapPanel{
    position: fixed !important;
    left: 0 !important;
    top: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    display: flex !important;
    flex-direction: column;
    border-radius: 0 !important;
    z-index: 10 !important;
  }
  #mapPanel .map-wrap{ padding: 0 !important; border-radius: 0 !important; }
  #mapPanel .map-wrap svg{
    height: 100% !important;
    border-radius: 0 !important;
  }

  /* TOP tools bar */
  #controlsPanel{
    position: fixed !important;
    left: 0 !important;
    right: 0 !important;
    top: 0 !important;
    bottom: auto !important;
    width: 100vw !important;
    display: flex !important;
    flex-direction: column;
    border-radius: 0 0 16px 16px !important;
    z-index: 40 !important;

    /* safe-area */
    padding-top: env(safe-area-inset-top);
  }
  /* Remove the "Map Tools" title bar + any resize chrome */
  #controlsPanel .window-drag-handle,
  #controlsPanel .window-resizer{ display: none !important; }

  /* Make the tools panel non-scrollable */
  #controlsPanel .controls-panel-body{
    overflow: hidden !important;
    padding: 8px 8px 10px !important;
    touch-action: manipulation;
  }

  /* Hide header bits you don't care about on mobile */
  #controlsPanel .header-left,
  #mapNameDisplay,
  #autosaveRow,
  #blockName{ display: none !important; }

  /* Map tools: compact 4-column grid */
  #mapToolsGrid{
    grid-template-columns: repeat(4, minmax(0,1fr)) !important;
    column-gap: 4px !important;
    row-gap: 4px !important;
    margin-top: 0 !important;
  }
  #pseudoFullscreenBtn{ display:none !important; }

  .tool-btn{
    min-height: 30px !important;
    font-size: 12px !important;
    padding: 6px 6px !important;
  }

  /* BOTTOM quick-edit bar (selection name + label/info) */
  #mobileInfoBar{
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 45;
    background: var(--panel);
    border-top: 1px solid rgba(255,255,255,0.09);
    box-shadow: 0 -10px 24px rgba(0,0,0,0.35);
    padding: 8px 8px calc(10px + env(safe-area-inset-bottom));

    /* Keep this panel from growing into the map; scroll internally instead */
    height: clamp(190px, 32vh, 420px);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
    touch-action: pan-y;

    /* Hide scrollbars but keep scrolling */
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  #mobileInfoBar::-webkit-scrollbar{ display:none; }
    /* Show quick edit bar on mobile */
  #quickEditBar{ display:block !important; }

#mobileInfoBar #quickEditBar{
    margin-top: 0 !important;
  }
  #mobileInfoBar #quickEditBar .quick-top{
    gap: 10px !important;
  }
  #mobileInfoBar #quickSelMeta{
    font-size: 12px !important;
  }
  #mobileInfoBar #quickNotesInput{
    max-height: 60px;
  }

  /* Disable window chrome that's annoying on touch (keep overlay headers for Close buttons) */
  #mapPanel .window-resizer,
  #mapPanel .window-drag-handle,
  #infoPanel .window-resizer,
  #analyticsPanel .window-resizer { display: none !important; }

  /* Fullscreen overlays (hidden until opened) */
  #infoPanel, #analyticsPanel{
    position: fixed !important;
    inset: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    border-radius: 0 !important;
    z-index: 60 !important;
    display: none !important;
  }
  body.mobile-pane-info #infoPanel{ display: flex !important; }
  body.mobile-pane-analytics #analyticsPanel{ display: flex !important; }

  /* Prevent iOS “zoom on focus” in forms */
  input, select, textarea { font-size: 16px; }

  /* Tell the browser we're handling touch gestures on the SVG */
  #mapSvg{
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
  }

  /* Make analytics list easier to tap */
  #analyticsPanel li{ padding: 10px 10px; }
}


    .header-left{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    .header-actions{display:flex;gap:8px}

    .ellipsis{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:60vw}
    .header-actions label.muted-btn{font-weight:600}
    .header-actions .muted-btn{margin-top:0;font-weight:600}
    .header-actions a.muted-btn{ text-decoration:none; display:inline-block; }
    .header-actions a.muted-btn:visited{ color:var(--muted); }

    #mapPanel, #infoPanel{
      position:absolute;
      box-shadow:0 14px 40px rgba(0,0,0,0.75);
      border-radius:12px;
      overflow:hidden;
      z-index:10;
      padding:0;
    }
    #controlsPanel{
      position:absolute;
      top:24px;
      left:24px;
      width:380px;
      min-height:100px;
      display:flex;
      flex-direction:column;
      background:var(--panel);
      border-radius:12px;
      box-shadow:0 14px 40px rgba(0,0,0,0.75);
      overflow:hidden;
      z-index:12;
    }
    #controlsPanel .controls-panel-body{
      padding:10px 12px 12px 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    /* Pseudo fullscreen (desktop): hide Inspector + Lines & Routes */
    @media (min-width: 901px){
      body.pseudo-fullscreen #infoPanel,
      body.pseudo-fullscreen #analyticsPanel{
        display:none !important;
      }
      body.pseudo-fullscreen #mapPanel{
        position:fixed !important;
        top:0 !important;
        left:0 !important;
        width:100vw !important;
        height:100vh !important;
        border-radius:0 !important;
        /* Keep Map Tools clickable above the map (controlsPanel is z-index:12 by default). */
        z-index: 10 !important;
      }
    }

    /* Quick edit bar (always visible while scrolling Map Tools) */
    #quickEditBar{
      position: sticky;
      top: 0;
      z-index: 5;
      background: rgba(15,15,18,0.88);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      padding: 8px;
      backdrop-filter: blur(8px);
    }
    #quickEditBar .quick-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom:6px;
    }
    #quickSelMeta{
      font-size:12px;
      opacity:0.85;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    #quickEditBar .quick-input{
      padding: 8px;
      border-radius: 10px;
      font-size: 16px; /* avoid iOS zoom-on-focus */
    }
    #quickEditBar .quick-textarea{
      padding: 8px;
      border-radius: 10px;
      font-size: 16px; /* avoid iOS zoom-on-focus */
      resize: vertical;
      min-height: 60px;
    }
    #quickEditBar .quick-input:disabled,
    #quickEditBar .quick-textarea:disabled{
      opacity:0.55;
    }


    #quickEditBar .quick-top-actions{
      display:flex;
      gap:8px;
      align-items:center;
    }
    #quickEditBar .quick-grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 6px;
      margin-top: 6px;
    }
    #quickEditBar .quick-field{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    #quickEditBar .quick-label{
      font-size:11px;
      opacity:0.8;
      margin-top: 4px;
    }
    #quickEditBar .quick-span-2{
      grid-column: 1 / -1;
    }
    #quickEditBar select{
      padding: 8px;
      border-radius: 10px;
      font-size: 16px; /* avoid iOS zoom-on-focus */
    }
    #quickColorInput{
      height: 38px;
      padding: 0;
      border: none;
      background: transparent;
    }
    /* Hide UI the user doesn’t want */
    #mapNameDisplay,
    #autosaveRow,
    #blockName,

    .rotate-btn{
      display:none !important;
    }
    #controlsPanel .header-left{
      margin-bottom:2px;
    }
    #controlsPanel .controls{
      margin-top:4px;
    }
    #controlsPanel .legend{
      margin-top:6px;
    }
    #mapPanel{
      top:90px;
      left:24px;
      width:min(60vw, 960px);
      height:calc(100vh - 150px);
      display:flex;
      flex-direction:column;
    }
    #infoPanel{
      top:100px;
      right:24px;
      width:360px;
      height:calc(100vh - 170px);
      display:flex;
      flex-direction:column;
      padding:0;
    }
    #mapPanel .map-wrap{
      flex:1;
      display:flex;
      flex-direction:column;
    }
    #mapPanel .map-wrap svg{
      flex:1;
      height:auto;
    }
    .window-drag-handle{
      height:20px;
      padding:0 10px;
      font-size:12px;
      background:rgba(0,0,0,0.45);
      border-bottom:1px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      cursor:move;
    }
    /* Normalize window headers: make all four handles match Map Tools */
    #mapPanel > .window-drag-handle,
    #infoPanel > .window-drag-handle,
    #analyticsPanel > .window-drag-handle,
    #controlsPanel > .window-drag-handle{
      height:20px;
      padding:0 10px;
      font-size:12px;
      background:rgba(0,0,0,0.45);
      border-bottom:1px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      cursor:move;
      box-sizing:border-box;
    }
    /* unified handle: infoPanel uses global/window-header rule below */

    .window-resizer{
      position:absolute;
      width:12px;
      height:12px;
      right:4px;
      bottom:4px;
      cursor:se-resize;
      background:rgba(255,255,255,0.2);
      border-radius:3px;
    }

    #analyticsPanel{
      position:absolute;
      top:100px;
      left:calc(50% - 180px);
      width:320px;
      height:calc(100vh - 170px);
      display:flex;
      flex-direction:column;
      background:var(--panel);
      border-radius:12px;
      box-shadow:0 14px 40px rgba(0,0,0,0.75);
      overflow:hidden;
      z-index:11;
      padding:0;
    }
    /* unified handle: analyticsPanel uses global/window-header rule below */
    #analyticsPanel .analytics-body{
      flex:1;
      padding:10px;
      overflow:auto;
      font-size:12px;
      scrollbar-width:none; /* Firefox */
    }
    #analyticsPanel .analytics-body::-webkit-scrollbar{
      width:0;
      height:0;
    }
    #analyticsPanel .group-header{
      margin:8px 0 4px;
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:0.06em;
      color:var(--muted);
    }
    #analyticsPanel ul{
      list-style:none;
      margin:0;
      padding:0;
    }
    #analyticsPanel li{
      padding:4px 6px;
      border-radius:6px;
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:6px;
    }
    #analyticsPanel li:hover{
      background:rgba(255,255,255,0.04);
    }
    #analyticsPanel li.active{
      background:rgba(110,231,183,0.18);
      color:#e6eef3;
    }
    #analyticsPanel .pill{
      font-size:10px;
      padding:2px 6px;
      border-radius:999px;
      background:rgba(255,255,255,0.06);
      color:var(--muted);
      white-space:nowrap;
    }
    /*
      Street highlight: glow using the street's own stroke color (set via --glowColor on the element).
      We "turn it up" by stacking multiple drop-shadows.
      For darker/grey streets we also brighten the glow (same hue, higher value) via color-mix().
    */
    .street.highlighted{
      --glowBase: var(--glowColor, var(--accent));
      --glowBright: var(--glowBase);
      filter:
        drop-shadow(0 0 1px var(--glowBase))
        drop-shadow(0 0 4px var(--glowBright))
        drop-shadow(0 0 10px var(--glowBright))
        drop-shadow(0 0 18px var(--glowBright))
        drop-shadow(0 0 28px var(--glowBright));
    }

    .street.stop-related{
      --glowBase: var(--glowColor, var(--accent));
      --glowBright: var(--glowBase);
      filter:
        drop-shadow(0 0 1px var(--glowBase))
        drop-shadow(0 0 4px var(--glowBright))
        drop-shadow(0 0 10px var(--glowBright))
        drop-shadow(0 0 18px var(--glowBright))
        drop-shadow(0 0 28px var(--glowBright));
    }

    text.stop-related{
      --glowBase: var(--glowColor, var(--accent));
      --glowBright: var(--glowBase);
      opacity:0.9;
      filter:
        drop-shadow(0 0 3px rgba(0,0,0,0.65))
        drop-shadow(0 0 4px var(--glowBright))
        drop-shadow(0 0 10px var(--glowBright));
    }
    @supports (color: color-mix(in srgb, red 50%, white)){
      .street.highlighted{
        --glowBright: color-mix(in srgb, var(--glowBase) 45%, white);
      }
    }
    text.highlighted{
      --glowBase: var(--glowColor, var(--accent));
      --glowBright: var(--glowBase);
      opacity:0.9;
      filter:
        drop-shadow(0 0 3px rgba(0,0,0,0.65))
        drop-shadow(0 0 4px var(--glowBright))
        drop-shadow(0 0 10px var(--glowBright));
    }
    @supports (color: color-mix(in srgb, red 50%, white)){
      text.highlighted{
        --glowBright: color-mix(in srgb, var(--glowBase) 45%, white);
      }
    }
    text.highlighted textPath{
      fill:var(--glowBright, var(--glowColor, var(--accent))) !important;
    }
    /* Selection (street) highlight: stronger glow */
    .street.selected-street{
      --glowBase: var(--glowColor, var(--accent));
      --glowBright: var(--glowBase);
      filter:
        drop-shadow(0 0 2px var(--glowBase))
        drop-shadow(0 0 6px var(--glowBright))
        drop-shadow(0 0 14px var(--glowBright))
        drop-shadow(0 0 24px var(--glowBright))
        drop-shadow(0 0 36px var(--glowBright));
    }
    @supports (color: color-mix(in srgb, red 50%, white)){
      .street.selected-street{
        --glowBright: color-mix(in srgb, var(--glowBase) 35%, white);
      }
    }
    text.selected-street{
      --glowBase: var(--glowColor, var(--accent));
      --glowBright: var(--glowBase);
      opacity:0.95;
      filter:
        drop-shadow(0 0 3px rgba(0,0,0,0.65))
        drop-shadow(0 0 6px var(--glowBright))
        drop-shadow(0 0 14px var(--glowBright));
    }
    @supports (color: color-mix(in srgb, red 50%, white)){
      text.selected-street{
        --glowBright: color-mix(in srgb, var(--glowBase) 35%, white);
      }
    }
    text.selected-street textPath{
      fill:var(--glowBright, var(--glowColor, rgba(255,255,255,0.95))) !important;
    }

    /* --- Simplified highlight (performance) ---
       The prior glow stacked multiple drop-shadows per element. That looks great but can get heavy
       when many segments/labels are highlighted. This version keeps the highlight obvious using:
         - a modest stroke-width bump (via per-path --sw)
         - a single drop-shadow (no stacking)
    */
    .street.highlighted,
    .street.stop-related{
      --glowBase: var(--glowColor, var(--accent));
      --glowBright: var(--glowBase);
      stroke: var(--glowBright) !important;
      filter: drop-shadow(0 0 8px var(--glowBright));
    }
    .street.highlighted{ stroke-width: calc(var(--sw, 50px) + 6px) !important; }
    .street.stop-related{ stroke-width: calc(var(--sw, 50px) + 5px) !important; }

    .street.selected-street{
      --glowBase: var(--glowColor, var(--accent));
      --glowBright: var(--glowBase);
      stroke: var(--glowBright) !important;
      stroke-width: calc(var(--sw, 50px) + 8px) !important;
      filter: drop-shadow(0 0 10px var(--glowBright));
    }

    text.highlighted,
    text.stop-related,
    text.selected-street{
      --glowBase: var(--glowColor, var(--accent));
      --glowBright: var(--glowBase);
      opacity:0.92;
      filter:
        drop-shadow(0 0 2px rgba(0,0,0,0.65))
        drop-shadow(0 0 8px var(--glowBright));
    }
    text.highlighted textPath,
    text.stop-related textPath,
    text.selected-street textPath{
      fill: var(--glowBright, var(--glowColor, var(--accent))) !important;
    }

    @supports (color: color-mix(in srgb, red 50%, white)){
      .street.highlighted,
      .street.stop-related{
        --glowBright: color-mix(in srgb, var(--glowBase) 45%, white);
      }
      .street.selected-street{
        --glowBright: color-mix(in srgb, var(--glowBase) 35%, white);
      }
      text.highlighted,
      text.stop-related{
        --glowBright: color-mix(in srgb, var(--glowBase) 45%, white);
      }
      text.selected-street{
        --glowBright: color-mix(in srgb, var(--glowBase) 35%, white);
      }
    }

</style>
</head>
<body>
<div class="app">

<main>
  <div id="mapPanel">
    <div class="window-drag-handle" data-window="mapPanel"></div>
    <div class="map-wrap">
      <svg aria-label="Neighborhood map" id="mapSvg" preserveaspectratio="xMidYMid meet" tabindex="0" viewbox="0 0 1000 700"></svg>
    </div>
    <div class="window-resizer" data-window="mapPanel"></div>
  </div>
</main>


<div id="controlsPanel">
  <div class="window-drag-handle" data-window="controlsPanel">
    <span>Map Tools</span>
  </div>
  <div class="controls-panel-body">
    <div class="header-left">
      <h1 id="mapNameDisplay" class="ellipsis">SICA Map</h1>
      <div id="autosaveRow" style="display:flex;align-items:center;gap:4px;margin-top:0px;flex-wrap:wrap">
        <span id="autosaveIndicator" style="font-size:12px;opacity:0.85">Last saved: —</span>
        <button class="tool-btn tool-btn-file" id="restoreAutosaveBtn" style="display:none;padding:6px 10px">Restore autosave</button>
        <button class="tool-btn tool-btn-file" id="cancelAutosaveBtn" style="display:none;padding:6px 10px">Cancel</button>
      </div>
      <div id="quickEditBar">
  <div class="quick-top">
    <span id="quickSelMeta">No selection</span>
    <div class="quick-top-actions">
      <button class="tool-btn muted-btn" id="quickRoutesBtn" type="button">Routes</button>
      <button class="tool-btn muted-btn" id="quickApplyBtn" type="button" disabled>Apply</button>
    </div>
  </div>

  <div class="quick-grid">
    <div class="quick-field quick-span-2">
      <label class="quick-label">Object name</label>
      <input id="quickNameInput" class="quick-input" type="text" placeholder="Object name" disabled />
    </div>

    <div class="quick-field quick-span-2">
      <label class="quick-label">Info / notes</label>
      <textarea id="quickNotesInput" class="quick-textarea" rows="2" placeholder="Info / notes" disabled></textarea>
    </div>
  </div>

  <div id="quickBuildingInfo" style="display:none">
    <div class="quick-grid">
      <div class="quick-field">
        <label class="quick-label">Type</label>
        <select id="quickTypeInput" disabled>
          <option value="residential">Residential</option>
          <option value="commercial">Commercial</option>
          <option value="civic">Civic</option>
          <option value="vacant">Vacant</option>
          <option value="other">Other</option>
          <option value="public_transport">Public Transport</option>
        </select>
      </div>

      <div class="quick-field">
        <label class="quick-label">Usage</label>
        <select id="quickUsageInput" disabled>
          <option value="high">High</option>
          <option value="medium">Medium</option>
          <option value="low">Low</option>
          <option value="none">None</option>
        </select>
      </div>

      <div class="quick-field">
        <label class="quick-label">Funding</label>
        <select id="quickFundingInput" disabled>
          <option value="high">High</option>
          <option value="medium">Medium</option>
          <option value="low">Low</option>
          <option value="none">None</option>
        </select>
      </div>

      <div class="quick-field quick-span-2">
        <label class="quick-label">Occupants</label>
        <textarea id="quickOccupantsInput" class="quick-textarea" rows="2" placeholder="Occupants" disabled></textarea>
      </div>
    </div>
  </div>

  <div id="quickSetupInputs" style="display:none">
    <div class="quick-grid">
      <div class="quick-field">
        <label class="quick-label">Color</label>
        <input id="quickColorInput" type="color" disabled />
      </div>

      <div class="quick-field">
        <label class="quick-label">Length</label>
        <input id="quickLengthInput" class="quick-input" type="text" inputmode="decimal" disabled />
      </div>

      <div class="quick-field">
        <label class="quick-label">Width</label>
        <input id="quickWidthInput" class="quick-input" type="text" inputmode="decimal" disabled />
      </div>

      <div class="quick-field">
        <label class="quick-label">Angle (°)</label>
        <input id="quickAngleInput" class="quick-input" type="text" inputmode="decimal" disabled />
      </div>
    </div>
  </div>
</div>
    </div>
    <div class="controls">
      <span id="blockName" style="display:none"></span>
      <div id="mapToolsGrid">

<div id="mapSearchWrap">
  <input id="mapSearchInput" type="text" placeholder="Search (e.g., groceries, bus, station)" autocomplete="off" />
  <div id="mapSearchResults" style="display:none"></div>
</div>
        <button class="tool-btn tool-btn-file" id="loadBtn">Load</button>
        <button class="tool-btn tool-btn-file" id="downloadBtn">Save</button>
        <button class="tool-btn tool-btn-file" id="undoBtn" title="Undo (Ctrl/Cmd+Z)" disabled>Undo</button>
        <button class="tool-btn tool-btn-file" id="redoBtn" title="Redo (Ctrl/Cmd+Y or Ctrl/Cmd+Shift+Z)" disabled>Redo</button>

        <button class="tool-btn tool-btn-zoom" id="mapTraceBtn" title="Show tracing image" aria-pressed="false">Map</button>
        <button class="tool-btn tool-btn-zoom" id="pseudoFullscreenBtn" title="Focus mode (hide Inspector + Lines & Routes)" aria-pressed="false">Full</button>
        <button class="tool-btn tool-btn-zoom" id="zoomInBtn">+</button>
        <button class="tool-btn tool-btn-zoom" id="zoomOutBtn">−</button>

        <button class="tool-btn tool-btn-edit" id="addBuildingBtn" style="grid-column: span 2;">+ building</button>
        <button class="tool-btn tool-btn-edit" id="addStreetBtn" style="grid-column: span 2;">+ street</button>

        <button class="tool-btn tool-btn-layer layer-toggle" data-layer="streets">Streets</button>
        <button class="tool-btn tool-btn-layer layer-toggle" data-layer="bike">Bike</button>
        <button class="tool-btn tool-btn-layer layer-toggle" data-layer="rail">Rail</button>
        <button class="tool-btn tool-btn-layer layer-toggle" data-layer="bus">Bus</button>
        <input accept=".js,.json" id="fileInput" style="display:none" type="file"/>
      </div>
    </div>
  </div>
<div class="window-resizer" data-window="controlsPanel"></div>
</div>

<aside class="sidebar" id="infoPanel">
  <div class="window-drag-handle" data-window="infoPanel"></div>
<div id="inspector">
<div id="noSelection" style="margin-top:6px">No object selected.</div>
<div id="form" style="display:none;margin-top:8px">
<h3 id="inspectorTitle" style="margin:6px 0">Inspector</h3>

<!-- BUILDINGS: Top actions row -->
<div class="inspector-actions" style="display:flex;gap:0px;flex-wrap:wrap;align-items:center;margin:0px 0">
  <button class="tool-btn muted-btn" id="toggleDragBtn">Drag: Off</button>
  <button class="tool-btn" id="saveBtn">Save</button>
  <button class="tool-btn muted-btn" id="copyBuildingBtn">Copy</button>
  <button class="tool-btn muted-btn" id="pasteBuildingBtn">Paste</button>
  <button class="tool-btn" id="deleteBtn" style="background:var(--danger);color:white">Delete</button>
</div>

<details id="setup">
<summary>Building Set Up</summary>
<label for="bColor">Color</label>
<input id="bColor" type="color"/>
<label for="bAlign">Label position</label>
<select id="bAlign">
<option value="top">Top</option>
<option value="bottom">Bottom</option>
</select>
<label for="bOrient">Label orientation</label>
<select id="bOrient">
<option value="horizontal">Horizontal</option>
<option value="vertical">Vertical (90°)</option>
</select>
<label class="small">Geometry (x, y, Length, Width)</label>
<div style="display:flex;gap:6px">
<input id="bX" type="text"/>
<input id="bY" type="text"/>
<input id="bW" type="text"/>
<input id="bH" type="text"/>
</div>
<label class="small">Angle (°)</label>
<input id="bAngle" type="text"/>
    <label class="small">Shape</label>
    <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:6px">
      <button class="tool-btn muted-btn" id="bShapeRectBtn" type="button">Rectangle</button>
      <button class="tool-btn muted-btn" id="bShapePolyBtn" type="button">Polygon</button>
      <button class="tool-btn muted-btn" id="bPolyAddBtn" type="button">+ point</button>
      <button class="tool-btn muted-btn" id="bPolyDelBtn" type="button">− point</button>
    </div>
    <div class="small" style="margin-top:6px">Tip: switch to <b>Polygon</b>, then drag the white points on the map.</div>

</details>
<details id="fill">
<summary>Building Info</summary>
<label for="bLabel">Label</label>
<input id="bLabel" type="text"/>
<label for="bType">Type</label>
<select id="bType">
<option value="residential">Residential</option>
<option value="commercial">Commercial</option>
<option value="civic">Civic</option>
<option value="vacant">Vacant</option>
<option value="other">Other</option>
<option value="public_transport">Public Transport</option>
</select>
<label for="bUsage">Usage</label>
<select id="bUsage">
<option value="high">High</option>
<option value="medium">Medium</option>
<option value="low">Low</option>
<option value="none">None</option>
</select>
<label for="bFunding">Funding</label>
<select id="bFunding">
<option value="high">High</option>
<option value="medium">Medium</option>
<option value="low">Low</option>
<option value="none">None</option>
</select>
<label for="bOcc">Occupants</label>
<textarea id="bOcc" rows="4"></textarea>
<label for="bNotes">Notes</label>
<textarea id="bNotes" rows="3"></textarea>

<div id="ptLineOverrides" style="display:none;margin-top:10px">
  <div class="small" style="opacity:0.85;margin:2px 0 6px 0">Public transport line overrides</div>

  <label for="bIncludeLines" class="small">Include lines (comma or newline separated)</label>
  <textarea id="bIncludeLines" rows="2" placeholder="Broad St. Line, Norristown Line"></textarea>

  <label for="bExcludeLines" class="small" style="margin-top:6px">Exclude lines (comma or newline separated)</label>
  <textarea id="bExcludeLines" rows="2" placeholder="(optional)"></textarea>
</div>

</details>
</div>

<details id="traceTools" class="section">
  <summary>Tracing Image</summary>

  <label class="small" style="margin-top:8px">Load background image (real map)</label>
  <input type="file" id="traceImageInput" accept="image/png,image/jpeg,image/webp"/>

  <label class="small" style="margin-top:8px">Rotation (deg)</label>
  <div style="display:flex;gap:6px;align-items:center">
    <input type="range" id="traceRotationInput" min="-180" max="180" step="1" value="0" style="flex:1"/>
    <input type="number" id="traceRotationInputBox" min="-180" max="180" step="0.1" style="width:70px"/>
  </div>

  <label class="small" style="margin-top:8px">Offset X (ft)</label>
  <input type="number" id="traceOffsetX" step="10"/>

  <label class="small" style="margin-top:4px">Offset Y (ft)</label>
  <input type="number" id="traceOffsetY" step="10"/>

  <label class="small" style="margin-top:4px">Scale</label>
  <div style="display:flex;gap:6px;align-items:center">
    <input type="range" id="traceScaleInput" min="0.1" max="10" step="0.05" value="1" style="flex:1"/>
    <input type="number" id="traceScaleInputBox" min="0.1" max="10" step="0.05" style="width:70px"/>
  </div>

  <button class="muted-btn" id="traceToggleBtn" style="margin-top:8px">Hide tracing image</button>
  <button class="muted-btn" id="traceDragBtn" style="margin-top:4px">Drag image: Off</button>
</details>
</div>
<div class="window-resizer" data-window="infoPanel"></div>
</aside>

<aside class="sidebar" id="analyticsPanel">
  <div class="window-drag-handle" data-window="analyticsPanel">
    <span>Lines &amp; Routes</span>
  </div>
  <div class="analytics-body">
    <div id="analyticsEmpty" class="small">No streets or routes loaded.</div>
    <div id="analyticsContent" style="display:none">
      <div class="group-header" style="margin-top:10px">Rail (Subway &amp; Regional)</div>
      <ul id="analyticsRailList"></ul>
      <div class="group-header" style="margin-top:10px">Bus lines</div>
      <ul id="analyticsBusList"></ul>
      <div class="group-header" style="margin-top:10px">Bike lanes</div>
      <ul id="analyticsBikeList"></ul>
      <div class="group-header" style="margin-top:10px">Rivers &amp; Waterways</div>
      <ul id="analyticsWaterList"></ul>
      <div class="group-header">Streets</div>
      <ul id="analyticsStreetList"></ul>
    </div>
  </div>
  <div class="window-resizer" data-window="analyticsPanel"></div>
</aside>

<script src="BrooklynMap.js" onerror="window.__AUTOLOAD_PHILLY_FAILED=true;"></script>
<script>
(function(){
  const svg = document.getElementById('mapSvg');

  // Shared helper for simple 90°/180° rotation-aware navigation
  function adjustForRotation(dx, dy) {
    if (worldAngle === 90) return [dy, -dx];
    if (worldAngle === -90) return [-dy, dx];
    if (worldAngle === 180 || worldAngle === -180) return [-dx, -dy];
    return [dx, dy];
  }

  const blockNameEl = document.getElementById('blockName');
  const noSelection = document.getElementById('noSelection');
  const form = document.getElementById('form');
  const inspector = document.getElementById('inspector');
  const toggleDragBtn = document.getElementById('toggleDragBtn');
  const mapSearchInput = document.getElementById('mapSearchInput');
  const mapSearchResults = document.getElementById('mapSearchResults');


  const mapNameDisplayEl = document.getElementById('mapNameDisplay');
  const autosaveIndicatorEl = document.getElementById('autosaveIndicator');
  const restoreAutosaveBtn = document.getElementById('restoreAutosaveBtn');
  const cancelAutosaveBtn = document.getElementById('cancelAutosaveBtn');

  // Map file metadata (optional; included when you Save -> data.js)
  if (typeof window.MAP_META !== 'object' || !window.MAP_META) window.MAP_META = {};
  let currentFileSavedAt = Number((window.MAP_META && window.MAP_META.savedAt) || 0) || 0;



  const traceInput = document.getElementById('traceImageInput');
  const traceRotationInput = document.getElementById('traceRotationInput');
  const traceRotationInputBox = document.getElementById('traceRotationInputBox');
  const traceToggleBtn = document.getElementById('traceToggleBtn');
  const mapTraceBtn = document.getElementById('mapTraceBtn');
  const traceOffsetXInput = document.getElementById('traceOffsetX');
  const traceOffsetYInput = document.getElementById('traceOffsetY');
  const traceScaleInput = document.getElementById('traceScaleInput');
  const traceScaleInputBox = document.getElementById('traceScaleInputBox');
  const traceDragBtn = document.getElementById('traceDragBtn');
  let selectedId = null;
  let selectedType = null;
  let selectedIds = new Set();  // multi-selection of buildings
  let clipboard = null;  // for copy/paste of buildings & streets
  let drag = null;           // building drag
  let nodeDrag = null;       // street node drag
  let polyPointDrag = null;  // building polygon point drag
  let activeStreetId = null;

  // buildings that should be visually highlighted as transit stops on the active line
  let stopHighlightIds = new Set();
  let stopHighlightColorById = new Map();
  let highlightedStreetIdsForStops = [];
  let stopRelatedStreetIds = []; // streets associated with the currently selected transit stop (building)
 // street segments currently highlighted as a line/route (used to highlight stops)


  // remembers which end of a street you last extended (start vs end), so Delete node removes the last-added end
  const streetNodeLastSide = Object.create(null);

  // translate mode vars
  let streetTranslateMode = false;
  let streetTranslateDrag = null;

  // remember street details open state across re-renders
  let lastStreetInfoOpen = false;
  let lastStreetSetupOpen = false;

  // dragging is OFF by default
  let dragEnabled = false;

  // Tracing image state
  let traceImageUrl = null;
  let traceImageName = ''; // filename for per-image tracing presets
  let traceImageVisible = false;
  let traceImageX = 0;
  let traceImageY = 0;
  let traceImageBaseWidth = 0;
  let traceImageBaseHeight = 0;
  let traceImageScale = 1;
  let traceImageAngle = 0;
  const traceImageOpacity = 1;
  let traceDragMode = false;
  let traceDrag = null;


  // --- Tracing image performance helpers (LOD / object URLs) ---
  // Reality check: large JPGs decode into raw RGBA pixels (often hundreds of MB).
  // File size (e.g., 23MB) is not what crashes mobile; decoded pixel dimensions are.
  // We avoid decoding full-res on mobile by default and instead render a downsampled proxy,
  // swapping resolution based on zoom ("level of detail"). This keeps detail where it matters.

  let traceOriginalUrl = null;      // the "true" source (filename URL or blob URL)
  let traceOriginalFile = null;     // File object when loaded via picker (best for safe downsample decode)
  let traceOriginalIsObjectUrl = false;

  // Active (currently-rendered) raster source for the SVG <image>
  let traceLodUrl = null;
  let traceLodKey = null;           // numeric max-dimension (e.g., 2048) or "full"
  const traceLodCache = new Map();  // key -> { url, w, h }
  const traceLodInFlight = new Map();
  const traceLodObjectUrls = new Set();

  // Persistent SVG image element (so we can swap href without re-rendering everything)
  let traceImageEl = null;

  // Persistent SVG layers (avoid rebuilding the entire SVG tree)
  let __layersBuilt = false;
  let worldG = null, traceG = null, streetsG = null, buildingsG = null, handlesG = null;

  // LOD scheduling
  let __traceLodRaf = 0;
  let __traceRawTargetPx = 0;

  function isLikelyMobile(){
    try {
      if (window.matchMedia && window.matchMedia('(pointer:coarse)').matches) return true;
    } catch(_) {}
    const ua = (navigator && navigator.userAgent) ? navigator.userAgent : '';
    return /Mobi|Android|iPhone|iPad|iPod/i.test(ua);
  }

  // Conservative caps (can be changed if you really want to risk mobile crashes)
  const TRACE_MAXDIM_MOBILE = 4096;  // phones often struggle beyond this as a single bitmap
  const TRACE_MAXDIM_DESKTOP = 8192; // good balance; "full" is still available on desktop

  function revokeTraceObjectUrls(){
    for (const u of traceLodObjectUrls) {
      try { URL.revokeObjectURL(u); } catch(_) {}
    }
    traceLodObjectUrls.clear();
  }

  function clearTraceLod(){
    traceLodCache.clear();
    traceLodInFlight.clear();
    revokeTraceObjectUrls();
    traceLodUrl = null;
    traceLodKey = null;
  }

  function ensureSvgLayers(){
    if (__layersBuilt) return;

    // Build a stable SVG structure so renderAll doesn't recreate the tracing image node repeatedly.
    svg.innerHTML = '';
    worldG = document.createElementNS(NS, 'g');
    worldG.id = 'world';

    traceG = document.createElementNS(NS, 'g');
    traceG.id = 'traceLayerGroup';

    streetsG = document.createElementNS(NS, 'g');
    streetsG.id = 'streetsLayerGroup';

    buildingsG = document.createElementNS(NS, 'g');
    buildingsG.id = 'buildingsLayerGroup';

    handlesG = document.createElementNS(NS, 'g');
    handlesG.id = 'handlesLayerGroup';

    // Ordering: tracing image behind everything
    worldG.appendChild(traceG);
    worldG.appendChild(streetsG);
    worldG.appendChild(buildingsG);
    worldG.appendChild(handlesG);

    svg.appendChild(worldG);

    // Create a persistent <image> node (we'll show/hide and swap href as needed)
    traceImageEl = document.createElementNS(NS, 'image');
    traceImageEl.setAttribute('id', 'traceImageLayer');
    traceImageEl.setAttribute('opacity', traceImageOpacity); // always 100%
    traceImageEl.setAttribute('pointer-events', 'none');
    traceG.appendChild(traceImageEl);

    __layersBuilt = true;
  }

  function updateTraceImageElement(){
    if (!traceImageEl) return;

    // Hide if not active
    if (!(traceImageVisible && (traceImageUrl || traceLodUrl || (traceOriginalFile ? null : traceOriginalUrl)))) {
      traceImageEl.style.display = 'none';
      return;
    }

    // If the source came from a File picker, we intentionally avoid rendering the full-res original until a proxy is ready.
    // For URL-based sources (e.g. BrooklynMap.jpg), we can fall back to the URL.
    const href = traceImageUrl || traceLodUrl || (traceOriginalFile ? null : traceOriginalUrl);
    if (!href) {
      traceImageEl.style.display = 'none';
      return;
    }

    traceImageEl.style.display = '';
    const w = traceImageBaseWidth * traceImageScale || 0;
    const h = traceImageBaseHeight * traceImageScale || 0;

    traceImageEl.setAttribute('x', traceImageX);
    traceImageEl.setAttribute('y', traceImageY);
    if (w > 0) traceImageEl.setAttribute('width', w);
    if (h > 0) traceImageEl.setAttribute('height', h);

    if (w > 0 && h > 0) {
      const cx = traceImageX + w / 2;
      const cy = traceImageY + h / 2;
      traceImageEl.setAttribute('transform', 'rotate(' + traceImageAngle + ' ' + cx + ' ' + cy + ')');
    } else {
      traceImageEl.removeAttribute('transform');
    }

    traceImageEl.setAttribute('pointer-events', traceDragMode ? 'visiblePainted' : 'none');
    traceImageEl.setAttributeNS('http://www.w3.org/1999/xlink', 'href', href);
  }

  function nextPow2(n){
    let p = 1;
    while (p < n) p <<= 1;
    return p;
  }

  function getTraceDesiredMaxDim(){
    // Choose a raster resolution based on how big the tracing image is on-screen.
    // We aim for ~2x screen resolution (oversampling) to keep it crisp.
    const vb = svg.viewBox.baseVal;
    const rect = svg.getBoundingClientRect();
    const screenW = rect && rect.width ? rect.width : (svg.clientWidth || 1);
    const screenH = rect && rect.height ? rect.height : (svg.clientHeight || 1);

    const pxPerWorldX = screenW / (vb.width || 1);
    const pxPerWorldY = screenH / (vb.height || 1);

    const wWorld = (traceImageBaseWidth * traceImageScale) || vb.width || 1;
    const hWorld = (traceImageBaseHeight * traceImageScale) || vb.height || 1;

    const wScreen = Math.max(1, wWorld * pxPerWorldX);
    const hScreen = Math.max(1, hWorld * pxPerWorldY);

    const target = Math.max(wScreen, hScreen) * 2; // oversample
    __traceRawTargetPx = target;
    const cap = isLikelyMobile() ? TRACE_MAXDIM_MOBILE : TRACE_MAXDIM_DESKTOP;

    // Snap to power-of-two-ish levels for caching.
    const desired = Math.min(cap, Math.max(512, nextPow2(Math.ceil(target))));
    return desired;
  }

  function chooseTraceLodKey(){
    // If we only have a filename URL (autoload) and we're on mobile, decoding full-res can crash.
    // We still allow it if the user explicitly loads via the file picker (traceOriginalFile),
    // because then we can safely decode downsampled proxies without touching full-res.
    const desired = getTraceDesiredMaxDim();
    const cap = isLikelyMobile() ? TRACE_MAXDIM_MOBILE : TRACE_MAXDIM_DESKTOP;

    // On desktop: allow "full" if you zoom far enough (beyond our desktop cap).
    // On mobile: never auto-switch to full; it's a common crash vector.
    const allowFull = !isLikelyMobile();

    if (allowFull && desired >= cap && (cap >= TRACE_MAXDIM_DESKTOP)) {
      // Still keep within cap unless we truly need full; we'll only use full if the desired is at cap and the user is zooming in.
      // We'll decide in updateTraceLODNow based on current key.
    }

    return desired;
  }


  async function getImageDimsFromBlobOrFile(blobOrFile){
    try {
      const type = (blobOrFile && blobOrFile.type) ? String(blobOrFile.type).toLowerCase() : '';
      // Read only a small header region
      const head = await blobOrFile.slice(0, 512 * 1024).arrayBuffer();
      const view = new DataView(head);

      // PNG: 8-byte signature + IHDR chunk
      // Width/Height are big-endian uint32 at offsets 16 and 20.
      const isPng = view.byteLength >= 24 &&
        view.getUint8(0) === 0x89 && view.getUint8(1) === 0x50 && view.getUint8(2) === 0x4E && view.getUint8(3) === 0x47;
      if (isPng) {
        const w = view.getUint32(16, false);
        const h = view.getUint32(20, false);
        if (w > 0 && h > 0) return { w, h };
      }

      // JPEG: parse SOF markers to read dimensions without full decode.
      const isJpeg = view.byteLength >= 4 &&
        view.getUint8(0) === 0xFF && view.getUint8(1) === 0xD8;
      if (isJpeg) {
        let offset = 2;
        const len = view.byteLength;
        while (offset + 3 < len) {
          // Find marker 0xFF
          if (view.getUint8(offset) !== 0xFF) { offset++; continue; }
          let marker = view.getUint8(offset + 1);
          offset += 2;

          // Skip padding FFs
          while (marker === 0xFF && offset < len) marker = view.getUint8(offset++);

          // Start of Scan or End of Image: stop
          if (marker === 0xDA || marker === 0xD9) break;

          if (offset + 1 >= len) break;
          const segLen = view.getUint16(offset, false);
          if (segLen < 2) break;

          // SOF markers that contain width/height
          const isSOF =
            (marker >= 0xC0 && marker <= 0xC3) ||
            (marker >= 0xC5 && marker <= 0xC7) ||
            (marker >= 0xC9 && marker <= 0xCB) ||
            (marker >= 0xCD && marker <= 0xCF);

          if (isSOF && offset + 7 < len) {
            const h = view.getUint16(offset + 3, false);
            const w = view.getUint16(offset + 5, false);
            if (w > 0 && h > 0) return { w, h };
            break;
          }

          offset += segLen;
        }
      }
    } catch(_) {}
    return null;
  }

  async function makeLodFromFile(fileOrBlob, maxDim){
    // Decode directly to a smaller bitmap when possible (prevents full-res decode on mobile).
    // IMPORTANT: preserve aspect ratio by computing resizeWidth/resizeHeight from header dimensions.
    const dims = await getImageDimsFromBlobOrFile(fileOrBlob);

    let resizeW = maxDim;
    let resizeH = maxDim;
    if (dims && dims.w > 0 && dims.h > 0) {
      if (dims.w >= dims.h) {
        resizeW = maxDim;
        resizeH = Math.max(1, Math.round(maxDim * (dims.h / dims.w)));
      } else {
        resizeH = maxDim;
        resizeW = Math.max(1, Math.round(maxDim * (dims.w / dims.h)));
      }
    }

    // Some browsers may ignore resize options; still safe for the common case (large JPG on mobile).
    const bitmap = await createImageBitmap(fileOrBlob, {
      resizeWidth: resizeW,
      resizeHeight: resizeH,
      resizeQuality: 'high'
    });

    const w = bitmap.width;
    const h = bitmap.height;

    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    ctx.drawImage(bitmap, 0, 0, w, h);
    try { bitmap.close && bitmap.close(); } catch(_) {}

    const blob = await new Promise((resolve) => {
      // This does NOT change your original file; it only creates a runtime proxy.
      canvas.toBlob((b) => resolve(b), 'image/jpeg', 0.92);
    });

    const url = URL.createObjectURL(blob);
    traceLodObjectUrls.add(url);
    return { url, w, h };
  }

  async function ensureTraceLod(maxDim){
    if (!traceOriginalUrl && !traceOriginalFile) return null;

    // If we have a cached LOD, use it
    if (traceLodCache.has(maxDim)) return traceLodCache.get(maxDim);

    if (traceLodInFlight.has(maxDim)) return traceLodInFlight.get(maxDim);

    const p = (async () => {
      // Prefer File-based decode (safe on mobile because we can resize during decode)
      if (traceOriginalFile && window.createImageBitmap) {
        const out = await makeLodFromFile(traceOriginalFile, maxDim);
        traceLodCache.set(maxDim, out);
        return out;
      }

      // Fallback: attempt fetch -> blob -> createImageBitmap (may fail on file:// in some browsers)
      if (window.createImageBitmap && window.fetch && traceOriginalUrl) {
        try {
          const resp = await fetch(traceOriginalUrl);
          const blob = await resp.blob();
          const out = await makeLodFromFile(blob, maxDim);
          traceLodCache.set(maxDim, out);
          return out;
        } catch(_) {
          // ignore and fall through
        }
      }

      // Last resort: we cannot safely build a proxy; return null (caller may fall back to original URL).
      return null;
    })();

    traceLodInFlight.set(maxDim, p);
    const out = await p;
    traceLodInFlight.delete(maxDim);
    return out;
  }

  function scheduleTraceLODUpdate(){
    if (!traceImageVisible) return;
    if (!traceOriginalUrl && !traceOriginalFile) return;
    if (__traceLodRaf) return;
    __traceLodRaf = requestAnimationFrame(() => {
      __traceLodRaf = 0;
      updateTraceLODNow();
    });
  }

  async function updateTraceLODNow(){
    if (!traceImageVisible) return;
    if (!traceOriginalUrl && !traceOriginalFile) return;

    const desiredMaxDim = chooseTraceLodKey();

    // On desktop, if you zoom in far enough, allow switching to full-res original.
    // We use the *raw* target before capping so you can still reach "full" beyond our cached proxy cap.
    const wantFullDesktop = (!isLikelyMobile()) && (__traceRawTargetPx > TRACE_MAXDIM_DESKTOP * 1.5);

    // Desktop: if you really zoom in, use full original. Mobile: never auto-switch to full.
    const key = wantFullDesktop ? 'full' : desiredMaxDim;

    if (traceLodKey === key) return;

    if (key === 'full') {
      // Full-res: use original URL directly
      traceLodKey = 'full';
      traceLodUrl = null;
      traceImageUrl = traceOriginalUrl; // renderAll/update element reads traceImageUrl
      updateTraceImageElement();
      return;
    }

    const out = await ensureTraceLod(key);
    if (out && out.url) {
      traceLodKey = key;
      traceLodUrl = out.url;
      traceImageUrl = out.url;
      updateTraceImageElement();
    } else {
      // If we cannot build a proxy, fall back to original (desktop) or do nothing (mobile)
      if (!isLikelyMobile() && traceOriginalUrl) {
        traceLodKey = 'full';
        traceLodUrl = null;
        traceImageUrl = traceOriginalUrl;
        updateTraceImageElement();
      }
    }
  }

  function setTracingImageSource(sourceUrl, filename, fileObj, makeVisible){
    // Clear old generated proxies
    clearTraceLod();

    // Revoke previous original object URL if any
    if (traceOriginalIsObjectUrl && traceOriginalUrl) {
      try { URL.revokeObjectURL(traceOriginalUrl); } catch(_) {}
    }

    traceOriginalUrl = sourceUrl || null;
    traceOriginalFile = fileObj || null;
    traceOriginalIsObjectUrl = !!(sourceUrl && sourceUrl.startsWith('blob:') && fileObj);

    traceImageName = filename || '';
    traceImageVisible = !!makeVisible;

    // KEY CHANGE:
    // If we have a File object (user loaded via picker), do NOT point the SVG <image> at the full-res source first.
    // That initial decode is what stalls desktop and crashes mobile. Instead, we start hidden and immediately build an LOD proxy.
    if (traceOriginalFile) {
      traceImageUrl = null;   // wait for proxy
      traceLodUrl = null;
      traceLodKey = null;
    } else {
      // Filename / URL source (autoload): we may not be able to safely build a proxy on file://
      traceImageUrl = traceOriginalUrl;
    }

    // Kick LOD selection
    scheduleTraceLODUpdate();
  }

  function syncTraceVisibilityUI(){
    if (traceToggleBtn) {
      traceToggleBtn.textContent = traceImageVisible ? 'Hide tracing image' : 'Show tracing image';
    }
    if (mapTraceBtn) {
      mapTraceBtn.classList.toggle('drag-on', !!traceImageVisible);
      mapTraceBtn.setAttribute('aria-pressed', traceImageVisible ? 'true' : 'false');
      mapTraceBtn.title = traceImageVisible ? 'Hide tracing image' : 'Show tracing image';
    }
  }

// world rotation angle (degrees)
  let worldAngle = 0;

  // pan dragging
  let panDrag = null;

  // track whether a pan occurred to suppress background click-clear
  let didPan = false;

  // pinch zoom state
  let pinchState = null;

  let state = window.MAP_DATA || {
    blockName: '',
    viewBox: [0,0,1000,700],
    buildings: [],
    streets: []
  };

  // If we autoloaded a sibling data file (Philadelphia.js), set the title now (before autosave keying).
  try {
    if (window.MAP_DATA && mapNameDisplayEl) {
      const metaName = (window.MAP_META && window.MAP_META.name) ? String(window.MAP_META.name).trim() : '';
      const title = metaName || (state && state.blockName) || '';
      if (title) mapNameDisplayEl.textContent = title.replace(/\.[^.]+$/, '');
      if (state && title && !state.blockName) state.blockName = title;
    }
  } catch(_) {}


  // =========================
  // Quick edit bar (mobile-docked) for the currently selected object
  const quickSelMetaEl = document.getElementById('quickSelMeta');
  const quickNameInputEl = document.getElementById('quickNameInput');
  const quickNotesInputEl = document.getElementById('quickNotesInput');
  const quickApplyBtnEl = document.getElementById('quickApplyBtn');
  const quickRoutesBtnEl = document.getElementById('quickRoutesBtn');

  const quickBuildingInfoWrapEl = document.getElementById('quickBuildingInfo');
  const quickTypeInputEl = document.getElementById('quickTypeInput');
  const quickUsageInputEl = document.getElementById('quickUsageInput');
  const quickFundingInputEl = document.getElementById('quickFundingInput');
  const quickOccupantsInputEl = document.getElementById('quickOccupantsInput');

  const quickSetupWrapEl = document.getElementById('quickSetupInputs');
  const quickColorInputEl = document.getElementById('quickColorInput');
  const quickLengthInputEl = document.getElementById('quickLengthInput');
  const quickWidthInputEl = document.getElementById('quickWidthInput');
  const quickAngleInputEl = document.getElementById('quickAngleInput');

  let quickLoaded = {
    type:null, id:null,
    name:'', notes:'',
    color:'', length:'', width:'', angle:'',
    bType:'', usage:'', funding:'', occupants:''
  };

  function getQuickSelection(){
    try {
      if (selectedType === 'building' && selectedId) {
        const b = (state.buildings || []).find(x => x.id === selectedId);
        if (!b) return null;
        return { type: 'building', id: selectedId, obj: b };
      }
      if (selectedType === 'street' && selectedId) {
        const s = (state.streets || []).find(x => x.id === selectedId);
        if (!s) return null;
        return { type: 'street', id: selectedId, obj: s };
      }
      return null;
    } catch(_) { return null; }
  }

  function quickGetStreetAngleDeg(s){
    try{
      if (!s || !Array.isArray(s.nodes) || s.nodes.length < 2) return 0;
      const a = s.nodes[0];
      const b = s.nodes[s.nodes.length - 1];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      return Math.atan2(dy, dx) * 180 / Math.PI;
    } catch(_) { return 0; }
  }

  function quickRotateStreetToAngle(s, targetDeg){
    if (!s || !Array.isArray(s.nodes) || s.nodes.length < 2) return;
    const first = s.nodes[0];
    const cx = first.x;
    const cy = first.y;
    const last = s.nodes[s.nodes.length - 1];
    const dx = last.x - cx;
    const dy = last.y - cy;
    const currentRad = Math.atan2(dy, dx);
    const targetRad = targetDeg * Math.PI / 180;
    const delta = targetRad - currentRad;

    const cosD = Math.cos(delta);
    const sinD = Math.sin(delta);
    for (let i = 1; i < s.nodes.length; i++) {
      const node = s.nodes[i];
      const rx = (node.x - cx) * cosD - (node.y - cy) * sinD;
      const ry = (node.x - cx) * sinD + (node.y - cy) * cosD;
      node.x = Math.round(cx + rx);
      node.y = Math.round(cy + ry);
    }
  }

  function quickSetStreetLength(s, lenVal){
    if (!s || !Array.isArray(s.nodes) || s.nodes.length < 2) return;
    if (!(lenVal > 0) || Number.isNaN(lenVal)) return;
    const nodes = s.nodes;
    const a = nodes[0];
    const b = nodes[nodes.length - 1];
    const curDx = b.x - a.x;
    const curDy = b.y - a.y;
    const curLen = Math.sqrt(curDx * curDx + curDy * curDy);
    if (!(curLen > 0)) return;
    const scale = lenVal / curLen;
    b.x = Math.round(a.x + curDx * scale);
    b.y = Math.round(a.y + curDy * scale);
  }

  function refreshQuickEditBar(){
    if (!quickSelMetaEl || !quickNameInputEl || !quickNotesInputEl || !quickApplyBtnEl) return;

    const sel = getQuickSelection();
    if (!sel){
      quickLoaded = { type:null, id:null, name:'', notes:'', color:'', length:'', width:'', angle:'', bType:'', usage:'', funding:'', occupants:'' };
      quickSelMetaEl.textContent = 'No selection';

      // Ensure no lingering street/route highlights when nothing is selected
      try { activeStreetId = null; } catch(_) {}
      try { clearSelectedStreetHighlight(); } catch(_) {}
      try { clearRouteHighlight(); } catch(_) {}

      // clear + disable
      [quickNameInputEl, quickNotesInputEl, quickTypeInputEl, quickUsageInputEl, quickFundingInputEl,
       quickOccupantsInputEl, quickColorInputEl, quickLengthInputEl, quickWidthInputEl, quickAngleInputEl]
        .forEach(el => { if (el){ el.value = ''; el.disabled = true; } });

      if (quickBuildingInfoWrapEl) quickBuildingInfoWrapEl.style.display = 'none';
      if (quickSetupWrapEl) quickSetupWrapEl.style.display = 'none';

      quickApplyBtnEl.disabled = true;
      return;
    }

    const isBuilding = (sel.type === 'building');
    quickSelMetaEl.textContent = isBuilding ? 'Building' : 'Street';

    // Always show setup inputs when something is selected
    if (quickSetupWrapEl) quickSetupWrapEl.style.display = '';
    if (quickBuildingInfoWrapEl) quickBuildingInfoWrapEl.style.display = isBuilding ? '' : 'none';

    const nameVal = isBuilding ? (sel.obj.label || '') : (sel.obj.name || '');
    const notesVal = (sel.obj.notes || '');

    let colorVal = '';
    let lengthVal = '';
    let widthVal = '';
    let angleVal = '';

    if (isBuilding){
      colorVal = toHexColor(sel.obj.color || getFillForType(sel.obj.type));
      lengthVal = String((typeof sel.obj.h === 'number') ? sel.obj.h : (sel.obj.h || ''));
      widthVal = String((typeof sel.obj.w === 'number') ? sel.obj.w : (sel.obj.w || ''));
      angleVal = String((typeof sel.obj.angle === 'number') ? sel.obj.angle : (sel.obj.angle || 0));
    } else {
      colorVal = toHexColor(sel.obj.color || 'rgba(60,66,72,0.95)');
      lengthVal = String(Math.round(computeStreetEndToEndLength(sel.obj) || 0));
      widthVal = String((typeof sel.obj.width === 'number') ? Math.round(sel.obj.width) : (sel.obj.width || 60));
      angleVal = String(Number(quickGetStreetAngleDeg(sel.obj)).toFixed(1));
    }

    quickLoaded = {
      type: sel.type,
      id: sel.id,
      name: String(nameVal),
      notes: String(notesVal),
      color: String(colorVal),
      length: String(lengthVal),
      width: String(widthVal),
      angle: String(angleVal),
      bType: isBuilding ? String(sel.obj.type || 'other') : '',
      usage: isBuilding ? String(sel.obj.usage || 'none') : '',
      funding: isBuilding ? String(sel.obj.funding || 'none') : '',
      occupants: isBuilding ? String(sel.obj.occupants || '') : ''
    };

    // Populate + enable base fields
    if (quickNameInputEl){ quickNameInputEl.value = nameVal; quickNameInputEl.disabled = false; }
    if (quickNotesInputEl){ quickNotesInputEl.value = notesVal; quickNotesInputEl.disabled = false; }

    // Setup fields (both)
    if (quickColorInputEl){ quickColorInputEl.value = colorVal || '#888888'; quickColorInputEl.disabled = false; }
    if (quickLengthInputEl){ quickLengthInputEl.value = lengthVal; quickLengthInputEl.disabled = false; }
    if (quickWidthInputEl){ quickWidthInputEl.value = widthVal; quickWidthInputEl.disabled = false; }
    if (quickAngleInputEl){ quickAngleInputEl.value = angleVal; quickAngleInputEl.disabled = false; }

    // Building-only fields
    if (isBuilding){
      if (quickTypeInputEl){ quickTypeInputEl.value = (sel.obj.type || 'other'); quickTypeInputEl.disabled = false; }
      if (quickUsageInputEl){ quickUsageInputEl.value = (sel.obj.usage || 'none'); quickUsageInputEl.disabled = false; }
      if (quickFundingInputEl){ quickFundingInputEl.value = (sel.obj.funding || 'none'); quickFundingInputEl.disabled = false; }
      if (quickOccupantsInputEl){ quickOccupantsInputEl.value = (sel.obj.occupants || ''); quickOccupantsInputEl.disabled = false; }
    } else {
      [quickTypeInputEl, quickUsageInputEl, quickFundingInputEl, quickOccupantsInputEl]
        .forEach(el => { if (el){ el.value = ''; el.disabled = true; } });
    }

    quickApplyBtnEl.disabled = true;
  }

  function updateQuickApplyEnabled(){
    if (!quickApplyBtnEl) return;
    const sel = getQuickSelection();
    if (!sel) { quickApplyBtnEl.disabled = true; return; }

    const isBuilding = (sel.type === 'building');

    const now = {
      name: String(quickNameInputEl ? (quickNameInputEl.value || '') : ''),
      notes: String(quickNotesInputEl ? (quickNotesInputEl.value || '') : ''),
      color: String(quickColorInputEl ? (quickColorInputEl.value || '') : ''),
      length: String(quickLengthInputEl ? (quickLengthInputEl.value || '') : ''),
      width: String(quickWidthInputEl ? (quickWidthInputEl.value || '') : ''),
      angle: String(quickAngleInputEl ? (quickAngleInputEl.value || '') : ''),
      bType: isBuilding ? String(quickTypeInputEl ? (quickTypeInputEl.value || '') : '') : '',
      usage: isBuilding ? String(quickUsageInputEl ? (quickUsageInputEl.value || '') : '') : '',
      funding: isBuilding ? String(quickFundingInputEl ? (quickFundingInputEl.value || '') : '') : '',
      occupants: isBuilding ? String(quickOccupantsInputEl ? (quickOccupantsInputEl.value || '') : '') : ''
    };

    const dirty =
      now.name !== String(quickLoaded.name) ||
      now.notes !== String(quickLoaded.notes) ||
      now.color !== String(quickLoaded.color) ||
      now.length !== String(quickLoaded.length) ||
      now.width !== String(quickLoaded.width) ||
      now.angle !== String(quickLoaded.angle) ||
      (isBuilding && (
        now.bType !== String(quickLoaded.bType) ||
        now.usage !== String(quickLoaded.usage) ||
        now.funding !== String(quickLoaded.funding) ||
        now.occupants !== String(quickLoaded.occupants)
      ));

    quickApplyBtnEl.disabled = !dirty;
  }

  // Enable Apply when any input changes
  [quickNameInputEl, quickNotesInputEl, quickColorInputEl, quickLengthInputEl, quickWidthInputEl, quickAngleInputEl,
   quickTypeInputEl, quickUsageInputEl, quickFundingInputEl, quickOccupantsInputEl]
    .forEach(el => { if (el) el.addEventListener('input', updateQuickApplyEnabled); });

  if (quickApplyBtnEl) quickApplyBtnEl.addEventListener('click', (evt)=>{
    evt.preventDefault(); evt.stopPropagation();
    const sel = getQuickSelection();
    if (!sel) return;

    const isBuilding = (sel.type === 'building');

    // Snapshot new values
    const newName = String(quickNameInputEl ? (quickNameInputEl.value || '') : '');
    const newNotes = String(quickNotesInputEl ? (quickNotesInputEl.value || '') : '');
    const newColor = String(quickColorInputEl ? (quickColorInputEl.value || '') : '');

    const newLength = Number(quickLengthInputEl ? quickLengthInputEl.value : NaN);
    const newWidth  = Number(quickWidthInputEl ? quickWidthInputEl.value : NaN);
    const newAngle  = Number(quickAngleInputEl ? quickAngleInputEl.value : NaN);

    const newBType = isBuilding ? String(quickTypeInputEl ? (quickTypeInputEl.value || '') : '') : '';
    const newUsage = isBuilding ? String(quickUsageInputEl ? (quickUsageInputEl.value || '') : '') : '';
    const newFunding = isBuilding ? String(quickFundingInputEl ? (quickFundingInputEl.value || '') : '') : '';
    const newOccupants = isBuilding ? String(quickOccupantsInputEl ? (quickOccupantsInputEl.value || '') : '') : '';

    // If nothing changed, just refresh
    updateQuickApplyEnabled();
    if (quickApplyBtnEl.disabled) { refreshQuickEditBar(); return; }

    pushHistory('Quick edit');

    if (isBuilding) {
      sel.obj.label = newName;
      sel.obj.notes = newNotes;

      if (newBType) sel.obj.type = newBType;
      sel.obj.usage = newUsage || sel.obj.usage;
      sel.obj.funding = newFunding || sel.obj.funding;
      sel.obj.occupants = newOccupants;

      if (newColor) sel.obj.color = newColor;

      if (!Number.isNaN(newWidth) && newWidth > 0) sel.obj.w = newWidth;
      if (!Number.isNaN(newLength) && newLength > 0) sel.obj.h = newLength;
      if (!Number.isNaN(newAngle)) sel.obj.angle = newAngle;

      // keep inspector fields in sync if it's open
      const bLabelEl = document.getElementById('bLabel'); if (bLabelEl) bLabelEl.value = newName;
      const bNotesEl = document.getElementById('bNotes'); if (bNotesEl) bNotesEl.value = newNotes;
      const bTypeEl = document.getElementById('bType'); if (bTypeEl && newBType) bTypeEl.value = newBType;
      const bUsageEl = document.getElementById('bUsage'); if (bUsageEl) bUsageEl.value = newUsage || bUsageEl.value;
      const bFundingEl = document.getElementById('bFunding'); if (bFundingEl) bFundingEl.value = newFunding || bFundingEl.value;
      const bOccEl = document.getElementById('bOcc'); if (bOccEl) bOccEl.value = newOccupants;
      const bColorEl = document.getElementById('bColor'); if (bColorEl && newColor) bColorEl.value = newColor;
      const bWEl = document.getElementById('bW'); if (bWEl && !Number.isNaN(newWidth) && newWidth > 0) bWEl.value = String(newWidth);
      const bHEl = document.getElementById('bH'); if (bHEl && !Number.isNaN(newLength) && newLength > 0) bHEl.value = String(newLength);
      const bAngleEl = document.getElementById('bAngle'); if (bAngleEl && !Number.isNaN(newAngle)) bAngleEl.value = String(newAngle);
      refreshInspectorTitle(newName);
    } else {
      sel.obj.name = newName;
      sel.obj.notes = newNotes;
      if (newColor) sel.obj.color = newColor;

      if (!Number.isNaN(newWidth) && newWidth > 0) sel.obj.width = newWidth;
      quickSetStreetLength(sel.obj, newLength);
      if (!Number.isNaN(newAngle)) quickRotateStreetToAngle(sel.obj, newAngle);

      // keep street inspector fields in sync if open
      const sNameEl = document.getElementById('streetName'); if (sNameEl) sNameEl.value = newName;
      const sNotesEl = document.getElementById('streetNotes'); if (sNotesEl) sNotesEl.value = newNotes;
      const sColorEl = document.getElementById('streetColor'); if (sColorEl && newColor) sColorEl.value = newColor;

      const sLenEl = document.getElementById('streetGW'); if (sLenEl && !Number.isNaN(newLength) && newLength > 0) sLenEl.value = String(Math.round(newLength));
      const sWidEl = document.getElementById('streetGH'); if (sWidEl && !Number.isNaN(newWidth) && newWidth > 0) sWidEl.value = String(Math.round(newWidth));
      const sAngEl = document.getElementById('streetAngle'); if (sAngEl && !Number.isNaN(newAngle)) sAngEl.value = String(newAngle);

      const st = document.getElementById('streetInspectorTitle');
      if (st) st.textContent = (newName && String(newName).trim()) ? newName : 'Street';
    }

    if (typeof scheduleAutosave === 'function') scheduleAutosave('quick edit');
    renderAll();
    applySelectedStreetHighlight(id);
    refreshQuickEditBar();
  });

  // Routes button moved into the info/label panel (mobile)
  if (quickRoutesBtnEl) quickRoutesBtnEl.addEventListener('click', (evt)=>{
    evt.preventDefault(); evt.stopPropagation();
    const wasOpen = document.body.classList.contains('mobile-pane-analytics');
    document.body.classList.remove('mobile-pane-info','mobile-pane-analytics');
    if (!wasOpen) document.body.classList.add('mobile-pane-analytics');
  });

// initialize
  refreshQuickEditBar();


  // =========================
  // Autosave (localStorage)
  const AUTOSAVE_VERSION = 1;
  const AUTOSAVE_DEBOUNCE_MS = 450;
  let autosaveTimer = null;
  let autosaveAppliedThisSession = false;

  function safeId(raw){
    return String(raw || '')
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9_-]+/g, '_')
      .replace(/^_+|_+$/g, '')
      .slice(0, 80) || 'default';
  }

  function getCurrentMapId(){
    try {
      if (window.MAP_META && typeof window.MAP_META.id === 'string' && window.MAP_META.id) return safeId(window.MAP_META.id);
      if (window.MAP_META && typeof window.MAP_META.name === 'string' && window.MAP_META.name) return safeId(window.MAP_META.name);
    } catch(_) {}
    const name = (mapNameDisplayEl && mapNameDisplayEl.textContent) ? mapNameDisplayEl.textContent : '';
    return safeId(name || (state && state.blockName) || 'default');
  }

  function getAutosaveKey(){
    return 'SICAMap_autosave_v' + AUTOSAVE_VERSION + '__' + getCurrentMapId();
  }

  function formatClock(ts){
    if (!ts) return '—';
    try {
      return new Date(ts)
        .toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true })
        .toLowerCase();
    } catch(_) {
      return '—';
    }
  }

  function setAutosaveIndicator(ts){
    if (!autosaveIndicatorEl) return;
    autosaveIndicatorEl.textContent = 'Last saved: ' + (ts ? formatClock(ts) : '—');
  }

  function readAutosave(){
    try {
      const raw = localStorage.getItem(getAutosaveKey());
      if (!raw) return null;
      const obj = JSON.parse(raw);
      if (!obj || typeof obj !== 'object') return null;
      if (!obj.ts || !obj.state) return null;
      return obj;
    } catch(_) {
      return null;
    }
  }

  function writeAutosave(obj){
    try {
      localStorage.setItem(getAutosaveKey(), JSON.stringify(obj));
    } catch(_) {}
  }

  function buildStateToSave(){
    // Clone state so we can strip out any tracing image URL/data before saving
    const s = JSON.parse(JSON.stringify(state));
    if (s && s.trace && s.trace.url) {
      delete s.trace.url;
    }
    return s;
  }

  function scheduleAutosave(reason){
    if (autosaveTimer) clearTimeout(autosaveTimer);
    autosaveTimer = setTimeout(() => {
      try {
        const ts = Date.now();
        const payload = {
          v: AUTOSAVE_VERSION,
          ts,
          reason: String(reason || ''),
          mapId: getCurrentMapId(),
          fileSavedAt: currentFileSavedAt || 0,
          state: buildStateToSave()
        };
        writeAutosave(payload);
        setAutosaveIndicator(ts);
      } catch(_) {}
    }, AUTOSAVE_DEBOUNCE_MS);
  }

  function setRestorePromptVisible(visible){
    if (restoreAutosaveBtn) restoreAutosaveBtn.style.display = visible ? 'inline-flex' : 'none';
    if (cancelAutosaveBtn) cancelAutosaveBtn.style.display = visible ? 'inline-flex' : 'none';
  }

  function getDismissKey(){
    return 'SICAMap_autosave_dismissed_ts__' + getCurrentMapId();
  }

  function shouldOfferRestore(payload){
    if (!payload || !payload.ts) return false;
    const dismissed = Number(sessionStorage.getItem(getDismissKey()) || 0) || 0;
    if (payload.ts <= dismissed) return false;
    // Only offer restore when autosave is newer than what's in the loaded file
    if ((currentFileSavedAt || 0) && payload.ts <= currentFileSavedAt) return false;
    return true;
  }

  function refreshAutosaveUI(showRestorePrompt){
    const payload = readAutosave();
    setAutosaveIndicator(payload ? payload.ts : 0);
    if (showRestorePrompt && shouldOfferRestore(payload)) {
      setRestorePromptVisible(true);
    } else {
      setRestorePromptVisible(false);
    }
  }

  function applyAutosave(payload){
    if (!payload || !payload.state) return;
    try {
      state = normalizeState(payload.state);
      // Keep tracing image / overlay consistent with restored state
      hydrateTraceFromState();
      // Clear selection (restored state may not match selected IDs)
      selectedId = null;
      selectedType = null;
      if (selectedIds) selectedIds.clear();
      activeStreetId = null;
      try { clearSelectedStreetHighlight(); } catch(_) {}
      try { clearRouteHighlight(); } catch(_) {}
      activeStreetId = null;
      autosaveAppliedThisSession = true;
      renderAll();
      setAutosaveIndicator(payload.ts || 0);
      setRestorePromptVisible(false);
    } catch(err) {
      console.error(err);
      alert('Failed to restore autosave: ' + (err && err.message ? err.message : String(err)));
    }
  }

  // Initial autosave UI on page load
  refreshAutosaveUI(true);
  if (restoreAutosaveBtn) {
    restoreAutosaveBtn.addEventListener('click', () => {
      const payload = readAutosave();
      applyAutosave(payload);
    });
  }
  if (cancelAutosaveBtn) {
    cancelAutosaveBtn.addEventListener('click', () => {
      const payload = readAutosave();
      const ts = payload && payload.ts ? payload.ts : Date.now();
      try { sessionStorage.setItem(getDismissKey(), String(ts)); } catch(_) {}
      setRestorePromptVisible(false);
    });
  }


  // =========================
  // Undo / Redo (edit history)
  // =========================
  const UNDO_LIMIT = 200;
  let undoStack = [];
  let redoStack = [];
  let historyLock = false;

  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  function getUndoSnapshotJson(){
    // Deep-clone state. Keep the current camera position (viewBox) OUT of history
    // so Undo/Redo doesn't jump your view around.
    const snap = JSON.parse(JSON.stringify(state || {}));
    if (snap && snap.viewBox) delete snap.viewBox;
    return JSON.stringify(snap);
  }

  function updateUndoRedoUI(){
    if (undoBtn) undoBtn.disabled = (undoStack.length === 0);
    if (redoBtn) redoBtn.disabled = (redoStack.length === 0);
  }

  function pushHistoryFromJson(json, label){
    if (historyLock) return;
    const last = undoStack.length ? undoStack[undoStack.length - 1].json : null;
    if (last === json) return; // avoid duplicate no-op entries
    undoStack.push({ json, label: label || '' });
    if (undoStack.length > UNDO_LIMIT) undoStack.shift();
    redoStack.length = 0;
    updateUndoRedoUI();
    scheduleAutosave(label || 'Edit');
  }

  function pushHistory(label){
    pushHistoryFromJson(getUndoSnapshotJson(), label);
  }

  function restoreFromHistoryJson(json){
    const vb = (state && Array.isArray(state.viewBox)) ? state.viewBox.slice() : [0,0,1000,700];
    let next = null;
    try { next = JSON.parse(json); } catch(_) { return; }
    next.viewBox = vb;

    state = normalizeState(next);

    // Preserve current tracing visibility; Undo/Redo should not toggle hide/show.
    const prevTraceVisible = traceImageVisible;

    // Keep tracing image / overlay consistent with restored state
    hydrateTraceFromState();
    traceImageVisible = prevTraceVisible;
    syncTraceVisibilityUI();

    renderAll();
    reconcileSelectionAfterUndoRedo();
  }

  function reconcileSelectionAfterUndoRedo(){
    // Try to preserve your selection if the thing still exists; otherwise clear inspector UI.
    if (selectedType === 'building' && selectedId) {
      const exists = (state.buildings || []).some(b => b.id === selectedId);
      if (exists) { selectBuilding(selectedId); return; }
    }
    if (selectedType === 'street' && selectedId) {
      const exists = (state.streets || []).some(s => s.id === selectedId);
      if (exists) { selectStreet(selectedId); return; }
    }
    if (selectedType === 'multi' && selectedIds && selectedIds.size > 0) {
      const existing = new Set((state.buildings || []).map(b => b.id));
      const kept = new Set([...selectedIds].filter(id => existing.has(id)));
      selectedIds = kept;
      if (selectedIds.size > 0) {
        selectedType = 'multi';
        selectedId = null;
        showMultiInspector();
        renderAll();
        return;
      }
    }

    selectedId = null;
    selectedType = null;
    if (selectedIds) selectedIds.clear();
    activeStreetId = null;
    form.style.display = 'none';
    noSelection.style.display = 'block';
    removeStreetInspector();
    clearSelectedStreetHighlight();
    clearRouteHighlight();
    renderAll();
    refreshQuickEditBar();
  }

  function undo(){
    if (!undoStack.length) return;
    const current = getUndoSnapshotJson();
    const entry = undoStack.pop();
    redoStack.push({ json: current, label: entry.label || '' });

    historyLock = true;
    restoreFromHistoryJson(entry.json);
    historyLock = false;

    updateUndoRedoUI();
  }

  function redo(){
    if (!redoStack.length) return;
    const current = getUndoSnapshotJson();
    const entry = redoStack.pop();
    undoStack.push({ json: current, label: entry.label || '' });
    if (undoStack.length > UNDO_LIMIT) undoStack.shift();

    historyLock = true;
    restoreFromHistoryJson(entry.json);
    historyLock = false;

    updateUndoRedoUI();
  }

  if (undoBtn) undoBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); undo(); });
  if (redoBtn) redoBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); redo(); });
  updateUndoRedoUI();

  // Keyboard shortcuts: Undo / Redo
// - Undo: Ctrl/Cmd+Z
// - Redo: Ctrl/Cmd+Y  OR  Ctrl/Cmd+Shift+Z
window.addEventListener('keydown', (e) => {
  const ae = document.activeElement;
  const tag = ae && ae.tagName;
  const isEditable = (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (ae && ae.isContentEditable));
  if (isEditable) return;

  const mod = e.ctrlKey || e.metaKey;
  if (!mod) return;

  const key = String(e.key || '').toLowerCase();
  if (key === 'z') {
    e.preventDefault();
    if (e.shiftKey) redo();
    else undo();
  } else if (key === 'y') {
    e.preventDefault();
    redo();
  }
}, { capture: true });

const NS = 'http://www.w3.org/2000/svg';

  // Simple layer visibility model for different transportation modes
  const layerVisibility = {
    streets: true,
    water: true,
    bike: true,
    rail: true,
    bus: true
  };
  // Used to auto-classify waterways into their own layer
  const WATER_LAYER_RE = /\b(river|lake|pond|ocean|sea|bay|harbor|harbour|creek|stream|canal|waterway|inlet|gulf|sound|strait|lagoon|reservoir|marsh|wetland)\b/;


  function getStreetLayer(s){
    const name = (s.name || '').toLowerCase();
    const notes = (s.notes || '').toLowerCase();
    const color = (s.color || '').toLowerCase();
    // Rivers & waterways: keyword match in name/notes
    if (WATER_LAYER_RE.test(name) || WATER_LAYER_RE.test(notes)) return 'water';
    // Bike lanes: explicit in name/notes
    if (name.includes('bike lane') || notes.includes('bike lane')) return 'bike';
    // Bus routes: anything explicitly called a bus
    if (name.includes(' bus') || name.endsWith('bus') || name.includes('buses') || notes.includes(' bus')) return 'bus';
    // Rail (regional + subway/metro)
    if (name.includes('regional rail') || notes.includes('regional rail')) return 'rail';
    if (name.includes('train tracks') || notes.includes('train')) return 'rail';
    if (name.includes('subway') || notes.includes('subway')) return 'rail';
    if (name.includes('metro') || notes.includes('metro')) return 'rail';
    if (name.includes('trolley') || notes.includes('trolley')) return 'rail';
    if (name.includes('tram') || notes.includes('tram')) return 'rail';
    // Named "lines" like Broad St. Line, etc.
    if (name.includes(' line')) return 'rail';
    // Fallback: basic street network
    return 'streets';
  }

  function isLayerVisibleForStreet(s){
    const layer = getStreetLayer(s);
    return layerVisibility[layer] !== false;
  }


    // -----------------------------
  // Transit stop association / highlighting helpers
  // -----------------------------
  // Broader stop keyword detection (used for highlighting stops when a line is selected).
  // We keep it strict enough to avoid highlighting random buildings.
  const STOP_KEYWORDS_RE = /\b(stop|station|subway|metro|trolley|rail|train|transportation\s+center|transportation\s+centre|transit\s+center|hub)\b/i;

  // Normalize text for loose-but-safe matching (e.g., "Broad St. Line" vs "Broad St Line").
  function normalizeForMatch(s){
    return String(s || '')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  function getBuildingCenterAndRadius(b){
    const x = Number(b && b.x) || 0;
    const y = Number(b && b.y) || 0;
    const w = Number(b && b.w) || 0;
    const h = Number(b && b.h) || 0;
    const cx = x + w / 2;
    const cy = y + h / 2;
    const radius = 0.5 * Math.sqrt(w*w + h*h);
    return { cx, cy, radius };
  }

  


// -----------------------------
// Map search (center map on any object)
// -----------------------------
const __SEARCH_MAX_RESULTS = 40;

function __getBuildingSearchLabel(b){
  const label = (b && b.label != null) ? String(b.label).trim() : '';
  if (label) return label;
  const t = (b && b.type) ? String(b.type).trim() : '';
  if (t) return t.replace(/_/g,' ');
  return 'Building';
}

function __getStreetSearchLabel(s){
  const name = (s && s.name != null) ? String(s.name).trim() : '';
  return name || 'Street';
}

function __getStreetCenter(s){
  const nodes = s && s.nodes;
  if (!Array.isArray(nodes) || nodes.length === 0) return { x: 0, y: 0 };
  const b = getStreetBounds(nodes);
  if (Number.isFinite(b.minX) && Number.isFinite(b.maxX) && Number.isFinite(b.minY) && Number.isFinite(b.maxY)) {
    return { x: (b.minX + b.maxX) / 2, y: (b.minY + b.maxY) / 2 };
  }
  let sx=0, sy=0, n=0;
  nodes.forEach(pt => {
    const x = Number(pt.x);
    const y = Number(pt.y);
    if (Number.isFinite(x) && Number.isFinite(y)) { sx += x; sy += y; n++; }
  });
  return n ? { x: sx/n, y: sy/n } : { x: 0, y: 0 };
}

function __centerViewOnPoint(px, py){
  try {
    const vb = svg.viewBox && svg.viewBox.baseVal;
    if (!vb) return;
    const nx = (Number(px) || 0) - vb.width / 2;
    const ny = (Number(py) || 0) - vb.height / 2;
    svg.setAttribute('viewBox', `${nx} ${ny} ${vb.width} ${vb.height}`);
    try { if (state && Array.isArray(state.viewBox)) state.viewBox = [nx, ny, vb.width, vb.height]; } catch(_) {}
    applyWorldRotation();
    try { scheduleTraceLODUpdate(); } catch(_) {}
    try { svg.focus(); } catch(_) {}
  } catch(_) {}
}

function __normalizeQueryTokens(q){
  const norm = normalizeForMatch(String(q || '').toLowerCase());
  if (!norm) return [];
  const raw = norm.split(' ').filter(Boolean);

  // tiny stemming / synonyms for the common cases
  const out = [];
  raw.forEach(t => {
    if (!t) return;
    if (t === 'groceries') t = 'grocery';
    if (t === 'buses') t = 'bus';
    if (t.endsWith('s') && t.length > 3) out.push(t.slice(0, -1)); // plural -> singular-ish
    out.push(t);
  });

  // de-dupe, preserve order
  const seen = new Set();
  const dedup = [];
  out.forEach(t => { if (!seen.has(t)) { seen.add(t); dedup.push(t); } });
  return dedup;
}

function __buildSearchItems(){
  const items = [];

  // Streets (including bus/rail lines)
  (state.streets || []).forEach(s => {
    if (!s || !s.id) return;
    const layer = getStreetLayer(s);
    const center = __getStreetCenter(s);
    const name = __getStreetSearchLabel(s);
    const hay = [
      name,
      layer,
      'street',
      (s.notes || ''),
      (s.tags || '')
    ].join(' ');
    items.push({
      kind: 'street',
      id: s.id,
      layer,
      name,
      nameNorm: normalizeForMatch(name.toLowerCase()),
      hayNorm: normalizeForMatch(hay.toLowerCase()),
      x: center.x,
      y: center.y
    });
  });

  // Buildings (including stops)
  (state.buildings || []).forEach(b => {
    if (!b || !b.id) return;
    const label = __getBuildingSearchLabel(b);
    const type = (b.type || '').toString();
    const usage = (b.usage || '').toString();
    const funding = (b.funding || '').toString();
    const notes = (b.notes || '').toString();
    const occ = (b.occupants || '').toString();
    const hayRaw = (label + ' ' + notes + ' ' + type).toLowerCase();
    const isStop = (String(type).toLowerCase() === 'public_transport') || STOP_KEYWORDS_RE.test(hayRaw);
    const geo = getBuildingCenterAndRadius(b);
    const kindLabel = isStop ? 'stop' : 'building';
    const hay = [
      label,
      type,
      usage,
      funding,
      notes,
      occ,
      kindLabel,
      // Include "bus" so searching bus shows stops + lines (even if the stop isn't explicitly labeled "bus")
      isStop ? 'bus rail transit station' : ''
    ].join(' ');
    items.push({
      kind: 'building',
      id: b.id,
      isStop,
      type: String(type || '').toLowerCase(),
      name: label,
      nameNorm: normalizeForMatch(label.toLowerCase()),
      hayNorm: normalizeForMatch(hay.toLowerCase()),
      x: geo.cx,
      y: geo.cy
    });
  });

  return items;
}

function __scoreSearchItem(item, qNorm){
  let s = 0;
  if (!item) return s;
  const nn = item.nameNorm || '';
  if (qNorm && nn) {
    if (nn === qNorm) s += 120;
    else if (nn.startsWith(qNorm)) s += 90;
    else if (nn.includes(qNorm)) s += 55;
  }
  if (item.kind === 'building') s += 10;
  if (item.kind === 'street') s += 6;
  if (item.kind === 'building' && item.isStop) s += 8;
  if (item.kind === 'street' && (item.layer === 'bus' || item.layer === 'rail')) s += 10;
  return s;
}

function __renderSearchResults(matches, activeIndex){
  if (!mapSearchResults) return;
  mapSearchResults.innerHTML = '';

  if (!matches || matches.length === 0) {
    const d = document.createElement('div');
    d.className = 'search-empty';
    d.textContent = 'No matches.';
    mapSearchResults.appendChild(d);
    mapSearchResults.style.display = 'block';
    return;
  }

  matches.forEach((m, idx) => {
    const row = document.createElement('div');
    row.className = 'search-item' + (idx === activeIndex ? ' active' : '');

    const title = document.createElement('div');
    title.className = 'title';

    let prefix = '';
    if (m.kind === 'building') prefix = m.isStop ? 'Stop' : 'Building';
    else if (m.kind === 'street') {
      if (m.layer === 'bus') prefix = 'Bus line';
      else if (m.layer === 'rail') prefix = 'Rail line';
      else if (m.layer === 'bike') prefix = 'Bike lane';
      else if (m.layer === 'water') prefix = 'Waterway';
      else prefix = 'Street';
    }

    title.textContent = `${prefix}: ${m.name}`;

    const meta = document.createElement('div');
    meta.className = 'meta';

    if (m.kind === 'building' && m.isStop) {
      let lineNames = [];
      try {
        const bObj = (state.buildings || []).find(x => x && x.id === m.id);
        const ids = getAssociatedStreetIdsForStopBuilding(bObj);
        lineNames = (ids || []).map(id => {
          const st = (state.streets || []).find(s => s && s.id === id);
          return st && st.name ? String(st.name).trim() : '';
        }).filter(Boolean);
      } catch(_) {}
      if (lineNames.length) meta.textContent = 'Serves: ' + lineNames.slice(0,3).join(', ') + (lineNames.length > 3 ? '…' : '');
      else meta.textContent = 'Public transport stop';
    } else if (m.kind === 'street') {
      meta.textContent = (m.layer === 'streets') ? 'Street' : (m.layer ? (m.layer.charAt(0).toUpperCase() + m.layer.slice(1)) : 'Street');
    } else {
      meta.textContent = (m.type ? m.type.replace(/_/g,' ') : 'Building');
    }

    row.appendChild(title);
    row.appendChild(meta);

    row.addEventListener('mousedown', (e) => {
      // mousedown so we select before input blur hides the list
      e.preventDefault();
      e.stopPropagation();
      __activateSearchItem(m);
    });

    mapSearchResults.appendChild(row);
  });

  mapSearchResults.style.display = 'block';
}

function __hideSearchResults(){
  if (mapSearchResults) mapSearchResults.style.display = 'none';
}

function __activateSearchItem(item){
  if (!item) return;
  try {
    if (mapSearchInput) mapSearchInput.value = item.name || '';
    __hideSearchResults();

    if (item.kind === 'building') {
      selectBuilding(item.id);
      __centerViewOnPoint(item.x, item.y);
    } else if (item.kind === 'street') {
      selectStreet(item.id);
      __centerViewOnPoint(item.x, item.y);
    }
  } catch(_) {}
}

function __wireMapSearch(){
  if (!mapSearchInput || !mapSearchResults) return;

  let activeIndex = -1;
  let lastMatches = [];

  function update(){
    const q = String(mapSearchInput.value || '').trim();
    const toks = __normalizeQueryTokens(q);
    const qNorm = normalizeForMatch(q.toLowerCase());

    if (!toks.length) {
      lastMatches = [];
      activeIndex = -1;
      __hideSearchResults();
      return;
    }

    const all = __buildSearchItems();
    const matches = [];

    for (const item of all){
      const hay = item.hayNorm || '';
      let ok = true;
      for (const t of toks){
        if (!t) continue;
        if (!hay.includes(t)) { ok = false; break; }
      }
      if (!ok) continue;
      matches.push(item);
    }

    matches.sort((a,b) => __scoreSearchItem(b, qNorm) - __scoreSearchItem(a, qNorm));
    lastMatches = matches.slice(0, __SEARCH_MAX_RESULTS);

    if (activeIndex >= lastMatches.length) activeIndex = lastMatches.length - 1;
    if (activeIndex < 0 && lastMatches.length) activeIndex = 0;

    __renderSearchResults(lastMatches, activeIndex);
  }

  mapSearchInput.addEventListener('input', update);

  mapSearchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Escape'){
      __hideSearchResults();
      return;
    }
    if (e.key === 'ArrowDown'){
      if (!lastMatches.length) return;
      e.preventDefault();
      activeIndex = Math.min(lastMatches.length - 1, activeIndex + 1);
      __renderSearchResults(lastMatches, activeIndex);
      return;
    }
    if (e.key === 'ArrowUp'){
      if (!lastMatches.length) return;
      e.preventDefault();
      activeIndex = Math.max(0, activeIndex - 1);
      __renderSearchResults(lastMatches, activeIndex);
      return;
    }
    if (e.key === 'Enter'){
      if (activeIndex >= 0 && activeIndex < lastMatches.length){
        e.preventDefault();
        __activateSearchItem(lastMatches[activeIndex]);
      }
    }
  });

  mapSearchInput.addEventListener('focus', () => {
    const q = String(mapSearchInput.value || '').trim();
    if (q) update();
  });

  // click outside closes
  document.addEventListener('mousedown', (e) => {
    const wrap = document.getElementById('mapSearchWrap');
    if (wrap && wrap.contains(e.target)) return;
    __hideSearchResults();
  }, { capture: true });
}

try { __wireMapSearch(); } catch(_) {}

function pointToSegmentDist2(px, py, ax, ay, bx, by){
    const abx = bx - ax, aby = by - ay;
    const apx = px - ax, apy = py - ay;
    const ab2 = abx*abx + aby*aby;
    if (ab2 <= 1e-9){
      const dx = px - ax, dy = py - ay;
      return dx*dx + dy*dy;
    }
    let t = (apx*abx + apy*aby) / ab2;
    if (t < 0) t = 0;
    else if (t > 1) t = 1;
    const cx = ax + t*abx, cy = ay + t*aby;
    const dx = px - cx, dy = py - cy;
    return dx*dx + dy*dy;
  }

  function polylineMinDist2(px, py, nodes){
    if (!Array.isArray(nodes) || nodes.length < 2) return Infinity;
    let best = Infinity;
    for (let i=0; i<nodes.length-1; i++){
      const a = nodes[i], b = nodes[i+1];
      const d2 = pointToSegmentDist2(px, py, Number(a.x)||0, Number(a.y)||0, Number(b.x)||0, Number(b.y)||0);
      if (d2 < best) best = d2;
    }
    return best;
  }

  function getStreetBounds(nodes){
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    if (!Array.isArray(nodes) || !nodes.length) return {minX, minY, maxX, maxY};
    nodes.forEach(n => {
      const x = Number(n.x)||0, y = Number(n.y)||0;
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    });
    return {minX, minY, maxX, maxY};
  }

  function shouldUseRailGeometryForBuilding(b, hayLower){
    // Avoid accidentally treating bus stops as rail stops at crossings.
    if (/\bbus(es)?\b/.test(hayLower)) return false;

    const t = (b && b.type ? String(b.type) : '').toLowerCase();
    if (t === 'public_transport') return true;

    // If a building is clearly "rail-ish", allow geometry association.
    return /\b(rail|train|subway|metro|trolley|station)\b/.test(hayLower);
  }

  function stopNearStreet(bCache, street){
    if (!bCache || !street) return false;
    const nodes = street.nodes;
    if (!Array.isArray(nodes) || nodes.length < 2) return false;

    const width = Number(street.width) || 0;
    // Tuned for your maps: rail/metro stops can be offset from the drawn line a bit,
    // but we still want to avoid "nearby intersection" false positives.
    const base = Math.max(110, width * 1.3);
    const pad = Math.min(90, (Number(bCache.radius) || 0) * 0.55);
    const thr = base + pad;

    const bounds = getStreetBounds(nodes);
    if (bCache.cx < bounds.minX - thr || bCache.cx > bounds.maxX + thr || bCache.cy < bounds.minY - thr || bCache.cy > bounds.maxY + thr){
      return false;
    }

    const d2 = polylineMinDist2(bCache.cx, bCache.cy, nodes);
    return d2 <= (thr * thr);
  }

  function getLineNameTokensForMatching(street){
    const raw = (street && street.name ? String(street.name) : '').trim();
    if (!raw) return [];
    const toks = [];

    const addTok = (v) => {
      const t = normalizeForMatch(String(v || '').toLowerCase());
      if (!t) return;
      toks.push(t);
    };

    // full name (normalized)
    addTok(raw);

    const hasSlash = /\//.test(raw);
    const rawHasLineWord = /\bline\b/i.test(raw);

    // split common separators (for names like "Norristown Line & Lansdale/Doylestown Line")
    raw.split(/\s*(?:&|\/|,|\band\b)\s*/i).forEach(part => {
      const p = String(part || '').trim();
      if (!p) return;
      if (hasSlash && rawHasLineWord && !/\bline\b/i.test(p)) {
        // Avoid overly-generic tokens like "Lansdale" by re-attaching "Line"
        addTok(p + ' Line');
      } else {
        addTok(p);
      }
    });

    // extract route-ish tokens (numbers/letter suffixes like "47", "MFL", "B", "10")
    const routeBits = raw.match(/\b\d{1,3}[a-zA-Z]?\b/g) || [];
    routeBits.forEach(b => addTok(b));

    // de-dupe & remove overly-short tokens (except pure numbers)
    const uniq = [];
    const seen = new Set();
    for (const t of toks) {
      const tt = String(t || '').trim();
      if (!tt) continue;
      const isNum = /^\d+$/.test(tt);
      if (!isNum && tt.length < 3) continue;
      if (seen.has(tt)) continue;
      seen.add(tt);
      uniq.push(tt);
    }
    return uniq;
  }

  function parseManualLineNameSet(str){
    const set = new Set();
    const raw = (str == null) ? '' : String(str);
    raw.split(/[\n,;]+/).forEach(part => {
      const p = String(part || '').trim();
      if (!p) return;
      const norm = normalizeForMatch(p.toLowerCase());
      if (norm) set.add(norm);
    });
    return set;
  }

  function tokensMatchNameSet(tokens, nameSet){
    if (!nameSet || nameSet.size === 0) return false;
    if (!Array.isArray(tokens) || tokens.length === 0) return false;
    for (const t of tokens){
      if (t && nameSet.has(t)) return true;
    }
    return false;
  }


  function __hexToRgb(hex){
    const h = String(hex || '').trim();
    let x = h.replace('#','');
    if (x.length === 3){
      x = x[0]+x[0]+x[1]+x[1]+x[2]+x[2];
    }
    if (x.length !== 6) return null;
    const r = parseInt(x.slice(0,2),16);
    const g = parseInt(x.slice(2,4),16);
    const b = parseInt(x.slice(4,6),16);
    if ([r,g,b].some(v => Number.isNaN(v))) return null;
    return {r,g,b};
  }

  function __parseColorToRgb(color){
    const c = String(color || '').trim();
    if (!c) return null;

    // hex
    if (c[0] === '#'){
      return __hexToRgb(c);
    }

    // rgb/rgba
    const m = c.match(/rgba?\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:\s*,\s*([\d.]+))?\s*\)/i);
    if (m){
      const r = Number(m[1]), g = Number(m[2]), b = Number(m[3]);
      if ([r,g,b].some(v => Number.isNaN(v))) return null;
      return { r, g, b };
    }

    return null;
  }

  // Blend a color toward white. factor=0 keeps original; factor=1 becomes white.
  function __lightenColor(color, factor){
    const f = Math.max(0, Math.min(1, Number(factor == null ? 0.45 : factor)));
    const rgb = __parseColorToRgb(color);
    if (!rgb) return String(color || '').trim();
    const r = Math.round(rgb.r + (255 - rgb.r) * f);
    const g = Math.round(rgb.g + (255 - rgb.g) * f);
    const b = Math.round(rgb.b + (255 - rgb.b) * f);
    return `rgb(${r},${g},${b})`;
  }

  function __colorToRgbaWithAlpha(color, alpha){
    const a = (alpha == null) ? 0.22 : alpha;
    const c = String(color || '').trim();
    if (!c) return null;

    // hex
    if (c[0] === '#'){
      const rgb = __hexToRgb(c);
      if (!rgb) return null;
      return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`;
    }

    // rgb/rgba
    const m = c.match(/rgba?\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:\s*,\s*([\d.]+))?\s*\)/i);
    if (m){
      const r = Number(m[1]), g = Number(m[2]), b = Number(m[3]);
      if ([r,g,b].some(v => Number.isNaN(v))) return null;
      return `rgba(${r},${g},${b},${a})`;
    }

    // fallback: if it's a css named color or something, just use it for stroke accent and keep a safe fill
    return null;
  }

  function applyStopHighlightColorToElement(el, accentColor){
    if (!el) return;

    // Clear any prior vars first so unhighlighted buildings don't retain overrides
    el.style.removeProperty('--stopAccent');
    el.style.removeProperty('--stopFill');

    const c = (accentColor || '').toString().trim();
    if (!c) return;

    el.style.setProperty('--stopAccent', c);

    // Use a high alpha so the stop actually looks "lighter" (instead of just more transparent).
    const fill = __colorToRgbaWithAlpha(c, 0.88);
    if (fill){
      el.style.setProperty('--stopFill', fill);
    } else {
      // if we can't derive a semi-transparent fill (named colors etc), just reuse the accent as fill
      el.style.setProperty('--stopFill', c);
    }
  }

  function computeStopHighlightIds(){
    stopHighlightIds = new Set();
    stopHighlightColorById = new Map();

    // Two ways a stop can be highlighted:
    //  1) via an associated line (street) selection/highlight
    //  2) directly, when the user selects the stop itself
    let streetIds = [];
    let hasStreetContext = false;
    if (selectedType === 'street' && activeStreetId) {
      streetIds = [activeStreetId];
      hasStreetContext = true;
    } else if (Array.isArray(highlightedStreetIdsForStops) && highlightedStreetIdsForStops.length) {
      streetIds = highlightedStreetIdsForStops.slice();
      hasStreetContext = true;
    }

    const streetsById = Object.create(null);
    (state.streets || []).forEach(s => { streetsById[s.id] = s; });

    const buildingCache = (state.buildings || []).map(b => {
      const label = (b.label || '').toString();
      const notes = (b.notes || '').toString();
      const type = (b.type || '').toString();
      const hayRaw = (label + ' ' + notes + ' ' + type).toLowerCase();
      const hayNorm = normalizeForMatch(hayRaw);
      const isStop = (String(type).toLowerCase() === 'public_transport') || STOP_KEYWORDS_RE.test(hayRaw);
      const geom = getBuildingCenterAndRadius(b);
      const typeLower = String(type || '').toLowerCase();
      const includeSet = parseManualLineNameSet(b.ptIncludeLines || '');
      const excludeSet = parseManualLineNameSet(b.ptExcludeLines || '');
      const baseColor = b.color || getFillForType(b.type);
      return { id: b.id, hayRaw, hayNorm, isStop, typeLower, cx: geom.cx, cy: geom.cy, radius: geom.radius, includeSet, excludeSet, baseColor };
    });

    // If the user selected a stop directly, highlight it using its own color.
    if (selectedType === 'building' && selectedId){
      const bbSel = buildingCache.find(x => x && x.id === selectedId);
      if (bbSel && bbSel.isStop){
        stopHighlightIds.add(bbSel.id);
        if (!stopHighlightColorById.has(bbSel.id)){
          stopHighlightColorById.set(bbSel.id, __lightenColor(bbSel.baseColor, 0.45));
        }
      }
    }

    // If we don't have any line context, we're done after the direct-stop highlight.
    if (!hasStreetContext) return;

    streetIds.forEach(stId => {
      const s = streetsById[stId];
      if (!s) return;

      const layer = getStreetLayer(s);
      if (layer !== 'bus' && layer !== 'rail') return;

      const tokens = getLineNameTokensForMatching(s);
      if (!tokens.length) return;
      const __addStop = (bb) => {
        if (!bb || !bb.id) return;
        stopHighlightIds.add(bb.id);
        if (!stopHighlightColorById.has(bb.id)){
          // IMPORTANT: use the stop's *own* color (lightened), not the line's color.
          stopHighlightColorById.set(bb.id, __lightenColor(bb.baseColor, 0.45));
        }
      };

      // Precompute whether this is a rail-like selection (we only use geometry for rail).
      const isRail = (layer === 'rail');

      buildingCache.forEach(bb => {
        if (stopHighlightIds.has(bb.id)) return;
        if (!bb.isStop) return;

        // Manual allow/deny list (optional, per-stop)
        const hasInclude = bb.includeSet && bb.includeSet.size > 0;
        const isIncluded = hasInclude && tokensMatchNameSet(tokens, bb.includeSet);
        const isExcluded = bb.excludeSet && bb.excludeSet.size > 0 && tokensMatchNameSet(tokens, bb.excludeSet);

        if (isExcluded) return;
        if (hasInclude){
          if (isIncluded){
            __addStop(bb);
          }
          return;
        }

        // Text match first (safe and precise, now punctuation-insensitive).
        let matched = false;
        for (const tok of tokens){
          if (tok && bb.hayNorm.includes(tok)){
            matched = true;
            break;
          }
        }

        if (matched){
          __addStop(bb);
          return;
        }

        // Geometry fallback for rail/metro/regional (to catch stations served by multiple lines
        // when the stop text doesn't list every line explicitly).
        if (isRail && shouldUseRailGeometryForBuilding({type: bb.typeLower}, bb.hayRaw)){
          if (stopNearStreet(bb, s)){
            __addStop(bb);
          }
        }
      });
    });
  }
function getFillForType(type){
    switch(type){
      case 'commercial': return 'rgba(246,194,62,0.95)';
      case 'civic': return 'rgba(110,231,183,0.95)';
      case 'vacant': return 'rgba(255,255,255,0.03)';
      case 'residential': return 'rgba(110,190,231,0.95)';
      case 'school': return 'rgba(180,120,255,0.95)';
      default: return 'rgba(255,255,255,0.06)';
    }
  }

  function createWorldGroup() {
    const g = document.createElementNS(NS, 'g');
    g.id = 'world';
    return g;
  }

  function clientToSvg(clientX, clientY){
    const pt = svg.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const screenCTM = svg.getScreenCTM();
    if (!screenCTM) return { x: clientX, y: clientY };
    const svgP = pt.matrixTransform(screenCTM.inverse());
    return { x: svgP.x, y: svgP.y };
  }

  function getWorldPoint(evt){
    // Convert a pointer/click event to coordinates in the local coordinate system of #world.
    // Using world.getScreenCTM() is more reliable than mixing svg.getScreenCTM() + world.getCTM(),
    // especially when the event target is a nested element (e.g., a path) and when viewBox/rotation are in play.
    const pt = svg.createSVGPoint();
    if (evt.touches && evt.touches.length){ pt.x = evt.touches[0].clientX; pt.y = evt.touches[0].clientY; }
    else { pt.x = evt.clientX; pt.y = evt.clientY; }

    const world = document.getElementById('world');
    const ctm = (world && world.getScreenCTM) ? world.getScreenCTM() : svg.getScreenCTM();
    if (!ctm) return { x: pt.x, y: pt.y };

    const w = pt.matrixTransform(ctm.inverse());
    return { x: w.x, y: w.y };
  }

  // =========================
  // Street editing helpers
  // =========================
  // Alt + click on a street to insert a node at the clicked location (projected onto the street polyline).
  function insertStreetNodeAtEvent(evt, streetId){
    // Alt + click: insert exactly at the clicked point in world coordinates.
    const p = getWorldPoint(evt);
    insertStreetNodeAtPoint(streetId, p);
  }

  function insertStreetNodeAtPoint(streetId, p){
    const s = (state.streets || []).find(x => x.id === streetId);
    if (!s) return;
    s.nodes = Array.isArray(s.nodes) ? s.nodes : [];

    // Ensure the street has at least 2 nodes
    if (s.nodes.length < 2){
      if (s.nodes.length === 0){
        s.nodes.push(
          { x: Math.round(p.x - 20), y: Math.round(p.y - 20) },
          { x: Math.round(p.x + 20), y: Math.round(p.y + 20) }
        );
      } else if (s.nodes.length === 1){
        s.nodes.push({ x: Math.round(p.x), y: Math.round(p.y) });
      }
      return;
    }

    // Choose insertion index by closest segment (so the new node lands in the right place in the polyline).
    let bestIdx = -1;
    let bestD2  = Infinity;

    for (let i = 0; i < s.nodes.length - 1; i++){
      const a = s.nodes[i];
      const b = s.nodes[i + 1];
      const vx = b.x - a.x;
      const vy = b.y - a.y;
      const wx = p.x - a.x;
      const wy = p.y - a.y;
      const len2 = vx*vx + vy*vy;
      if (len2 <= 1e-9) continue;

      let t = (wx*vx + wy*vy) / len2;
      if (t < 0) t = 0;
      else if (t > 1) t = 1;

      const qx = a.x + t * vx;
      const qy = a.y + t * vy;
      const dx = p.x - qx;
      const dy = p.y - qy;
      const d2 = dx*dx + dy*dy;

      if (d2 < bestD2){
        bestD2 = d2;
        bestIdx = i;
      }
    }

    if (bestIdx < 0) return;

    const newNode = { x: Math.round(p.x), y: Math.round(p.y) };

    // Avoid inserting duplicates (clicking very close to an existing node).
    const eps = 8;
    for (const n of s.nodes){
      if (Math.hypot(n.x - newNode.x, n.y - newNode.y) < eps) return;
    }

    s.nodes.splice(bestIdx + 1, 0, newNode);
  }


  function applyWorldRotation(){
    const world = document.getElementById('world');
    if (!world) return;
    const vb = svg.viewBox.baseVal;
    const cx = vb.x + vb.width/2;
    const cy = vb.y + vb.height/2;
    world.setAttribute('transform', `rotate(${worldAngle}, ${cx}, ${cy})`);
  }

function getViewBoxNumbers(){
  const vb = svg.viewBox && svg.viewBox.baseVal;
  if (vb && Number.isFinite(vb.width) && vb.width > 0 && Number.isFinite(vb.height) && vb.height > 0){
    return { x: vb.x, y: vb.y, w: vb.width, h: vb.height };
  }
  const vbStr = svg.getAttribute('viewBox') || '0 0 1000 700';
  const parts = vbStr.trim().split(/[,\s]+/).map(Number);
  return { x: parts[0] || 0, y: parts[1] || 0, w: parts[2] || 1000, h: parts[3] || 700 };
}

function getViewCenter(){
  const vb = getViewBoxNumbers();
  return { x: vb.x + vb.w / 2, y: vb.y + vb.h / 2, vb };
}

  function isBackgroundTarget(target){
    if (!target) return false;
    if (target === svg) return true;
    if (target.id === 'world') return true;
    const interactiveClasses = new Set(['building','node-handle','street']);
    if (target.closest && target.closest('#world')){
      if (target.classList){
        for (const cls of interactiveClasses){
          if (target.classList.contains(cls)) return false;
        }
      }
      return true;
    }
    return false;
  }

  // =========================
  // Building polygons (optional)
  // =========================
  // Buildings default to rectangles. If a building has a `poly` array (normalized points), it renders as a polygon.
  // Each point is {u, v} where u and v are relative to the building's width/height (0..1 is the rectangle bounds).
  function isPolyBuilding(b){
    return !!(b && Array.isArray(b.poly) && b.poly.length >= 3);
  }

  function ensureBuildingPoly(b){
    if (!b) return;
    if (!Array.isArray(b.poly) || b.poly.length < 3){
      b.poly = [
        { u: 0, v: 0 },
        { u: 1, v: 0 },
        { u: 1, v: 1 },
        { u: 0, v: 1 }
      ];
    }
  }

  function rotateAround(px, py, cx, cy, deg){
    const rad = (Number(deg) || 0) * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    const dx = px - cx;
    const dy = py - cy;
    return { x: cx + dx * cos - dy * sin, y: cy + dx * sin + dy * cos };
  }

  function unrotateAround(px, py, cx, cy, deg){
    return rotateAround(px, py, cx, cy, -(Number(deg) || 0));
  }

  function getBuildingPolyPointsString(b){
    if (!b || !Array.isArray(b.poly)) return '';
    const w = (Number(b.w) || 1);
    const h = (Number(b.h) || 1);
    return b.poly.map(p => {
      const u = Number(p && p.u);
      const v = Number(p && p.v);
      const x = b.x + (Number.isFinite(u) ? u : 0) * w;
      const y = b.y + (Number.isFinite(v) ? v : 0) * h;
      return `${x},${y}`;
    }).join(' ');
  }

  function refreshBuildingShapeUI(b){
    const rectBtn = document.getElementById('bShapeRectBtn');
    const polyBtn = document.getElementById('bShapePolyBtn');
    const addBtn  = document.getElementById('bPolyAddBtn');
    const delBtn  = document.getElementById('bPolyDelBtn');
    if (!rectBtn || !polyBtn || !addBtn || !delBtn) return;

    const hasB = !!b;
    const polyActive = hasB && isPolyBuilding(b);

    rectBtn.disabled = !hasB;
    polyBtn.disabled = !hasB;
    addBtn.disabled  = !hasB;
    delBtn.disabled  = !hasB || !polyActive || (b.poly.length <= 3);

    rectBtn.classList.toggle('drag-on', hasB && !polyActive);
    polyBtn.classList.toggle('drag-on', polyActive);
  }


  function createWrappedText(svgEl, text, bx, by, bw, bh, fontSize, lineHeight, align, orient) {
    const NS = svgEl.namespaceURI;
    const g = document.createElementNS(NS, 'g');
    const textEl = document.createElementNS(NS, 'text');

    const oneLine = (text || '').replace(/\s*\n\s*/g, ' ').trim() || '';

    textEl.setAttribute('font-size', fontSize);
    textEl.setAttribute('font-family', 'Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial');
    textEl.setAttribute('text-anchor', 'middle');
    textEl.setAttribute('pointer-events', 'none');

    const minCenterWidth = 480;
    const cx = bx + bw / 2;
    const cy = by + bh / 2;

    if (bw <= minCenterWidth) {
      textEl.setAttribute('x', cx);
      textEl.setAttribute('y', cy);
      textEl.setAttribute('dominant-baseline', 'middle');
      if (orient === 'vertical') {
        textEl.setAttribute('transform', `rotate(90 ${cx} ${cy})`);
      }
      textEl.textContent = oneLine;
      g.appendChild(textEl);
      return g;
    }

    const padding = 6;
    const pyTop = by + padding + fontSize / 2;
    const pyBottom = by + bh - padding - fontSize / 2;
    const positionY = (align === 'bottom') ? pyBottom : pyTop;

    if (orient === 'horizontal') {
      textEl.setAttribute('x', cx);
      textEl.setAttribute('y', positionY);
      textEl.setAttribute('dominant-baseline', 'middle');
      textEl.textContent = oneLine;
      g.appendChild(textEl);
      return g;
    } else {
      textEl.setAttribute('x', cx);
      textEl.setAttribute('y', positionY);
      textEl.setAttribute('dominant-baseline', 'middle');
      textEl.setAttribute('transform', `rotate(90 ${cx} ${cy})`);
      textEl.textContent = oneLine;
      g.appendChild(textEl);
      return g;
    }
  }

  function renderStreetsInto(world){
    (state.streets || []).forEach(s=>{
      if (!isLayerVisibleForStreet(s)) return;
      const layer = getStreetLayer(s);
      const nodes = s.nodes || [];
      const pathD = nodes.map((n,i) => (i===0 ? 'M' : 'L') + n.x + ' ' + n.y).join(' ');
      const path = document.createElementNS(NS,'path');
      path.setAttribute('d', pathD);
      path.setAttribute('fill', 'none');
      const strokeColor = s.color || 'rgba(60,66,72,0.95)';
      path.setAttribute('stroke', strokeColor);
      path.style.setProperty('--glowColor', strokeColor);
      path.setAttribute('stroke-width', s.width || 50);
      path.style.setProperty('--sw', (s.width || 50) + 'px');
      path.setAttribute('stroke-linecap', 'butt');
      path.setAttribute('stroke-linejoin', 'miter');
      path.classList.add('street');
      path.dataset.id = s.id;
      path.dataset.layer = layer;
      world.appendChild(path);

      const hit = document.createElementNS(NS,'path');
      hit.setAttribute('d', pathD);
      hit.setAttribute('fill','none');
      hit.setAttribute('stroke','transparent');
      hit.setAttribute('stroke-width', (s.width || 50) + 18);
      hit.style.cursor = 'pointer';
      hit.dataset.id = s.id;
      hit.dataset.layer = layer;
      hit.addEventListener('click', e => {
        e.stopPropagation();

        // Alt + click inserts a node at the clicked point (projected onto the street polyline)
        if (e.altKey) {
          e.preventDefault();
          pushHistory('Add street node');
          insertStreetNodeAtEvent(e, s.id);
          // Keep behavior consistent with normal map-click selection: select in inspector,
          // but do NOT change the active analytics group.
          selectStreet(s.id, { suppressAnalyticsSync: true });
          return;
        }

        // For map clicks, select in inspector but do NOT change the active analytics group
        selectStreet(s.id, { suppressAnalyticsSync: true });
      });

      hit.addEventListener('mousedown', e => {
        if (streetTranslateMode && !e.altKey) { e.stopPropagation(); startStreetTranslate(e, s.id); }});
      hit.addEventListener('touchstart', e => { e.stopPropagation(); if (streetTranslateMode) startStreetTranslate(e, s.id); }, {passive:false});

      world.appendChild(hit);

      if (s.name) {
        const textPathId = 'tp_' + s.id;
        path.setAttribute('id', textPathId);
        const txt = document.createElementNS(NS,'text');
        txt.dataset.layer = layer;
        txt.dataset.streetId = s.id;
        txt.style.setProperty('--glowColor', strokeColor);
        const tp = document.createElementNS(NS,'textPath');
        tp.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href', '#' + textPathId);
        tp.setAttribute('startOffset','50%');
        tp.setAttribute('text-anchor','middle');
        tp.setAttribute('fill','rgba(255,255,255,0.85)');
        tp.setAttribute('font-size',12);
        tp.textContent = s.name;
        txt.appendChild(tp);
        world.appendChild(txt);
      }
    });
  }

  function renderBuildingsInto(world){
    (state.buildings || []).forEach(b=>{
      const angle = Number(b.angle) || 0;
      const usePoly = isPolyBuilding(b);

      const el = document.createElementNS(NS, usePoly ? 'polygon' : 'rect');
      if (usePoly) {
        el.setAttribute('points', getBuildingPolyPointsString(b));
      } else {
        el.setAttribute('x', b.x); el.setAttribute('y', b.y);
        el.setAttribute('width', b.w); el.setAttribute('height', b.h);
        el.setAttribute('rx', 6); el.setAttribute('ry', 6);
      }

      el.classList.add('building');
      el.dataset.id = b.id;

      if (stopHighlightIds && stopHighlightIds.has(b.id)) {
        el.classList.add('stop-highlight');
      }
      if (selectedIds && selectedIds.has(b.id)) {
        el.classList.add('selected');
      }

      el.setAttribute('fill', b.color || getFillForType(b.type));
      el.setAttribute('stroke', b.stroke || 'rgba(0,0,0,0.6)');
      if (stopHighlightIds && stopHighlightIds.has(b.id)) {
        let c = null;
        try { if (stopHighlightColorById && stopHighlightColorById.get) c = stopHighlightColorById.get(b.id); } catch(_) {}
        applyStopHighlightColorToElement(el, c);
      }

      el.setAttribute('stroke-width', 2);
      el.style.cursor = 'move';
      el.style.pointerEvents = 'auto';

      let baseTransform = '';
      if (angle) {
        const cx = b.x + b.w / 2;
        const cy = b.y + b.h / 2;
        baseTransform = `rotate(${angle}, ${cx}, ${cy})`;
        el.setAttribute('data-base-transform', baseTransform);
        el.setAttribute('transform', baseTransform);
      } else {
        el.removeAttribute('data-base-transform');
        el.removeAttribute('transform');
      }

      el.addEventListener('mouseenter', () => {
        if (!drag && !polyPointDrag) {
          const bt = el.getAttribute('data-base-transform') || '';
          el.setAttribute('transform', bt ? bt + ' translate(0,-3)' : 'translate(0,-3)');
        }
      });
      el.addEventListener('mouseleave', () => {
        const bt = el.getAttribute('data-base-transform');
        if (bt) el.setAttribute('transform', bt);
        else el.removeAttribute('transform');
      });

      el.addEventListener('mousedown', e => {
        e.stopPropagation();
        const bt = el.getAttribute('data-base-transform');
        if (bt) el.setAttribute('transform', bt);
        else el.removeAttribute('transform');
        if (dragEnabled) startDrag(e, b);
      });
      el.addEventListener('touchstart', e => {
        e.stopPropagation();
        const bt = el.getAttribute('data-base-transform');
        if (bt) el.setAttribute('transform', bt);
        else el.removeAttribute('transform');
        if (dragEnabled) startDrag(e, b);
      }, {passive:false});

      el.addEventListener('click', e => { e.stopPropagation(); handleBuildingClick(e, b); });

      world.appendChild(el);

      const align = b.align || 'top';
      const orient = b.orient || 'horizontal';
      const labelGroup = createWrappedText(svg, b.label || '', b.x, b.y, b.w, b.h, 14, 16, align, orient);
      labelGroup.setAttribute('pointer-events','none');

      const textNodes = labelGroup.querySelectorAll('text');
      textNodes.forEach(t => t.setAttribute('fill', (b.type === 'vacant') ? 'rgba(255,255,255,0.95)' : 'rgba(0,0,0,0.9)'));

      if (angle) {
        const cx = b.x + b.w / 2;
        const cy = b.y + b.h / 2;
        labelGroup.setAttribute('transform', `rotate(${angle}, ${cx}, ${cy})`);
      }

      world.appendChild(labelGroup);
    });
  }

  function renderNodeHandlesInto(world){
    // Caller clears handlesG; we just build a fresh handles group and append it last so it stays on top.
    const handlesGroup = document.createElementNS(NS,'g');
    handlesGroup.setAttribute('id', 'nodeHandlesLayer');

    (state.streets || []).forEach(s => {
      if (s.id !== activeStreetId) return;
      (s.nodes || []).forEach((n, idx) => {
        // Large invisible hit area for easier clicking/tapping
        const hit = document.createElementNS(NS,'circle');
        hit.setAttribute('cx', n.x);
        hit.setAttribute('cy', n.y);
        hit.setAttribute('r', 34);
        hit.setAttribute('fill', 'transparent');
        hit.classList.add('node-handle','node-handle-hit');
        hit.dataset.sid = s.id;
        hit.dataset.idx = String(idx);
        hit.style.cursor = 'pointer';
        hit.style.pointerEvents = 'all';
        hit.addEventListener('mousedown', e => { e.stopPropagation(); startNodeDrag(e, s.id, idx); });
        hit.addEventListener('touchstart', e => { e.stopPropagation(); startNodeDrag(e, s.id, idx); }, { passive:false });
        handlesGroup.appendChild(hit);

        // Visible handle
        const c = document.createElementNS(NS,'circle');
        c.setAttribute('cx', n.x);
        c.setAttribute('cy', n.y);
        c.setAttribute('r', 25);
        c.setAttribute('fill', '#ffffff');
        c.classList.add('node-handle','node-handle-visual');
        c.dataset.sid = s.id;
        c.dataset.idx = String(idx);
        c.style.pointerEvents = 'none';
        handlesGroup.appendChild(c);
      });
    });

    // Building polygon point handles (only when a single polygon building is selected)
    if (selectedType === 'building' && selectedId) {
      const b = (state.buildings || []).find(x => x.id === selectedId);
      if (b && isPolyBuilding(b)) {
        const angle = Number(b.angle) || 0;
        const cx = b.x + b.w / 2;
        const cy = b.y + b.h / 2;
        const w = Number(b.w) || 1;
        const h = Number(b.h) || 1;

        (b.poly || []).forEach((pt, idx) => {
          const u = Number(pt && pt.u);
          const v = Number(pt && pt.v);
          const ax = b.x + (Number.isFinite(u) ? u : 0) * w;
          const ay = b.y + (Number.isFinite(v) ? v : 0) * h;
          const rp = angle ? rotateAround(ax, ay, cx, cy, angle) : { x: ax, y: ay };

          const hit = document.createElementNS(NS, 'circle');
          hit.setAttribute('cx', rp.x);
          hit.setAttribute('cy', rp.y);
          hit.setAttribute('r', 30);
          hit.setAttribute('fill', 'transparent');
          // Use node-handle class so svg background-click logic doesn't clear selection.
          hit.classList.add('node-handle', 'node-handle-hit');
          hit.dataset.bid = b.id;
          hit.dataset.pidx = String(idx);
          hit.style.cursor = 'pointer';
          hit.style.pointerEvents = 'all';
          hit.addEventListener('mousedown', e => { e.preventDefault(); e.stopPropagation(); startPolyPointDrag(e, b.id, idx); });
          hit.addEventListener('touchstart', e => { e.preventDefault(); e.stopPropagation(); startPolyPointDrag(e, b.id, idx); }, { passive:false });
          handlesGroup.appendChild(hit);

          const c = document.createElementNS(NS, 'circle');
          c.setAttribute('cx', rp.x);
          c.setAttribute('cy', rp.y);
          c.setAttribute('r', 18);
          c.setAttribute('fill', '#ffffff');
          c.classList.add('node-handle','node-handle-visual');
          c.style.pointerEvents = 'none';
          handlesGroup.appendChild(c);
        });
      }
    }

    world.appendChild(handlesGroup);
  }





  function hydrateTraceFromState(){
    // When loading a map from data.js, restore any saved tracing image settings
    if (!state || !state.trace) {
      // No trace settings in this state snapshot.
      // Preserve any currently-loaded tracing image so Undo/Redo doesn't unexpectedly clear it.
      const hasImg = !!traceImageUrl;

      if (traceOffsetXInput) traceOffsetXInput.value = hasImg ? String(Math.round(traceImageX)) : '';
      if (traceOffsetYInput) traceOffsetYInput.value = hasImg ? String(Math.round(traceImageY)) : '';

      const s = hasImg ? traceImageScale : 1;
      const a = hasImg ? traceImageAngle : 0;

      if (traceScaleInput) traceScaleInput.value = s;
      if (traceScaleInputBox) traceScaleInputBox.value = s;
      if (traceRotationInput) traceRotationInput.value = a;
      if (traceRotationInputBox) traceRotationInputBox.value = a;

      syncTraceVisibilityUI()
      return;
    }

    const byName = (state && state.traceByName && typeof state.traceByName === 'object') ? state.traceByName : null;
    const t = (traceImageName && byName && byName[traceImageName]) ? byName[traceImageName] : (state.trace || {});
    // Do NOT restore traceImageUrl from saved state to avoid embedding large data URLs in data.js
    // traceImageUrl is session-only; keep the currently loaded image (if any).
    traceImageVisible = (typeof t.visible === 'boolean') ? t.visible : true;
    traceImageX = (typeof t.x === 'number') ? t.x : 0;
    traceImageY = (typeof t.y === 'number') ? t.y : 0;
    traceImageBaseWidth = (typeof t.baseWidth === 'number') ? t.baseWidth : 0;
    traceImageBaseHeight = (typeof t.baseHeight === 'number') ? t.baseHeight : 0;
    traceImageScale = (typeof t.scale === 'number') ? t.scale : 1;
    traceImageAngle = (typeof t.angle === 'number') ? t.angle : 0;

    if (traceOffsetXInput) traceOffsetXInput.value = Math.round(traceImageX);
    if (traceOffsetYInput) traceOffsetYInput.value = Math.round(traceImageY);
    if (traceScaleInput) traceScaleInput.value = traceImageScale;
    if (traceScaleInputBox) traceScaleInputBox.value = traceImageScale;
    if (traceRotationInput) traceRotationInput.value = traceImageAngle;
    if (traceRotationInputBox) traceRotationInputBox.value = traceImageAngle;
    syncTraceVisibilityUI()
  }


  function applyStopHighlightClasses(){
    // Update existing SVG elements without forcing a full re-render.
    // Also apply per-stop accent coloring (based on the currently active street/route).
    const rects = svg.querySelectorAll('.building');

    rects.forEach(r => {
      r.classList.remove('stop-highlight');
      applyStopHighlightColorToElement(r, null);
    });

    if (!stopHighlightIds || !stopHighlightIds.size) return;

    stopHighlightIds.forEach(id => {
      const r = svg.querySelector('.building[data-id="' + id + '"]');
      if (r) {
        r.classList.add('stop-highlight');
        let c = null;
        try { if (stopHighlightColorById && stopHighlightColorById.get) c = stopHighlightColorById.get(id); } catch(_) {}
        applyStopHighlightColorToElement(r, c);
      }
    });
  }

  // --- Transit stop -> associated line highlighting (select a stop, highlight its line(s)) ---
  function clearStopRelatedStreetHighlight(){
    if (!stopRelatedStreetIds || !stopRelatedStreetIds.length) { stopRelatedStreetIds = []; return; }
    stopRelatedStreetIds.forEach(id => {
      const p = svg.querySelector('.street[data-id="' + id + '"]');
      if (p) p.classList.remove('stop-related');
      const t = svg.querySelector('text[data-street-id="' + id + '"]');
      if (t) t.classList.remove('stop-related');
    });
    stopRelatedStreetIds = [];
  }

  function reapplyStopRelatedStreetHighlight(){
    if (!stopRelatedStreetIds || !stopRelatedStreetIds.length) return;
    stopRelatedStreetIds.forEach(id => {
      const p = svg.querySelector('.street[data-id="' + id + '"]');
      if (p){
        p.classList.add('stop-related');
        if (p.parentNode) p.parentNode.appendChild(p);
      }
      const t = svg.querySelector('text[data-street-id="' + id + '"]');
      if (t){
        t.classList.add('stop-related');
        if (t.parentNode) t.parentNode.appendChild(t);
      }
    });
  }

  function getAssociatedStreetIdsForStopBuilding(b){
    if (!b) return [];
    const label = (b.label || '').toString();
    const notes = (b.notes || '').toString();
    const type = (b.type || '').toString();
    const hayRaw = (label + ' ' + notes + ' ' + type).toLowerCase();
    const hayNorm = normalizeForMatch(hayRaw);

    const isStop = (String(type).toLowerCase() === 'public_transport') || STOP_KEYWORDS_RE.test(hayRaw);
    if (!isStop) return [];

    // Manual overrides (optional):
    // - If Include Lines is non-empty: ONLY those lines will be considered (minus any excluded).
    // - Exclude Lines always removes matches.
    const includeSet = parseManualLineNameSet(b.ptIncludeLines || '');
    const excludeSet = parseManualLineNameSet(b.ptExcludeLines || '');

    const out = new Set();

    if (includeSet.size > 0){
      (state.streets || []).forEach(s => {
        if (!s) return;
        const layer = getStreetLayer(s);
        if (layer !== 'bus' && layer !== 'rail') return;

        const tokens = getLineNameTokensForMatching(s);
        if (!tokens.length) return;

        if (!tokensMatchNameSet(tokens, includeSet)) return;
        if (excludeSet.size > 0 && tokensMatchNameSet(tokens, excludeSet)) return;

        out.add(s.id);
      });
      return Array.from(out);
    }

    const geom = getBuildingCenterAndRadius(b);
    const bCache = { cx: geom.cx, cy: geom.cy, radius: geom.radius, hayRaw, hayNorm };

    (state.streets || []).forEach(s => {
      if (!s) return;
      const layer = getStreetLayer(s);
      if (layer !== 'bus' && layer !== 'rail') return;

      const tokens = getLineNameTokensForMatching(s);
      if (!tokens.length) return;

      let matched = false;
      for (const tok of tokens){
        if (tok && hayNorm.includes(tok)){
          matched = true;
          break;
        }
      }

      if (layer === 'bus'){
        if (matched) out.add(s.id);
        return;
      }

      // rail
      if (matched){
        out.add(s.id);
        return;
      }
      if (shouldUseRailGeometryForBuilding(b, hayRaw) && stopNearStreet(bCache, s)){
        out.add(s.id);
      }
    });

    if (excludeSet.size > 0){
      // Apply exclusions after auto matching
      Array.from(out).forEach(stId => {
        const s = (state.streets || []).find(x => x && x.id === stId);
        if (!s) return;
        const tokens = getLineNameTokensForMatching(s);
        if (tokensMatchNameSet(tokens, excludeSet)) out.delete(stId);
      });
    }

    return Array.from(out);
  }



  // --- Street highlight helpers (selection + route) ---
  function clearSelectedStreetHighlight(){
    const streetPaths = svg.querySelectorAll('.street.selected-street');
    streetPaths.forEach(p => p.classList.remove('selected-street'));
    const labels = svg.querySelectorAll('text.selected-street');
    labels.forEach(t => t.classList.remove('selected-street'));
  }

  function applySelectedStreetHighlight(id){
    clearSelectedStreetHighlight();
    if (!id) return;
    const path = svg.querySelector('.street[data-id="' + id + '"]');
    if (path) path.classList.add('selected-street');
    const label = svg.querySelector('text[data-street-id="' + id + '"]');
    if (label) label.classList.add('selected-street');
  }

  function clearRouteHighlight(){
    // Safely clear any active line/route highlight (and any stop highlights).
    try {
      const A = window.__sicaAnalytics;
      if (A && typeof A.setActiveKey === 'function') {
        A.setActiveKey(null);
        // Re-render the lists so the active item clears visually.
        if (typeof A.buildFromState === 'function') A.buildFromState();
      }
    } catch(_) {}
    try { if (typeof highlightedStreetIdsForStops !== 'undefined') highlightedStreetIdsForStops = []; } catch(_) {}
    try { if (typeof stopHighlightIds !== 'undefined') stopHighlightIds = new Set(); } catch(_) {}
    try { if (typeof stopHighlightColorById !== 'undefined') stopHighlightColorById = new Map(); } catch(_) {}

    const streetPaths = svg.querySelectorAll('.street.highlighted');
    streetPaths.forEach(p => p.classList.remove('highlighted'));
    const labelTexts = svg.querySelectorAll('text.highlighted');
    labelTexts.forEach(t => t.classList.remove('highlighted'));
    applyStopHighlightClasses();
  }

function renderAll(){
    // Keep ONLY tracing image transform settings in state so they are saved into data.js
    // We intentionally do NOT store the image data/url so data.js stays small.
    if (!state.trace) {
      state.trace = {};
    }
    state.trace.visible    = traceImageVisible;
    state.trace.x          = traceImageX;
    state.trace.y          = traceImageY;
    state.trace.baseWidth  = traceImageBaseWidth;
    state.trace.baseHeight = traceImageBaseHeight;
    state.trace.scale      = traceImageScale;
    state.trace.angle      = traceImageAngle;

    // Also persist per-image tracing presets keyed by filename (so multiple different tracing images can keep their own transform)
    if (!state.traceByName || typeof state.traceByName !== 'object') state.traceByName = {};
    if (traceImageName) {
      state.traceByName[traceImageName] = {
        visible: traceImageVisible,
        x: traceImageX,
        y: traceImageY,
        baseWidth: traceImageBaseWidth,
        baseHeight: traceImageBaseHeight,
        scale: traceImageScale,
        angle: traceImageAngle
      };
      state.traceActiveName = traceImageName;
    }


    ensureSvgLayers();

    // Update tracing image element (persistent) without rebuilding the entire SVG
    updateTraceImageElement();

    // Re-render vector layers
    streetsG.innerHTML = '';
    buildingsG.innerHTML = '';
    handlesG.innerHTML = '';

    renderStreetsInto(streetsG);
    reapplyStopRelatedStreetHighlight();
    computeStopHighlightIds();
    renderBuildingsInto(buildingsG);
    renderNodeHandlesInto(handlesG);

    applyWorldRotation();

    // Analytics panel: keep route/street lists and highlights in sync with the current state
    // (The analytics UI is implemented inside a nested IIFE; access it via window.__sicaAnalytics.)
    try {
      const A = window.__sicaAnalytics;
      if (A && typeof A.buildFromState === 'function') {
        A.buildFromState();
        const k = (typeof A.getActiveKey === 'function') ? A.getActiveKey() : null;
        const groups = (typeof A.getGroups === 'function') ? A.getGroups() : null;
        if (k && groups && groups[k] && typeof A.highlightGroup === 'function') {
          A.highlightGroup(k);
        }
      }
    } catch(_){ /* ignore analytics */ }
  }
// --- Default tracing image autoload ---
  // If a sibling image named BrooklynMap.jpg exists, load it automatically as the tracing image.
  // If it doesn't exist, keep the existing behavior (user can load a tracing image manually).
  let __defaultTraceAttempted = false;
  function attemptAutoloadDefaultTracingImage(filename){
    if (__defaultTraceAttempted) return;
    __defaultTraceAttempted = true;
    if (!filename) return;

    // Don't override an image the user already loaded in this session
    if (traceImageUrl) return;

    const probe = new Image();
    probe.onload = () => {
      // If the user loaded something while we were probing, don't override it
      if (traceImageUrl) return;

            // Use URL source (no base64). Keep hidden by default.
      traceImageName = filename;
      setTracingImageSource(filename, filename, null, false);
      traceImageVisible = false;

      // Apply any saved transform metadata for this filename (preferred),
      // otherwise fall back to the generic trace settings, and finally to the current viewBox.
      const byName = (state && state.traceByName && typeof state.traceByName === 'object') ? state.traceByName : null;
      const t = (traceImageName && byName && byName[traceImageName]) ? byName[traceImageName] : ((state && state.trace) ? state.trace : null);

      if (t && typeof t === 'object') {
        if (typeof t.x === 'number') traceImageX = t.x;
        if (typeof t.y === 'number') traceImageY = t.y;
        if (typeof t.baseWidth === 'number') traceImageBaseWidth = t.baseWidth;
        if (typeof t.baseHeight === 'number') traceImageBaseHeight = t.baseHeight;
        if (typeof t.scale === 'number') traceImageScale = t.scale;
        if (typeof t.angle === 'number') traceImageAngle = t.angle;
      }

      // Ensure the image has a usable base size so it actually renders.
      // (On a brand-new map, state.trace may exist but be empty/zeroed.)
      if (!(traceImageBaseWidth > 0 && traceImageBaseHeight > 0)) {
        const vb = svg.viewBox.baseVal;
        traceImageX = vb.x;
        traceImageY = vb.y;
        traceImageBaseWidth = vb.width;
        traceImageBaseHeight = vb.height;
        if (!(traceImageScale > 0)) traceImageScale = 1;
        if (!Number.isFinite(traceImageAngle)) traceImageAngle = 0;
      }

      syncTraceVisibilityUI();
      if (traceOffsetXInput) traceOffsetXInput.value = Math.round(traceImageX);
      if (traceOffsetYInput) traceOffsetYInput.value = Math.round(traceImageY);
      if (traceScaleInput) traceScaleInput.value = traceImageScale;
      if (traceScaleInputBox) traceScaleInputBox.value = traceImageScale;
      if (traceRotationInput) traceRotationInput.value = traceImageAngle;
      if (traceRotationInputBox) traceRotationInputBox.value = traceImageAngle;

      renderAll();
    };
    probe.onerror = () => {
      // BrooklynMap.jpg isn't present — do nothing and keep existing behavior.
    };
    probe.src = filename;
  }


  function init(){
    state = normalizeState(state);
    blockNameEl.textContent = state.blockName || 'Neighborhood';
    svg.setAttribute('viewBox', state.viewBox.join(' '));
    svg.tabIndex = 0;

    // Initialize layer toggle buttons
    const layerButtons = document.querySelectorAll('.layer-toggle');
    layerButtons.forEach(btn => {
      const layer = btn.dataset.layer;
      if (!layer) return;
      if (layerVisibility[layer]) {
        btn.classList.add('drag-on');
      } else {
        btn.classList.remove('drag-on');
      }
      btn.addEventListener('click', () => {
        layerVisibility[layer] = !layerVisibility[layer];
        if (layerVisibility[layer]) {
          btn.classList.add('drag-on');
        } else {
          btn.classList.remove('drag-on');
        }
        renderAll();
      });
    });


    // Building shape controls (rectangle by default; optional polygon + extra points)
    const bShapeRectBtn = document.getElementById('bShapeRectBtn');
    const bShapePolyBtn = document.getElementById('bShapePolyBtn');
    const bPolyAddBtn   = document.getElementById('bPolyAddBtn');
    const bPolyDelBtn   = document.getElementById('bPolyDelBtn');

    const withSelectedBuilding = (fn) => {
      if (!(selectedType === 'building' && selectedId)) return;
      const b = (state.buildings || []).find(x => x.id === selectedId);
      if (!b) return;
      fn(b);
    };

    if (bShapeRectBtn) bShapeRectBtn.addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      withSelectedBuilding((b)=>{
        if (!b.poly) return;
        pushHistory('Set building shape: rectangle');
        delete b.poly;
        renderAll();
        selectBuilding(b.id);
      });
    });

    if (bShapePolyBtn) bShapePolyBtn.addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      withSelectedBuilding((b)=>{
        if (isPolyBuilding(b)) return;
        pushHistory('Set building shape: polygon');
        ensureBuildingPoly(b);
        renderAll();
        selectBuilding(b.id);
      });
    });

    if (bPolyAddBtn) bPolyAddBtn.addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      withSelectedBuilding((b)=>{
        pushHistory('Add polygon point');
        ensureBuildingPoly(b);
        const w = Number(b.w) || 1;
        const h = Number(b.h) || 1;

        // Insert at the midpoint of the longest edge (in pixel space)
        let bestI = 0;
        let bestLen = -1;
        for (let i = 0; i < b.poly.length; i++) {
          const a = b.poly[i];
          const c = b.poly[(i + 1) % b.poly.length];
          const ax = (Number(a.u) || 0) * w;
          const ay = (Number(a.v) || 0) * h;
          const cx = (Number(c.u) || 0) * w;
          const cy = (Number(c.v) || 0) * h;
          const len = Math.hypot(cx - ax, cy - ay);
          if (len > bestLen) { bestLen = len; bestI = i; }
        }
        const p1 = b.poly[bestI];
        const p2 = b.poly[(bestI + 1) % b.poly.length];
        const nu = ((Number(p1.u) || 0) + (Number(p2.u) || 0)) / 2;
        const nv = ((Number(p1.v) || 0) + (Number(p2.v) || 0)) / 2;
        b.poly.splice(bestI + 1, 0, { u: nu, v: nv });

        renderAll();
        selectBuilding(b.id);
      });
    });

    if (bPolyDelBtn) bPolyDelBtn.addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      withSelectedBuilding((b)=>{
        if (!isPolyBuilding(b)) return;
        if (b.poly.length <= 3) return;
        pushHistory('Remove polygon point');
        b.poly.pop();
        renderAll();
        selectBuilding(b.id);
      });
    });

    // If the loaded map has a saved tracing image, restore it
    hydrateTraceFromState();
    // Default: keep the tracing image hidden on page load (even if a default image exists)
    traceImageVisible = false;
    syncTraceVisibilityUI();

    renderAll();
    updateToggleDragButton();
    attemptAutoloadDefaultTracingImage('BrooklynMap.jpg');
  }

  function startDrag(evt, b){
    evt.preventDefault();
    clearAllRectTransforms();
    const p = getWorldPoint(evt);

    const _preHistoryJson = getUndoSnapshotJson();

    if (selectedType === 'multi' && selectedIds && selectedIds.size > 1 && selectedIds.has(b.id)) {
      const ids = Array.from(selectedIds);
      const origPositions = {};
      (state.buildings || []).forEach(bb => {
        if (ids.indexOf(bb.id) !== -1) {
          origPositions[bb.id] = { x: bb.x, y: bb.y };
        }
      });
      drag = { mode: 'multi', ids, sx: p.x, sy: p.y, origPositions };
    } else {
      drag = { mode: 'single', id: b.id, sx: p.x, sy: p.y, origX: b.x, origY: b.y };
    }

    if (drag) {
      drag._historyPre = _preHistoryJson;
      drag._historyPushed = false;
      drag._historyLabel = (drag.mode === 'multi') ? 'Move buildings' : 'Move building';
    }

    window.addEventListener('mousemove', onDrag);
    window.addEventListener('touchmove', onDrag, {passive:false});
    window.addEventListener('mouseup', endDrag);
    window.addEventListener('touchend', endDrag);
  }
  function onDrag(evt){
    if (!drag) return;
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const dx = p.x - drag.sx;
    const dy = p.y - drag.sy;


    if (!drag._historyPushed && (dx !== 0 || dy !== 0)) {
      pushHistoryFromJson(drag._historyPre, drag._historyLabel);
      drag._historyPushed = true;
    }

    if (drag.mode === 'multi') {
      (drag.ids || []).forEach(id => {
        const b = (state.buildings || []).find(x => x.id === id);
        const orig = drag.origPositions && drag.origPositions[id];
        if (b && orig) {
          b.x = Math.round(orig.x + dx);
          b.y = Math.round(orig.y + dy);
        }
      });
      renderAll();
    } else {
      const b = (state.buildings || []).find(x => x.id === drag.id);
      if (!b) return;
      b.x = Math.round(drag.origX + dx);
      b.y = Math.round(drag.origY + dy);
      if (selectedId === b.id && selectedType === 'building'){
        const bxEl = document.getElementById('bX');
        const byEl = document.getElementById('bY');
        if (bxEl) bxEl.value = b.x;
        if (byEl) byEl.value = b.y;
      }
      renderAll();
    }
  }
  function endDrag(){
    if (!drag) return;
    drag = null;
    clearAllRectTransforms();
    window.removeEventListener('mousemove', onDrag);
    window.removeEventListener('touchmove', onDrag);
    window.removeEventListener('mouseup', endDrag);
    window.removeEventListener('touchend', endDrag);
  }

function clearAllRectTransforms(){
    const els = svg.querySelectorAll('rect.building, polygon.building');
    els.forEach(r => {
      const bt = r.getAttribute('data-base-transform');
      if (bt) r.setAttribute('transform', bt);
      else r.removeAttribute('transform');
    });
  }

  function syncStreetInspectorGeometry(s){
    if (!s) return;
    if (!(selectedType === 'street' && selectedId === s.id)) return;
    const nodes = s.nodes || [];
    let gx = 0, gy = 0;
    if (nodes.length >= 1) {
      gx = nodes[0].x;
      gy = nodes[0].y;
    }
    const len = computeStreetEndToEndLength(s) || 0;
    const widthVal = s.width || 60;
    let angleDeg = 0;
    if (nodes.length >= 2) {
      const first = nodes[0];
      const last = nodes[nodes.length - 1];
      const dx = last.x - first.x;
      const dy = last.y - first.y;
      const ang = Math.atan2(dy, dx) * 180 / Math.PI;
      if (Number.isFinite(ang)) angleDeg = ang;
    }
    const gxEl = document.getElementById('streetGX');
    const gyEl = document.getElementById('streetGY');
    const lenEl = document.getElementById('streetGW');
    const widthEl = document.getElementById('streetGH');
    const angleEl = document.getElementById('streetAngle');
    if (gxEl) gxEl.value = Math.round(gx);
    if (gyEl) gyEl.value = Math.round(gy);
    if (lenEl) lenEl.value = Math.round(len);
    if (widthEl) widthEl.value = Math.round(widthVal);
    if (angleEl) angleEl.value = angleDeg.toFixed(1);
  }

function startNodeDrag(evt, streetId, idx){
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const _preHistoryJson = getUndoSnapshotJson();
    const s = (state.streets || []).find(x => x.id === streetId);
    if(!s || !s.nodes || s.nodes.length <= idx) return;
    const n = s.nodes[idx];
    nodeDrag = { streetId, nodeIdx: idx, sx: p.x, sy: p.y, origX: n.x, origY: n.y, _historyPre: _preHistoryJson, _historyPushed: false };
    window.addEventListener('mousemove', onNodeDrag);
    window.addEventListener('touchmove', onNodeDrag, {passive:false});
    window.addEventListener('mouseup', endNodeDrag);
    window.addEventListener('touchend', endNodeDrag);
  }
  function onNodeDrag(evt){
    if(!nodeDrag) return;
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const dx = p.x - nodeDrag.sx;
    const dy = p.y - nodeDrag.sy;

    if (!nodeDrag._historyPushed && (dx !== 0 || dy !== 0)) {
      pushHistoryFromJson(nodeDrag._historyPre, 'Move street node');
      nodeDrag._historyPushed = true;
    }
    const s = (state.streets || []).find(x => x.id === nodeDrag.streetId);
    if(!s) return;
    const idx = nodeDrag.nodeIdx;
    s.nodes[idx].x = Math.round(nodeDrag.origX + dx);
    s.nodes[idx].y = Math.round(nodeDrag.origY + dy);

    // Keep street inspector geometry/angle in sync while dragging nodes
    syncStreetInspectorGeometry(s);

    renderAll();
  }
  function endNodeDrag(){
    if(!nodeDrag) return;
    nodeDrag = null;
    window.removeEventListener('mousemove', onNodeDrag);
    window.removeEventListener('touchmove', onNodeDrag);
    window.removeEventListener('mouseup', endNodeDrag);
    window.removeEventListener('touchend', endNodeDrag);
  }


  function startPolyPointDrag(evt, buildingId, idx){
    evt.preventDefault();
    evt.stopPropagation();

    const b = (state.buildings || []).find(x => x.id === buildingId);
    if (!b || !Array.isArray(b.poly) || b.poly.length <= idx) return;

    const p0 = getWorldPoint(evt);
    const _preHistoryJson = getUndoSnapshotJson();

    const angle = Number(b.angle) || 0;
    const cx = b.x + b.w / 2;
    const cy = b.y + b.h / 2;
    const w = Number(b.w) || 1;
    const h = Number(b.h) || 1;

    // Compute current vertex world position (matches the rendered handle position).
    const curr = b.poly[idx] || { u: 0, v: 0 };
    const cu = Number(curr.u); const cv = Number(curr.v);
    const ax = b.x + (Number.isFinite(cu) ? cu : 0) * w;
    const ay = b.y + (Number.isFinite(cv) ? cv : 0) * h;
    const rp = angle ? rotateAround(ax, ay, cx, cy, angle) : { x: ax, y: ay };

    // IMPORTANT: keep the grab offset so the point doesn't "snap" under the cursor.
    const offx = p0.x - rp.x;
    const offy = p0.y - rp.y;

    polyPointDrag = {
      id: buildingId,
      idx,
      offx,
      offy,
      _historyPre: _preHistoryJson,
      _historyPushed: false
    };

    window.addEventListener('mousemove', onPolyPointDrag);
    window.addEventListener('touchmove', onPolyPointDrag, {passive:false});
    window.addEventListener('mouseup', endPolyPointDrag);
    window.addEventListener('touchend', endPolyPointDrag);
  }

  function onPolyPointDrag(evt){
    if (!polyPointDrag) return;
    evt.preventDefault();

    const b = (state.buildings || []).find(x => x.id === polyPointDrag.id);
    if (!b || !Array.isArray(b.poly) || b.poly.length <= polyPointDrag.idx) return;

    const p = getWorldPoint(evt);

    const angle = Number(b.angle) || 0;
    const cx = b.x + b.w / 2;
    const cy = b.y + b.h / 2;

    // Apply the grab offset so dragging is stable and doesn't jump.
    const tx = p.x - (Number(polyPointDrag.offx) || 0);
    const ty = p.y - (Number(polyPointDrag.offy) || 0);

    // Convert dragged world point back into the unrotated building-local frame.
    const q = angle ? unrotateAround(tx, ty, cx, cy, angle) : { x: tx, y: ty };

    const w = Number(b.w) || 1;
    const h = Number(b.h) || 1;

    let u = (q.x - b.x) / w;
    let v = (q.y - b.y) / h;

    if (!Number.isFinite(u)) u = 0;
    if (!Number.isFinite(v)) v = 0;

    // Keep values sane but give plenty of freedom so it doesn't feel "stuck".
    u = Math.max(-10, Math.min(10, u));
    v = Math.max(-10, Math.min(10, v));

    const prev = b.poly[polyPointDrag.idx] || { u: 0, v: 0 };
    if (!polyPointDrag._historyPushed && (u !== prev.u || v !== prev.v)) {
      pushHistoryFromJson(polyPointDrag._historyPre, 'Move polygon point');
      polyPointDrag._historyPushed = true;
    }

    b.poly[polyPointDrag.idx] = { u, v };

    renderAll();
  }

  function endPolyPointDrag(){
    if (!polyPointDrag) return;
    polyPointDrag = null;
    window.removeEventListener('mousemove', onPolyPointDrag);
    window.removeEventListener('touchmove', onPolyPointDrag);
    window.removeEventListener('mouseup', endPolyPointDrag);
    window.removeEventListener('touchend', endPolyPointDrag);
  }

  function startStreetTranslate(evt, streetId) {
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const _preHistoryJson = getUndoSnapshotJson();
    const s = (state.streets || []).find(x => x.id === streetId);
    if (!s) return;
    streetTranslateDrag = {
      streetId,
      sx: p.x,
      sy: p.y,
      origNodes: s.nodes.map(n => ({ x: n.x, y: n.y })),
      _historyPre: _preHistoryJson,
      _historyPushed: false
    };
    window.addEventListener('mousemove', onStreetTranslate);
    window.addEventListener('touchmove', onStreetTranslate, {passive:false});
    window.addEventListener('mouseup', endStreetTranslate);
    window.addEventListener('touchend', endStreetTranslate);
  }
  function onStreetTranslate(evt) {
    if (!streetTranslateDrag) return;
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const dx = p.x - streetTranslateDrag.sx;
    const dy = p.y - streetTranslateDrag.sy;

    if (!streetTranslateDrag._historyPushed && (dx !== 0 || dy !== 0)) {
      pushHistoryFromJson(streetTranslateDrag._historyPre, 'Move street');
      streetTranslateDrag._historyPushed = true;
    }
    const s = (state.streets || []).find(x => x.id === streetTranslateDrag.streetId);
    if (!s) return;
    s.nodes.forEach((n, i) => {
      n.x = Math.round(streetTranslateDrag.origNodes[i].x + dx);
      n.y = Math.round(streetTranslateDrag.origNodes[i].y + dy);
    });

    // Keep street inspector geometry/angle in sync while translating street
    syncStreetInspectorGeometry(s);

    renderAll();
  }
  function endStreetTranslate() {
    if (!streetTranslateDrag) return;
    streetTranslateDrag = null;
    window.removeEventListener('mousemove', onStreetTranslate);
    window.removeEventListener('touchmove', onStreetTranslate);
    window.removeEventListener('mouseup', endStreetTranslate);
    window.removeEventListener('touchend', endStreetTranslate);
  }




function refreshInspectorTitle(label){
      const el = document.getElementById('inspectorTitle');
      if (el) el.textContent = (label && String(label).trim()) ? label : 'Building';
    }

function showMultiInspector(){
    noSelection.style.display = 'none';
    form.style.display = 'block';
    removeStreetInspector();
    const setup = document.getElementById('setup');
    const fill = document.getElementById('fill');
    if (setup) setup.style.display = 'none';
    if (fill) fill.style.display = 'none';
    const tEl = document.getElementById('inspectorTitle');
    if (tEl) {
      const count = selectedIds.size || 0;
      tEl.textContent = count > 1 ? (count + ' items selected') : 'Item';
    }

    refreshQuickEditBar();
  }

  function selectBuilding(id){
    selectedId = id; selectedType = 'building'; activeStreetId = null;
    clearSelectedStreetHighlight();
    clearStopRelatedStreetHighlight();
    selectedIds.clear();
    selectedIds.add(id);
    const b = (state.buildings || []).find(x => x.id === id);
    if(!b) return;

    // If a transit stop is selected, highlight its associated line(s)
    try {
      stopRelatedStreetIds = getAssociatedStreetIdsForStopBuilding(b);
    } catch(_){ stopRelatedStreetIds = []; }

    noSelection.style.display = 'none'; form.style.display = 'block';
    removeStreetInspector();
    const setup = document.getElementById('setup');
    const fill = document.getElementById('fill');
    if (setup) setup.style.display = '';
    if (fill) fill.style.display = '';
    document.getElementById('bLabel').value = b.label || '';
    document.getElementById('bType').value = b.type || 'other';
    document.getElementById('bColor').value = toHexColor(b.color || getFillForType(b.type));
    document.getElementById('bAlign').value = b.align || 'top';
    document.getElementById('bOrient').value = b.orient || 'horizontal';
    document.getElementById('bOcc').value = b.occupants || '';
    document.getElementById('bNotes').value = b.notes || '';

    // Public transport line overrides (manual include/exclude)
    const ptWrap = document.getElementById('ptLineOverrides');
    const incEl = document.getElementById('bIncludeLines');
    const excEl = document.getElementById('bExcludeLines');
    const isPT = String(b.type || '').toLowerCase() === 'public_transport';
    if (ptWrap) ptWrap.style.display = isPT ? '' : 'none';
    if (incEl) incEl.value = isPT ? (b.ptIncludeLines || '') : '';
    if (excEl) excEl.value = isPT ? (b.ptExcludeLines || '') : '';

    document.getElementById('bUsage').value = b.usage || 'none';
    document.getElementById('bFunding').value = b.funding || 'none';
    document.getElementById('bX').value = b.x;
    document.getElementById('bY').value = b.y;
    document.getElementById('bW').value = b.w;
    document.getElementById('bH').value = b.h;
    const bAngleEl = document.getElementById('bAngle');
    if (bAngleEl) bAngleEl.value = (typeof b.angle === 'number') ? b.angle : (b.angle || 0);
    refreshBuildingShapeUI(b);

    const tEl = document.getElementById('inspectorTitle');
    if (tEl) tEl.textContent = (b.label && String(b.label).trim()) ? b.label : 'Building';
    const lblEl = document.getElementById('bLabel');
    if (lblEl) {
      lblEl.oninput = null;
      lblEl.addEventListener('input', function(){
        if (tEl) tEl.textContent = (this.value && String(this.value).trim()) ? this.value : 'Building';
      });
    }
    renderAll();
    refreshQuickEditBar();
  }

  function handleBuildingClick(evt, b){
    // switching selection modes should clear any stop->line highlight
    clearStopRelatedStreetHighlight();
    const multiKey = evt.shiftKey || evt.metaKey || evt.ctrlKey;
    if (multiKey){
      if (selectedIds.has(b.id)){
        selectedIds.delete(b.id);
      } else {
        selectedIds.add(b.id);
      }

      if (selectedIds.size === 0){
        selectedId = null;
        selectedType = null;
        activeStreetId = null;
        form.style.display = 'none';
        noSelection.style.display = 'block';
        removeStreetInspector();
      } else if (selectedIds.size === 1){
        const onlyId = Array.from(selectedIds)[0];
        selectBuilding(onlyId);
        return;
      } else {
        selectedId = null;
        selectedType = 'multi';
        activeStreetId = null;
        showMultiInspector();
      }
      renderAll();
      refreshQuickEditBar();
    } else {
      selectedIds.clear();
      selectBuilding(b.id);
    }
  }

  function selectStreet(id, opts){
    opts = opts || {};
    clearStopRelatedStreetHighlight();
    selectedIds.clear();
    selectedId = id; selectedType = 'street'; activeStreetId = id;
    noSelection.style.display = 'none'; form.style.display = 'none';
    injectStreetInspector((state.streets || []).find(s => s.id === id));

    renderAll();
    applySelectedStreetHighlight(id);
    refreshQuickEditBar();

    // Selecting a street from the inspector should activate the corresponding analytics group
    // unless the caller explicitly suppresses it (used for map-click selection).
    if (!opts.suppressAnalyticsSync) {
      // The analytics UI is implemented inside a nested IIFE; access it via window.__sicaAnalytics.
      try {
        const A = window.__sicaAnalytics;
        if (A && typeof A.syncSelectionToStreet === 'function') {
          A.syncSelectionToStreet(id);
        }
      } catch(_){ /* ignore analytics */ }
    }
  }

  function removeStreetInspector(){
    const old = document.getElementById('streetInspector'); if(old) old.remove();
  }

  function injectStreetInspector(s){
    removeStreetInspector();
    if(!s) return;
    const inspector = document.getElementById('inspector');
    const prevInfo = inspector ? inspector.querySelector('#streetInfo') : null;
    const prevSetup = inspector ? inspector.querySelector('#streetSetup') : null;
    if (prevInfo) lastStreetInfoOpen = !!prevInfo.open;
    if (prevSetup) lastStreetSetupOpen = !!prevSetup.open;

    const stub = document.createElement('div'); stub.id = 'streetInspector'; stub.style.marginTop='12px';
    const currentLen = computeStreetEndToEndLength(s);
    let gx = 0, gy = 0;
    let gw = currentLen || 0;
    let gh = s.width || 60;
    if (Array.isArray(s.nodes) && s.nodes.length >= 1) {
      gx = s.nodes[0].x;
      gy = s.nodes[0].y;
    }
    let streetAngleDeg = 0;
    if (Array.isArray(s.nodes) && s.nodes.length >= 2) {
      const first = s.nodes[0];
      const last = s.nodes[s.nodes.length - 1];
      const dx = last.x - first.x;
      const dy = last.y - first.y;
      const ang = Math.atan2(dy, dx) * 180 / Math.PI;
      if (Number.isFinite(ang)) streetAngleDeg = ang;
    }
    stub.innerHTML = `
      <h3 id="streetInspectorTitle" style="margin:6px 0">${escapeHtml(s.name||'Street')}</h3>

      <!-- STREETS: Top actions row -->
      <div class="street-actions" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0">
        <button id="toggleTranslateBtn" class="tool-btn muted-btn ${streetTranslateMode ? 'drag-on' : ''}">${streetTranslateMode ? 'Drag: On' : 'Drag: Off'}</button>
        <button class="tool-btn" id="saveStreetBtn">Save</button>
        <button class="tool-btn muted-btn" id="copyStreetBtn">Copy</button>
        <button class="tool-btn muted-btn" id="pasteStreetBtn">Paste</button>
        <button class="tool-btn" id="deleteStreetBtn" style="background:var(--danger);color:white">Delete</button>
      </div>



      <details id="streetSetup">
        <summary>Street Set Up</summary>
        <label class="small">Color</label>
        <input id="streetColor" type="color" value="${toHexColor(s.color || 'rgba(60,66,72,0.95)')}" />
        <label class="small">Geometry (x, y, Length, Width)</label>
        <div style="display:flex;gap:6px">
          <input id="streetGX" type="text" value="${Math.round(gx)}" />
          <input id="streetGY" type="text" value="${Math.round(gy)}" />
          <input id="streetGW" type="text" value="${Math.round(gw)}" />
          <input id="streetGH" type="text" value="${Math.round(gh)}" />
        </div>
        <label class="small">Angle (°)</label>
        <input id="streetAngle" type="text" value="${streetAngleDeg.toFixed(1)}" />
        <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
          <button id="addNodeStartBtn" class="muted-btn">Add Node Start</button>
          <button id="addNodeEndBtn" class="muted-btn">Add Node End</button>
          <button id="delNodeBtn" class="muted-btn" style="background:var(--danger);color:white" ${ (s.nodes && s.nodes.length > 2) ? "" : "disabled" }>Delete node</button>
        </div>

      <!-- Layer order controls -->
      <div class="street-layer" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0">
        <span class="small" style="margin-right:6px">Layer:</span>
        <button id="layerUpBtn" class="muted-btn" title="Move one step toward front">Up</button>
        <button id="layerDownBtn" class="muted-btn" title="Move one step toward back">Down</button>
        <button id="layerFrontBtn" class="muted-btn" title="Bring to front">Front</button>
        <button id="layerBackBtn" class="muted-btn" title="Send to back">Back</button>
      </div>
      </details>
      <details id="streetInfo">
        <summary>Street Info</summary>
        <label class="small">Name</label>
        <input id="streetName" type="text" value="${escapeHtml(s.name||'')}" />
        <label class="small">Notes</label>
        <textarea id="streetNotes" rows="3">${escapeHtml((s.notes||''))}</textarea>
      </details>
    `;
    const traceSection = inspector ? inspector.querySelector('#traceTools') : null;
    if (traceSection && traceSection.parentNode === inspector){
      inspector.insertBefore(stub, traceSection);
    } else {
      inspector.appendChild(stub);
    }
    const streetTitleEl = document.getElementById('streetInspectorTitle');
    const streetNameEl = document.getElementById('streetName');
    if (streetTitleEl && streetNameEl) {
      streetTitleEl.textContent = (streetNameEl.value && streetNameEl.value.trim()) ? streetNameEl.value : 'Street';
      streetNameEl.addEventListener('input', function(){
        streetTitleEl.textContent = (this.value && String(this.value).trim()) ? this.value : 'Street';
      });
    }

    const _info = stub.querySelector('#streetInfo');
    const _setup = stub.querySelector('#streetSetup');
    if (_info) { _info.open = !!lastStreetInfoOpen; _info.addEventListener('toggle', ()=>{ lastStreetInfoOpen = _info.open; }); }
    if (_setup) { _setup.open = !!lastStreetSetupOpen; _setup.addEventListener('toggle', ()=>{ lastStreetSetupOpen = _setup.open; }); }

    const tb = document.getElementById('toggleTranslateBtn');
    if (typeof updateStreetDragButton === 'function') updateStreetDragButton();
    if (tb) {
      tb.addEventListener('click', (evt) => { 
        evt.preventDefault(); evt.stopPropagation(); 
        streetTranslateMode = !streetTranslateMode; dragEnabled = streetTranslateMode; tb.textContent = streetTranslateMode ? 'Drag: On' : 'Drag: Off'; if (streetTranslateMode) tb.classList.add('drag-on'); else tb.classList.remove('drag-on'); updateToggleDragButton(); activeStreetId = s.id;
        renderAll();
      });
    }

    document.getElementById('saveStreetBtn').addEventListener('click', (evt)=>{ evt.preventDefault(); evt.stopPropagation();
      pushHistory('Edit street'); 
      s.name = document.getElementById('streetName').value;
      { const st = document.getElementById('streetInspectorTitle'); if (st) st.textContent = (s.name && String(s.name).trim()) ? s.name : 'Street'; }
      const _notesEl = document.getElementById('streetNotes'); if(_notesEl){ s.notes = _notesEl.value; }
      s.color = document.getElementById('streetColor').value;
      const gxVal = Number(document.getElementById('streetGX').value);
      const gyVal = Number(document.getElementById('streetGY').value);
      const lenVal = Number(document.getElementById('streetGW').value);
      const geomWidthVal = Number(document.getElementById('streetGH').value);

      // Apply X,Y,Length edits assuming a mostly two-node street (segment)
      if (Array.isArray(s.nodes) && s.nodes.length >= 2) {
        const nodes = s.nodes;
        const first = nodes[0];

        // Move street so first node is at (gx, gy)
        if (!Number.isNaN(gxVal) && !Number.isNaN(gyVal)) {
          const dx = gxVal - first.x;
          const dy = gyVal - first.y;
          for (let i = 0; i < nodes.length; i++) {
            nodes[i].x = Math.round(nodes[i].x + dx);
            nodes[i].y = Math.round(nodes[i].y + dy);
          }
        }

        // Adjust length along current direction (anchor at first node)
        if (lenVal > 0 && !Number.isNaN(lenVal)) {
          const a = nodes[0];
          const b = nodes[nodes.length - 1];
          const curDx = b.x - a.x;
          const curDy = b.y - a.y;
          const curLen = Math.sqrt(curDx * curDx + curDy * curDy);
          if (curLen > 0) {
            const scale = lenVal / curLen;
            const newBx = a.x + curDx * scale;
            const newBy = a.y + curDy * scale;
            b.x = Math.round(newBx);
            b.y = Math.round(newBy);
          }
        }
      } else if (Array.isArray(s.nodes) && s.nodes.length === 1) {
        if (!Number.isNaN(gxVal) && !Number.isNaN(gyVal)) {
          s.nodes[0].x = Math.round(gxVal);
          s.nodes[0].y = Math.round(gyVal);
        }
      }

      // Determine street width purely from the Geometry Width field
      let newWidth = s.width;
      if (!Number.isNaN(geomWidthVal) && geomWidthVal > 0) {
        newWidth = geomWidthVal;
      }
      s.width = newWidth;

      // Keep the Geometry Width input in sync with the street width
      const widthGeomEl = document.getElementById('streetGH');
      if (widthGeomEl) widthGeomEl.value = String(Math.round(newWidth));

      const angleEl = document.getElementById('streetAngle');
      if (angleEl && Array.isArray(s.nodes) && s.nodes.length >= 2) {
        const targetDeg = Number(angleEl.value);
        if (!Number.isNaN(targetDeg)) {
          const first = s.nodes[0];
          const cx = first.x;
          const cy = first.y;
          const last = s.nodes[s.nodes.length - 1];
          const dx = last.x - cx;
          const dy = last.y - cy;
          const currentRad = Math.atan2(dy, dx);
          const targetRad = targetDeg * Math.PI / 180;
          const delta = targetRad - currentRad;
          const cosD = Math.cos(delta);
          const sinD = Math.sin(delta);
          for (let i = 1; i < s.nodes.length; i++) {
            const node = s.nodes[i];
            const rx = (node.x - cx) * cosD - (node.y - cy) * sinD;
            const ry = (node.x - cx) * sinD + (node.y - cy) * cosD;
            node.x = Math.round(cx + rx);
            node.y = Math.round(cy + ry);
          }
        }
      }
      renderAll();
    });

    document.getElementById('deleteStreetBtn').addEventListener('click', (evt)=>{ evt.preventDefault(); evt.stopPropagation(); 
      if(!confirm('Delete this street?')) return;
      pushHistory('Delete street');
      state.streets = (state.streets || []).filter(x => x.id !== s.id);
      removeStreetInspector(); activeStreetId = null; renderAll();
    });

    const addNodeStartBtn = document.getElementById('addNodeStartBtn');
    if (addNodeStartBtn) addNodeStartBtn.addEventListener('click', (evt)=>{ evt.preventDefault(); evt.stopPropagation();
      pushHistory('Add street node (start)');
      streetNodeLastSide[s.id] = 'start';
      s.nodes = s.nodes || [];
      if (s.nodes.length === 0) {
        s.nodes.push({ x: 200, y: 200 }, { x: 240, y: 220 });
      } else if (s.nodes.length === 1) {
        const a = s.nodes[0] || { x: 200, y: 200 };
        s.nodes.unshift({ x: a.x - 40, y: a.y - 20 });
      } else {
        const a = s.nodes[0];
        const b = s.nodes[1];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const len = Math.hypot(dx, dy) || 1;
        const step = 40;
        const ux = dx / len;
        const uy = dy / len;
        s.nodes.unshift({ x: Math.round(a.x + ux * step), y: Math.round(a.y + uy * step) });
      }
      renderAll();
      injectStreetInspector(s);
    });

    const addNodeEndBtn = document.getElementById('addNodeEndBtn');
    if (addNodeEndBtn) addNodeEndBtn.addEventListener('click', (evt)=>{ evt.preventDefault(); evt.stopPropagation();
      pushHistory('Add street node (end)');
      streetNodeLastSide[s.id] = 'end';
      s.nodes = s.nodes || [];
      if (s.nodes.length === 0) {
        s.nodes.push({ x: 200, y: 200 }, { x: 240, y: 220 });
      } else if (s.nodes.length === 1) {
        const a = s.nodes[0] || { x: 200, y: 200 };
        s.nodes.push({ x: a.x + 40, y: a.y + 20 });
      } else {
        const a = s.nodes[s.nodes.length - 1];
        const b = s.nodes[s.nodes.length - 2];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const len = Math.hypot(dx, dy) || 1;
        const step = 40;
        const ux = dx / len;
        const uy = dy / len;
        s.nodes.push({ x: Math.round(a.x + ux * step), y: Math.round(a.y + uy * step) });
      }
      renderAll();
      injectStreetInspector(s);
    });

    const copyStreetBtn = document.getElementById('copyStreetBtn');
    if (copyStreetBtn) {
      copyStreetBtn.addEventListener('click', (evt)=>{ 
        evt.preventDefault(); 
        evt.stopPropagation(); 
        clipboard = { kind: 'street', data: JSON.parse(JSON.stringify(s)) };

      });
    }

    const pasteStreetBtn = document.getElementById('pasteStreetBtn');
    if (pasteStreetBtn) {
      pasteStreetBtn.addEventListener('click', (evt)=>{ 
        evt.preventDefault(); 
        evt.stopPropagation(); 
        if (!clipboard || clipboard.kind !== 'street' || !clipboard.data) {
          alert('No street in the clipboard.');
          return;
        }
        const orig = clipboard.data;
        const id = 's' + Date.now() + Math.floor(Math.random() * 1000);
        const offset = 25;
        const newStreet = Object.assign({}, orig, {
          id,
          nodes: (orig.nodes || []).map(n => ({
            x: (n.x || 0) + offset,
            y: (n.y || 0) + offset
          }))
        });
        state.streets = state.streets || [];
        state.streets.push(newStreet);
        renderAll();
        selectStreet(id);
      });
    }

    const delBtn = document.getElementById('delNodeBtn');
    if (delBtn) delBtn.addEventListener('click', (evt)=>{ evt.preventDefault(); evt.stopPropagation();
      if (!Array.isArray(s.nodes) || s.nodes.length <= 2) return;
      pushHistory('Remove street node');
      const side = streetNodeLastSide[s.id] || 'end';
      if (side === 'start') s.nodes.shift();
      else s.nodes.pop();
      renderAll();
      injectStreetInspector(s);
    });

    // Layer order wiring
    document.getElementById('layerUpBtn').addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); moveStreet('up', s.id); });
    document.getElementById('layerDownBtn').addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); moveStreet('down', s.id); });
    document.getElementById('layerFrontBtn').addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); moveStreet('front', s.id); });
    document.getElementById('layerBackBtn').addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); moveStreet('back', s.id); });
  }

  // --- layer order helper ---
  function moveStreet(dir, id){
    const arr = state.streets || [];
    const i = arr.findIndex(s => s.id === id);
    if (i < 0) return;

    const swap = (a, b) => { const t = arr[a]; arr[a] = arr[b]; arr[b] = t; };

    if (dir === 'up' && i < arr.length - 1) swap(i, i + 1);
    else if (dir === 'down' && i > 0) swap(i, i - 1);
    else if (dir === 'front' && i < arr.length - 1) { const [s] = arr.splice(i,1); arr.push(s); }
    else if (dir === 'back' && i > 0) { const [s] = arr.splice(i,1); arr.unshift(s); }

    renderAll();
    injectStreetInspector(arr.find(s => s.id === id));
    activeStreetId = id;
  }

  function computeStreetLength(st) {
    if (!st || !Array.isArray(st.nodes) || st.nodes.length === 0) return 0;
    let len = 0;
    for (let i = 1; i < st.nodes.length; i++) {
      const a = st.nodes[i-1];
      const b = st.nodes[i];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      len += Math.hypot(dx, dy);
    }
    return len;
  }

  // Straight-line (end-to-end) length from first to last node.
  // Used for the Street Set Up "Length" control so saving name/notes doesn't distort polylines.
  function computeStreetEndToEndLength(st) {
    if (!st || !Array.isArray(st.nodes) || st.nodes.length < 2) return 0;
    const a = st.nodes[0];
    const b = st.nodes[st.nodes.length - 1];
    return Math.hypot(b.x - a.x, b.y - a.y);
  }


  function computeStreetBBox(st) {
    if (!st || !Array.isArray(st.nodes) || !st.nodes.length) return null;
    let minX = st.nodes[0].x, maxX = st.nodes[0].x, minY = st.nodes[0].y, maxY = st.nodes[0].y;
    for (let i = 1; i < st.nodes.length; i++) {
      const n = st.nodes[i];
      if (n.x < minX) minX = n.x;
      if (n.x > maxX) maxX = n.x;
      if (n.y < minY) minY = n.y;
      if (n.y > maxY) maxY = n.y;
    }
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }




  // Toggle public transport override fields when changing building type in inspector
  (function(){
    const bTypeEl = document.getElementById('bType');
    const ptWrap = document.getElementById('ptLineOverrides');
    if (bTypeEl && ptWrap){
      bTypeEl.addEventListener('change', () => {
        const isPT = String(bTypeEl.value || '').toLowerCase() === 'public_transport';
        ptWrap.style.display = isPT ? '' : 'none';
        if (!isPT){
          const incEl = document.getElementById('bIncludeLines');
          const excEl = document.getElementById('bExcludeLines');
          if (incEl) incEl.value = '';
          if (excEl) excEl.value = '';
        }
      });
    }
  })();


  document.getElementById('saveBtn').addEventListener('click', ()=>{
    if(selectedType !== 'building' || !selectedId) return;
    const b = (state.buildings || []).find(x=>x.id===selectedId);
    if(!b) return;
    pushHistory('Edit building');
    b.label = document.getElementById('bLabel').value;
    b.type  = document.getElementById('bType').value;
    b.color = document.getElementById('bColor').value;
    b.align = document.getElementById('bAlign').value || 'top';
    b.orient = document.getElementById('bOrient').value || 'horizontal';
    b.occupants = document.getElementById('bOcc').value;
    b.notes = document.getElementById('bNotes').value;

    // Public transport overrides
    if (String(b.type || '').toLowerCase() === 'public_transport'){
      const incEl = document.getElementById('bIncludeLines');
      const excEl = document.getElementById('bExcludeLines');
      b.ptIncludeLines = incEl ? String(incEl.value || '') : '';
      b.ptExcludeLines = excEl ? String(excEl.value || '') : '';
    }

    b.usage = document.getElementById('bUsage').value;
    b.funding = document.getElementById('bFunding').value;
 b.x = Number(document.getElementById('bX').value) || b.x;
 b.y = Number(document.getElementById('bY').value) || b.y;
    const bAngleEl = document.getElementById('bAngle');
    if (bAngleEl) {
      const aVal = Number(bAngleEl.value);
      if (!Number.isNaN(aVal)) b.angle = aVal;
    }
    refreshInspectorTitle(b.label);
    b.w = Number(document.getElementById('bW').value) || b.w;
        b.h = Number(document.getElementById('bH').value) || b.h;
        // Precompute stop->line highlighting BEFORE re-render so the current SVG rebuild
    // uses the latest include/exclude overrides (prevents needing to press Save twice).
    try {
      if (selectedType === 'building' && selectedId === b.id) {
        stopRelatedStreetIds = getAssociatedStreetIdsForStopBuilding(b);
      }
    } catch(_) {}
    renderAll();
});

  document.getElementById('deleteBtn').addEventListener('click', ()=>{
    if (selectedType === 'building' && selectedId) {
      if (!confirm('Delete this building?')) return;
      pushHistory('Delete building');
      state.buildings = (state.buildings || []).filter(x => x.id !== selectedId);
      selectedId = null;
      selectedType = null;
      selectedIds.clear();
      form.style.display = 'none';
      noSelection.style.display = 'block';
      activeStreetId = null;
      try { clearSelectedStreetHighlight(); } catch(_) {}
      try { clearRouteHighlight(); } catch(_) {}
      renderAll();
    } else if (selectedType === 'multi' && selectedIds && selectedIds.size > 0) {
      if (!confirm('Delete ' + selectedIds.size + ' buildings?')) return;
      pushHistory('Delete buildings');
      const idsToDelete = new Set(selectedIds);
      state.buildings = (state.buildings || []).filter(x => !idsToDelete.has(x.id));
      selectedId = null;
      selectedType = null;
      selectedIds.clear();
      form.style.display = 'none';
      noSelection.style.display = 'block';
      activeStreetId = null;
      try { clearSelectedStreetHighlight(); } catch(_) {}
      try { clearRouteHighlight(); } catch(_) {}
      renderAll();
    }
  });



  document.getElementById('copyBuildingBtn').addEventListener('click', ()=>{
    if (selectedType === 'building' && selectedId) {
      const b = (state.buildings || []).find(x => x.id === selectedId);
      if (!b) return;
      clipboard = { kind: 'building', data: JSON.parse(JSON.stringify(b)) };

    } else if (selectedType === 'multi' && selectedIds && selectedIds.size > 0) {
      const buildings = (state.buildings || []).filter(bb => selectedIds.has(bb.id));
      if (!buildings.length) {
        alert('No buildings selected to copy.');
        return;
      }
      clipboard = { kind: 'building-multi', data: JSON.parse(JSON.stringify(buildings)) };

    } else {
      alert('Select a building first to copy.');
    }
  });

  document.getElementById('pasteBuildingBtn').addEventListener('click', ()=>{
    pushHistory('Paste building');
    if (!clipboard || !clipboard.data) {
      alert('No building in the clipboard.');
      return;
    }
    const offset = 25;
    state.buildings = state.buildings || [];
    const newIds = [];

    if (clipboard.kind === 'building') {
      const orig = clipboard.data;
      const id = 'b' + Date.now() + Math.floor(Math.random() * 1000);
      const b = Object.assign({}, orig, {
        id,
        x: (orig.x || 0) + offset,
        y: (orig.y || 0) + offset
      });
      state.buildings.push(b);
      newIds.push(id);
    } else if (clipboard.kind === 'building-multi') {
      const origArr = clipboard.data || [];
      let i = 0;
      origArr.forEach(orig => {
        const id = 'b' + Date.now() + Math.floor(Math.random() * 1000) + '_' + (i++);
        const b = Object.assign({}, orig, {
          id,
          x: (orig.x || 0) + offset,
          y: (orig.y || 0) + offset
        });
        state.buildings.push(b);
        newIds.push(id);
      });
    } else {
      alert('Clipboard does not contain buildings.');
      return;
    }

    renderAll();

    if (newIds.length === 1) {
      selectBuilding(newIds[0]);
    } else if (newIds.length > 1) {
      selectedIds.clear();
      newIds.forEach(id => selectedIds.add(id));
      selectedId = null;
      selectedType = 'multi';
      activeStreetId = null;
      showMultiInspector();
      renderAll();
    }
  });


toggleDragBtn.addEventListener('click', ()=>{
    dragEnabled = !dragEnabled;
    streetTranslateMode = dragEnabled;
    updateToggleDragButton();
    if (typeof updateStreetDragButton === 'function') updateStreetDragButton();
    renderAll();
  });
  function updateToggleDragButton(){
    if (dragEnabled){
      toggleDragBtn.textContent = 'Drag: On';
      toggleDragBtn.classList.add('drag-on');
    } else {
      toggleDragBtn.textContent = 'Drag: Off';
      toggleDragBtn.classList.remove('drag-on');
    }
  }

  // Keep the street inspector 'Drag' button UI in sync
  function updateStreetDragButton(){
    const tb = document.getElementById('toggleTranslateBtn');
    if (!tb) return;
    tb.textContent = streetTranslateMode ? 'Drag: On' : 'Drag: Off';
    if (streetTranslateMode) tb.classList.add('drag-on'); else tb.classList.remove('drag-on');
  }


document.getElementById('addBuildingBtn').addEventListener('click', ()=>{
  pushHistory('Add building');
  const id = 'b' + Date.now();
  const defaultType = 'residential';

  const w = 120;
  const h = 90;
  const { x: cx, y: cy } = getViewCenter();

  const b = {
    id,
    x: Math.round(cx - w/2),
    y: Math.round(cy - h/2),
    w,
    h,
    label: 'New Building',
    type: defaultType,
    occupants: '',
    color: getFillForType(defaultType),
    stroke: 'rgba(0,0,0,0.6)',
    align: 'top',
    orient: 'horizontal'
  };
  state.buildings = state.buildings || [];
  state.buildings.push(b);

  renderAll();
  selectBuilding(id);
});


document.getElementById('addStreetBtn').addEventListener('click', ()=>{
  pushHistory('Add street');
  const id = 's' + Date.now();
  const { x: cx, y: cy, vb } = getViewCenter();

  // Create a short segment that scales with the current zoom level
  const seg = Math.max(140, Math.min(400, (vb.w || 1000) * 0.30));
  const half = seg / 2;

  const s = {
    id,
    name: 'New Street',
    width: 60,
    color: 'rgba(60,66,72,0.95)',
    nodes: [
      { x: Math.round(cx - half), y: Math.round(cy) },
      { x: Math.round(cx + half), y: Math.round(cy) }
    ]
  };
  state.streets = state.streets || [];
  state.streets.push(s);

  renderAll();
  selectStreet(id);
});

  document.getElementById('downloadBtn').addEventListener('click', ()=>{
    // Clone state so we can strip out any tracing image URL/data before saving
    const stateToSave = JSON.parse(JSON.stringify(state));
    if (stateToSave.trace && stateToSave.trace.url) {
      delete stateToSave.trace.url;
    }
    // Stamp metadata into the saved file so we can compare against autosave on future loads
    const now = Date.now();
    if (typeof window.MAP_META !== 'object' || !window.MAP_META) window.MAP_META = {};
    if (mapNameDisplayEl && mapNameDisplayEl.textContent) window.MAP_META.name = String(mapNameDisplayEl.textContent).trim();
    window.MAP_META.savedAt = now;
    currentFileSavedAt = now;
    const content =
      'window.MAP_META = ' + JSON.stringify(window.MAP_META, null, 2) + ';\n' +
      'window.MAP_DATA = ' + JSON.stringify(stateToSave, null, 2) + ';';
    const blob = new Blob([content], { type: 'text/javascript' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'data.js';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    // Update autosave + indicator at the moment of manual save
    try {
      writeAutosave({
        v: AUTOSAVE_VERSION,
        ts: now,
        reason: 'manual-save',
        mapId: getCurrentMapId(),
        fileSavedAt: currentFileSavedAt || 0,
        state: stateToSave
      });
    } catch(_) {}
    setAutosaveIndicator(now);
    setRestorePromptVisible(false);
  });

  document.getElementById('fileInput').addEventListener('change', (e) => {
    const f = e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        let text = String(reader.result || '').trim();
        let loaded = null;
        // Support both JS (data.js) and raw JSON exports
        if (/window\.MAP_DATA/.test(text) || /window\.MAP_META/.test(text)) {
          (function(){ eval(text); })();
          loaded = window.MAP_DATA;
          // Update current file-saved timestamp if present in the loaded file
          currentFileSavedAt = Number((window.MAP_META && window.MAP_META.savedAt) || 0) || 0;
        } else {
          loaded = JSON.parse(text);
        }
        if (!loaded) throw new Error('Could not extract MAP data from file');
        loaded = normalizeState(loaded);
        state = loaded;
        undoStack.length = 0;
        redoStack.length = 0;
        updateUndoRedoUI();
        blockNameEl.textContent = formatFileDisplayName(f.name) || (state.blockName || 'Neighborhood');
        if (state.viewBox && Array.isArray(state.viewBox) && state.viewBox.length === 4) {
          svg.setAttribute('viewBox', state.viewBox.join(' '));
        }

        // Restore any tracing image settings stored in the loaded data
        hydrateTraceFromState();

        renderAll();
        refreshAutosaveUI(true);

      } catch (err) {
        console.error(err);
        alert('Failed to load file: ' + (err && err.message ? err.message : String(err)));
      }
    };
    reader.readAsText(f);
  });

  svg.addEventListener('click', (e) => {
    if (didPan) { didPan = false; e.preventDefault(); e.stopPropagation(); return; }
    if (isBackgroundTarget(e.target)){
      selectedId = null; selectedType = null; activeStreetId = null;
      if (selectedIds) selectedIds.clear();
      form.style.display = 'none'; noSelection.style.display = 'block';
      removeStreetInspector();
      clearSelectedStreetHighlight();
      clearStopRelatedStreetHighlight();
      clearRouteHighlight();
      renderAll();
      refreshQuickEditBar();
    }
  });

  const zoomFactor = 2.50;
  document.getElementById('zoomInBtn').addEventListener('click', ()=>{
    const vb = svg.viewBox.baseVal;
    const w = vb.width / zoomFactor;
    const h = vb.height / zoomFactor;
    const cx = vb.x + vb.width/2;
    const cy = vb.y + vb.height/2;
    svg.setAttribute('viewBox', `${cx - w/2} ${cy - h/2} ${w} ${h}`);
    applyWorldRotation();
  });
  document.getElementById('zoomOutBtn').addEventListener('click', ()=>{
    const vb = svg.viewBox.baseVal;
    const w = vb.width * zoomFactor;
    const h = vb.height * zoomFactor;
    const cx = vb.x + vb.width/2;
    const cy = vb.y + vb.height/2;
    svg.setAttribute('viewBox', `${cx - w/2} ${cy - h/2} ${w} ${h}`);
    applyWorldRotation();
  });

  // Pseudo fullscreen: hide Inspector + Lines & Routes (not OS fullscreen)
  const pseudoFullscreenBtn = document.getElementById('pseudoFullscreenBtn');
  let pseudoFullscreenOn = false;

    // Keep the map from "jumping" when focus mode changes the SVG size and/or
  // its on-screen position. We anchor the *same map point* to the *same screen pixel*
  // (the SVG's on-screen center), while preserving the existing on-screen zoom scale.
  //
  // This is robust even if the map panel moves (e.g., top/left changes) and even if the
  // world is rotated (worldAngle), because we solve the viewBox so the same world point
  // stays under the same screen coordinate.
  function __captureSvgAnchor(){
    try {
      const vb = svg.viewBox && svg.viewBox.baseVal;
      const rect = svg.getBoundingClientRect();
      const ctm = (svg.getScreenCTM && svg.getScreenCTM());
      if (!vb || !rect || !ctm) return null;

      const scale = Math.hypot(ctm.a, ctm.b); // px per user-unit (uniform with preserveAspectRatio meet)
      if (!(scale > 0) || !(rect.width > 0) || !(rect.height > 0) || !(vb.width > 0) || !(vb.height > 0)) return null;

      // Anchor at the SVG's on-screen center
      const ax = rect.left + rect.width / 2;
      const ay = rect.top + rect.height / 2;

      // Screen -> SVG user space (root)
      const pt = svg.createSVGPoint();
      pt.x = ax; pt.y = ay;
      const inv = ctm.inverse();
      const U = pt.matrixTransform(inv); // user units in the root SVG coord system

      // Undo world rotation to get the *unrotated* world point P that visually appears at (ax,ay)
      const ang = (typeof worldAngle === 'number' ? worldAngle : 0) * Math.PI / 180;
      const cx = vb.x + vb.width / 2;
      const cy = vb.y + vb.height / 2;

      const dx = U.x - cx;
      const dy = U.y - cy;

      const c = Math.cos(-ang);
      const s = Math.sin(-ang);

      const Px = cx + dx * c - dy * s;
      const Py = cy + dx * s + dy * c;

      return { ax, ay, scale, P: { x: Px, y: Py }, angleRad: ang };
    } catch(_) { return null; }
  }

  function __applyAnchorKeepScale(before){
    try {
      if (!before) return;
      const rect = svg.getBoundingClientRect();
      if (!(rect.width > 0) || !(rect.height > 0) || !(before.scale > 0)) return;

      // Choose a viewBox that yields the SAME px-per-unit scale, and also matches the
      // SVG's aspect ratio so there is no letterboxing offset.
      const vbW = rect.width / before.scale;
      const vbH = rect.height / before.scale;
      if (!(vbW > 0) || !(vbH > 0)) return;

      // Desired location of the (ax,ay) anchor within the SVG, expressed in user units
      const Sx = (before.ax - rect.left) / before.scale;
      const Sy = (before.ay - rect.top) / before.scale;

      const Dx = vbW / 2;
      const Dy = vbH / 2;

      // Rotation matrix for worldAngle
      const ang = before.angleRad || 0;
      const c = Math.cos(ang);
      const s = Math.sin(ang);

      // (I - R) * D
      const IRDx = (1 - c) * Dx + s * Dy;
      const IRDy = (-s) * Dx + (1 - c) * Dy;

      // T = (I - R)D - S
      const Tx = IRDx - Sx;
      const Ty = IRDy - Sy;

      // R^{-1} * T (R^{-1} is transpose for rotation)
      const RinTx = c * Tx + s * Ty;
      const RinTy = -s * Tx + c * Ty;

      // Solve for the new viewBox origin V = [x,y]
      const vbX = before.P.x + RinTx;
      const vbY = before.P.y + RinTy;

      if (!Number.isFinite(vbX) || !Number.isFinite(vbY) || !Number.isFinite(vbW) || !Number.isFinite(vbH)) return;

      svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`);
      try { if (state && Array.isArray(state.viewBox)) state.viewBox = [vbX, vbY, vbW, vbH]; } catch(_) {}

      applyWorldRotation();
      scheduleTraceLODUpdate();
    } catch(_) {}
  }

  function setPseudoFullscreen(on){
    const before = __captureSvgAnchor();

    pseudoFullscreenOn = !!on;
    document.body.classList.toggle('pseudo-fullscreen', pseudoFullscreenOn);

    // Safety: don't leave mobile overlays stuck open if viewport changes
    document.body.classList.remove('mobile-pane-info','mobile-pane-analytics');

    if (pseudoFullscreenBtn){
      pseudoFullscreenBtn.setAttribute('aria-pressed', pseudoFullscreenOn ? 'true' : 'false');
      pseudoFullscreenBtn.textContent = pseudoFullscreenOn ? 'Exit' : 'Full';
      pseudoFullscreenBtn.title = pseudoFullscreenOn ? 'Exit focus mode' : 'Focus mode (hide Inspector + Lines & Routes)';
      if (pseudoFullscreenOn) pseudoFullscreenBtn.classList.add('drag-on');
      else pseudoFullscreenBtn.classList.remove('drag-on');
    }


    // Apply immediately (the getBoundingClientRect() inside forces layout before the next paint),
    // which prevents a one-frame flash of the "wrong" map area during the panel resize.
    __applyAnchorKeepScale(before);
}

  if (pseudoFullscreenBtn){
    pseudoFullscreenBtn.addEventListener('click', ()=>{
      setPseudoFullscreen(!pseudoFullscreenOn);
    });
  }

  window.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape' && pseudoFullscreenOn){
      setPseudoFullscreen(false);
    }
  });


  const rotateButtons = document.querySelectorAll(".rotate-btn");
  rotateButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      worldAngle = Number(btn.dataset.angle);
      applyWorldRotation();
      try { svg.focus(); } catch (err) {}
    });
  });

  function panView(dx, dy){
    ;[dx, dy] = adjustForRotation(dx, dy);

    if (worldAngle === 90) { const t = dx; dx = dy; dy = -t; }
    else if (worldAngle === -90) { const t = dx; dx = -dy; dy = t; }
    else if (worldAngle === 180 || worldAngle === -180) { dx = -dx; dy = -dy; }

    const vb = svg.viewBox.baseVal;
    const nx = vb.x + dx;
    const ny = vb.y + dy;
    svg.setAttribute('viewBox', `${nx} ${ny} ${vb.width} ${vb.height}`);
    applyWorldRotation();
  }
  window.addEventListener('keydown', (e) => {
    const tag = document.activeElement && document.activeElement.tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;
    const step = 50;
    if (e.key === 'ArrowLeft'){ panView(-step, 0); e.preventDefault(); }
    else if (e.key === 'ArrowRight'){ panView(step, 0); e.preventDefault(); }
    else if (e.key === 'ArrowUp'){ panView(0, -step); e.preventDefault(); }
    else if (e.key === 'ArrowDown'){ panView(0, step); e.preventDefault(); }
  });

  function pixelDeltaToViewBoxDelta(dxPx, dyPx){
    const vb = svg.viewBox.baseVal;
    const rect = svg.getBoundingClientRect();
    const dx = dxPx * (vb.width / rect.width);
    const dy = dyPx * (vb.height / rect.height);
    return { dx, dy };
  }


  // Mouse pan (disabled when tracing image drag is on)
  svg.addEventListener('mousedown', (e) => {
    if (typeof traceDragMode !== 'undefined' && traceDragMode) return;

    didPan = false;
    if (!isBackgroundTarget(e.target)) {
      if (e.target.id !== 'world') return;
    }

    const vb = svg.viewBox.baseVal;
    panDrag = {
      sx: e.clientX,
      sy: e.clientY,
      orig: [vb.x, vb.y, vb.width, vb.height]
    };

    svg.classList.add('dragging');
    window.addEventListener('mousemove', onPanDrag);
    window.addEventListener('mouseup', endPanDrag);
  });

  // Touch pan + pinch (also disabled when tracing drag is on)
  svg.addEventListener('touchstart', (e) => {
    if (typeof traceDragMode !== 'undefined' && traceDragMode) return;

    didPan = false;

    // Pinch start (two fingers)
    if (e.touches && e.touches.length === 2) {
      e.preventDefault();
      const t0 = e.touches[0];
      const t1 = e.touches[1];
      const dx = t1.clientX - t0.clientX;
      const dy = t1.clientY - t0.clientY;
      const dist = Math.hypot(dx, dy);
      const midX = (t0.clientX + t1.clientX) / 2;
      const midY = (t0.clientY + t1.clientY) / 2;

      pinchState = {
        lastDist: dist,
        lastCenterClient: { x: midX, y: midY }
      };

      try { svg.focus(); } catch (err) {}
      window.addEventListener('touchmove', onPinchMove, { passive: false });
      window.addEventListener('touchend', onPinchEnd);
      return;
    }

    // Single-finger pan
    if (!e.touches || e.touches.length !== 1) return;
    const t = e.target;
    if (!isBackgroundTarget(t) && t.id !== 'world') return;

    const vb = svg.viewBox.baseVal;
    panDrag = {
      sx: e.touches[0].clientX,
      sy: e.touches[0].clientY,
      orig: [vb.x, vb.y, vb.width, vb.height]
    };

    svg.classList.add('dragging');
    window.addEventListener('touchmove', onPanDrag, { passive: false });
    window.addEventListener('touchend', endPanDrag);
  }, { passive: false });

  function onPanDrag(e) {
    didPan = true;
    if (!panDrag) return;

    e.preventDefault();

    let cx, cy;
    if (e.touches && e.touches.length) {
      cx = e.touches[0].clientX;
      cy = e.touches[0].clientY;
    } else {
      cx = e.clientX;
      cy = e.clientY;
    }

    const dxPx = cx - panDrag.sx;
    const dyPx = cy - panDrag.sy;
    const rotatedPx = adjustForRotation(dxPx, dyPx);
    const delta = pixelDeltaToViewBoxDelta(rotatedPx[0], rotatedPx[1]);

    const vb = svg.viewBox.baseVal;
    const nx = panDrag.orig[0] - delta.dx;
    const ny = panDrag.orig[1] - delta.dy;

    svg.setAttribute('viewBox', `${nx} ${ny} ${vb.width} ${vb.height}`);
    applyWorldRotation();
  }

  function endPanDrag() {
    if (!panDrag) return;

    panDrag = null;
    svg.classList.remove('dragging');
    window.removeEventListener('mousemove', onPanDrag);
    window.removeEventListener('mouseup', endPanDrag);
    window.removeEventListener('touchmove', onPanDrag);
    window.removeEventListener('touchend', endPanDrag);
  }

  function onPinchMove(e) {
    if (!pinchState || !e.touches || e.touches.length < 2) return;

    e.preventDefault();
    const t0 = e.touches[0];
    const t1 = e.touches[1];
    const dx = t1.clientX - t0.clientX;
    const dy = t1.clientY - t0.clientY;
    const dist = Math.hypot(dx, dy);
    if (!dist || !pinchState.lastDist) return;

    const midX = (t0.clientX + t1.clientX) / 2;
    const midY = (t0.clientY + t1.clientY) / 2;

    const pinchSensitivity = 1.4;
    const perFrameScale = dist / pinchState.lastDist;
    const adjustedPerFrame = Math.pow(perFrameScale, pinchSensitivity);

    const vb = svg.viewBox.baseVal;
    const currW = vb.width;
    const currH = vb.height;

    let newW = currW / adjustedPerFrame;
    let newH = currH / adjustedPerFrame;

    const MIN_W = 20;
    const MAX_W = 80000;
    if (newW < MIN_W) newW = MIN_W;
    if (newW > MAX_W) newW = MAX_W;
    newH = (newW * currH) / currW;

    const svgPt = clientToSvg(midX, midY);
    const relX = (svgPt.x - vb.x) / currW;
    const relY = (svgPt.y - vb.y) / currH;

    const newX = svgPt.x - relX * newW;
    const newY = svgPt.y - relY * newH;

    svg.setAttribute('viewBox', `${newX} ${newY} ${newW} ${newH}`);
    applyWorldRotation();
    scheduleTraceLODUpdate();

    pinchState.lastDist = dist;
    pinchState.lastCenterClient.x = midX;
    pinchState.lastCenterClient.y = midY;
  }

  function onPinchEnd(e) {
    pinchState = null;
    window.removeEventListener('touchmove', onPinchMove);
    window.removeEventListener('touchend', onPinchEnd);
  }

  svg.addEventListener('wheel', function onWheel(e){
    const tag = document.activeElement && document.activeElement.tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

    if (e.ctrlKey) {
      e.preventDefault();

      const vb = svg.viewBox.baseVal;
      const currW = vb.width;
      const currH = vb.height;

      const zoomSensitivity = 0.0025;
      const factor = Math.exp(e.deltaY * zoomSensitivity);

      let newW = currW * factor;
      let newH = currH * factor;

      const MIN_W = 20;
      const MAX_W = 80000;
      if (newW < MIN_W) newW = MIN_W;
      if (newW > MAX_W) newW = MAX_W;
      newH = newW * currH / currW;

      const clientX = (e.clientX !== undefined) ? e.clientX : (svg.getBoundingClientRect().left + svg.getBoundingClientRect().width/2);
      const clientY = (e.clientY !== undefined) ? e.clientY : (svg.getBoundingClientRect().top + svg.getBoundingClientRect().height/2);

      const svgPt = clientToSvg(clientX, clientY);

      const relX = (svgPt.x - vb.x) / currW;
      const relY = (svgPt.y - vb.y) / currH;

      const newX = svgPt.x - relX * newW;
      const newY = svgPt.y - relY * newH;

      svg.setAttribute('viewBox', `${newX} ${newY} ${newW} ${newH}`);
      applyWorldRotation();
      scheduleTraceLODUpdate();
      return;
    }

    e.preventDefault();

    const dxPx = e.deltaX;
    const dyPx = e.deltaY;

    const rotatedPx = adjustForRotation(dxPx, dyPx);

    const delta = pixelDeltaToViewBoxDelta(rotatedPx[0], rotatedPx[1]);
    const vb = svg.viewBox.baseVal;
    const nx = vb.x + delta.dx;
    const ny = vb.y + delta.dy;
    svg.setAttribute('viewBox', `${nx} ${ny} ${vb.width} ${vb.height}`);
    applyWorldRotation();
  }, { passive: false });

  function normalizeState(s){
    const sane = Object.assign({}, s || {});
    sane.blockName = sane.blockName || 'Neighborhood';
    sane.viewBox = Array.isArray(sane.viewBox) && sane.viewBox.length === 4 ? sane.viewBox.slice() : [0,0,1000,700];
    sane.buildings = Array.isArray(sane.buildings) ? sane.buildings.map(normalizeBuilding) : [];
    sane.streets = Array.isArray(sane.streets) ? sane.streets.map(normalizeStreet) : [];
    return sane;
  }
  function normalizeBuilding(b){
    const nb = Object.assign({}, b || {});
    nb.id = nb.id || ('b' + Date.now() + Math.floor(Math.random()*1000));
    nb.x = Number(nb.x) || 0;
    nb.y = Number(nb.y) || 0;
    nb.w = Number(nb.w) || 40;
    nb.h = Number(nb.h) || 30;
    nb.angle = Number(nb.angle) || 0;
    nb.label = nb.label || '';
    nb.type = nb.type || 'other';
    nb.color = nb.color || getFillForType(nb.type);
    nb.stroke = nb.stroke || 'rgba(0,0,0,0.6)';
    nb.occupants = nb.occupants || '';
    nb.align = nb.align || 'top';
    nb.orient = nb.orient || 'horizontal';
    nb.notes = nb.notes || '';
    nb.usage = nb.usage || 'none';
    nb.funding = nb.funding || 'none';

    if (Array.isArray(nb.poly)) {
      const pts = nb.poly.map(p => ({
        u: Number(p && (p.u != null ? p.u : p.x)),
        v: Number(p && (p.v != null ? p.v : p.y))
      })).filter(p => Number.isFinite(p.u) && Number.isFinite(p.v));
      if (pts.length >= 3) nb.poly = pts;
      else delete nb.poly;
    }

    return nb;
  }
  function normalizeStreet(s){
    const ns = Object.assign({}, s || {});
    ns.id = ns.id || ('s' + Date.now() + Math.floor(Math.random()*1000));
    ns.name = ns.name || '';
    ns.width = Number(ns.width) || 60;
    ns.color = ns.color || 'rgba(60,66,72,0.95)';
    ns.nodes = Array.isArray(ns.nodes) ? ns.nodes.map(n => ({ x: Number(n.x) || 0, y: Number(n.y) || 0 })) : [{ x: 100, y: 100 }, { x: 400, y: 100 }];
    return ns;
  }
  function escapeHtml(s){ return String(s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;'); }
  function toHexColor(c){
    if(!c) return '#ffffff';
    c = String(c);
    if(c[0] === '#') return c;
    const m = c.match(/rgba?\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})/i);
    if(m){
      const r = Number(m[1]), g = Number(m[2]), b = Number(m[3]);
      return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
    }
    return '#ffffff';
  }
  function formatFileDisplayName(filename) {
    if (!filename) return 'Neighborhood';
    const short = String(filename).split('/').pop().split('\\\\').pop();
    const dot = short.lastIndexOf('.');
    const base = dot > 0 ? short.slice(0, dot) : short;
    return base.replace(/_/g, ' ');
  }


  // === Tracing image controls ===
  if (traceInput) {
    traceInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      // Use a blob URL (no base64) and keep the original File so we can generate safe downsampled proxies.
      const url = URL.createObjectURL(file);

      // Keep the image data only in memory; do NOT put it in state so data.js stays small.
      // IMPORTANT: We do NOT immediately decode full-res on mobile. We start with an LOD proxy.
      traceImageVisible = true;
      traceImageName = file.name || '';

      // Restore transform settings for this filename (so it snaps back to previous position/scale/rotation).
      const byName = state && state.traceByName ? state.traceByName : null;
      const t = (traceImageName && byName && byName[traceImageName]) ? byName[traceImageName] : (state && state.trace ? state.trace : null);

      if (t) {
        if (typeof t.x === 'number') traceImageX = t.x;
        if (typeof t.y === 'number') traceImageY = t.y;
        if (typeof t.baseWidth === 'number') traceImageBaseWidth = t.baseWidth;
        if (typeof t.baseHeight === 'number') traceImageBaseHeight = t.baseHeight;
        if (typeof t.scale === 'number') traceImageScale = t.scale;
        if (typeof t.angle === 'number') traceImageAngle = t.angle;
      } else {
        // Fall back to initializing placement to current viewBox
        const vb = svg.viewBox.baseVal;
        traceImageX = vb.x;
        traceImageY = vb.y;
        traceImageBaseWidth = vb.width;
        traceImageBaseHeight = vb.height;
        traceImageScale = 1;
        traceImageAngle = 0;
      }

      // Ensure usable base size so the image renders (especially on a fresh map)
      if (!(traceImageBaseWidth > 0 && traceImageBaseHeight > 0)) {
        const vb = svg.viewBox.baseVal;
        traceImageX = vb.x;
        traceImageY = vb.y;
        traceImageBaseWidth = vb.width;
        traceImageBaseHeight = vb.height;
        if (!(traceImageScale > 0)) traceImageScale = 1;
        if (!Number.isFinite(traceImageAngle)) traceImageAngle = 0;
      }

      syncTraceVisibilityUI();
      if (traceOffsetXInput) traceOffsetXInput.value = Math.round(traceImageX);
      if (traceOffsetYInput) traceOffsetYInput.value = Math.round(traceImageY);
      if (traceScaleInput) traceScaleInput.value = traceImageScale;
      if (traceScaleInputBox) traceScaleInputBox.value = traceImageScale;
      if (traceRotationInput) traceRotationInput.value = traceImageAngle;
      if (traceRotationInputBox) traceRotationInputBox.value = traceImageAngle;

      // Set source (keeps File object for safe downsample decode)
      setTracingImageSource(url, traceImageName, file, true);

      renderAll();            // ensures layers exist + draws current selection
      scheduleTraceLODUpdate(); // pick an LOD proxy immediately
    });
  }

  if (traceRotationInput) {
    traceRotationInput.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v)) {
        traceImageAngle = v;
        renderAll();
      }
    });
  }

  if (traceRotationInputBox) {
    traceRotationInputBox.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v)) {
        traceImageAngle = v;
        if (traceRotationInput) traceRotationInput.value = v;
        renderAll();
      }
    });
  }

  if (traceToggleBtn) {
    traceToggleBtn.addEventListener('click', (e) => {
      e.preventDefault();
      traceImageVisible = !traceImageVisible;
      syncTraceVisibilityUI();
      renderAll();
          if (traceImageVisible) scheduleTraceLODUpdate();
});
  }

  if (mapTraceBtn) {
    mapTraceBtn.addEventListener('click', (e) => {
      e.preventDefault();
      traceImageVisible = !traceImageVisible;
      syncTraceVisibilityUI();
      renderAll();
          if (traceImageVisible) scheduleTraceLODUpdate();
});
  }


  if (traceOffsetXInput) {
    traceOffsetXInput.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v)) {
        traceImageX = v;
        renderAll();
      }
    });
  }

  if (traceOffsetYInput) {
    traceOffsetYInput.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v)) {
        traceImageY = v;
        renderAll();
      }
    });
  }

  if (traceScaleInput) {
    traceScaleInput.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v) && v > 0) {
        traceImageScale = v;
        if (traceScaleInputBox) traceScaleInputBox.value = v;
        renderAll();
      }
    });
  }

  if (traceScaleInputBox) {
    traceScaleInputBox.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v) && v > 0) {
        traceImageScale = v;
        if (traceScaleInput) traceScaleInput.value = v;
        renderAll();
      }
    });
  }

  if (traceDragBtn) {
    traceDragBtn.addEventListener('click', () => {
      traceDragMode = !traceDragMode;
      traceDragBtn.textContent = traceDragMode ? 'Drag image: On' : 'Drag image: Off';
      renderAll();
    });
  }

  function startTraceDrag(evt) {
    if (!traceImageUrl) return;
    evt.preventDefault();
    const p = getWorldPoint(evt);
    traceDrag = { sx: p.x, sy: p.y, origX: traceImageX, origY: traceImageY };
    window.addEventListener('mousemove', onTraceDrag);
    window.addEventListener('touchmove', onTraceDrag, { passive: false });
    window.addEventListener('mouseup', endTraceDrag);
    window.addEventListener('touchend', endTraceDrag);
  }

  function onTraceDrag(evt) {
    if (!traceDrag) return;
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const dx = p.x - traceDrag.sx;
    const dy = p.y - traceDrag.sy;
    traceImageX = traceDrag.origX + dx;
    traceImageY = traceDrag.origY + dy;
    if (traceOffsetXInput) traceOffsetXInput.value = Math.round(traceImageX);
    if (traceOffsetYInput) traceOffsetYInput.value = Math.round(traceImageY);
    renderAll();
  }

  function endTraceDrag() {
    if (!traceDrag) return;
    traceDrag = null;
    window.removeEventListener('mousemove', onTraceDrag);
    window.removeEventListener('touchmove', onTraceDrag);
    window.removeEventListener('mouseup', endTraceDrag);
    window.removeEventListener('touchend', endTraceDrag);
  }

  // Only allow starting a trace drag when trace drag mode is on and the tracing image is hit
  svg.addEventListener('mousedown', (e) => {
    if (!traceDragMode || !traceImageUrl) return;
    if (e.target && e.target.id === 'traceImageLayer') {
      startTraceDrag(e);
    }
  });

  svg.addEventListener('touchstart', (e) => {
    if (!traceDragMode || !traceImageUrl) return;
    const t = e.target;
    if (t && t.id === 'traceImageLayer') {
      startTraceDrag(e);
    }
  }, { passive: false });

  // === Floating window drag / resize for map & info ===
  (function(){
    const appEl = document.querySelector('.app');
    if (!appEl) return;
    const handles = document.querySelectorAll('.window-drag-handle');
    const resizers = document.querySelectorAll('.window-resizer');
    let activeWin = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let resizeWin = null;
    let resizeStartX = 0;
    let resizeStartY = 0;
    let resizeStartW = 0;
    let resizeStartH = 0;

    function getAppRect(){
      return appEl.getBoundingClientRect();
    }

    handles.forEach(h => {
      h.addEventListener('mousedown', (e) => {
        const id = h.getAttribute('data-window');
        const win = document.getElementById(id);
        if (!win) return;
        e.preventDefault();
        activeWin = win;
        const winRect = win.getBoundingClientRect();
        const appRect = getAppRect();
        dragOffsetX = e.clientX - winRect.left;
        dragOffsetY = e.clientY - winRect.top;
        document.body.style.cursor = 'move';
        window.addEventListener('mousemove', onWinDrag);
        window.addEventListener('mouseup', endWinDrag);
      });
    });

    function onWinDrag(e){
      if (!activeWin) return;
      e.preventDefault();
      const appRect = getAppRect();
      let x = e.clientX - appRect.left - dragOffsetX;
      let y = e.clientY - appRect.top - dragOffsetY;
      const maxX = appRect.width - 120;
      const maxY = appRect.height - 80;
      if (x < 0) x = 0;
      if (y < 0) y = 0;
      if (x > maxX) x = maxX;
      if (y > maxY) y = maxY;
      activeWin.style.left = x + 'px';
      activeWin.style.top = y + 'px';
    }

    function endWinDrag(){
      if (!activeWin) return;
      recordWindowState(activeWin);
      activeWin = null;
      document.body.style.cursor = '';
      window.removeEventListener('mousemove', onWinDrag);
      window.removeEventListener('mouseup', endWinDrag);
    }

    resizers.forEach(r => {
      r.addEventListener('mousedown', (e) => {
        const id = r.getAttribute('data-window');
        const win = document.getElementById(id);
        if (!win) return;
        e.preventDefault();
        resizeWin = win;
        const rect = win.getBoundingClientRect();
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        resizeStartW = rect.width;
        resizeStartH = rect.height;
        document.body.style.cursor = 'se-resize';
        window.addEventListener('mousemove', onWinResize);
        window.addEventListener('mouseup', endWinResize);
      });
    });

    function onWinResize(e){
      if (!resizeWin) return;
      e.preventDefault();
      const dx = e.clientX - resizeStartX;
      const dy = e.clientY - resizeStartY;
      let newW = resizeStartW + dx;
      let newH = resizeStartH + dy;
      const minW = (resizeWin.id === 'controlsPanel') ? 130 : 260;
      const minH = (resizeWin.id === 'controlsPanel') ? 100 : 220;
      if (newW < minW) newW = minW;
      if (newH < minH) newH = minH;
      resizeWin.style.width = newW + 'px';
      resizeWin.style.height = newH + 'px';

      // Adjust map tools grid columns when the controls panel is resized
      if (resizeWin.id === 'controlsPanel') {
        const mapToolsGrid = document.getElementById('mapToolsGrid');
        if (mapToolsGrid) {
          if (newW >= 600) {
            mapToolsGrid.style.gridTemplateColumns = 'repeat(7,minmax(0,1fr))';
          } else if (newW < 260) {
            mapToolsGrid.style.gridTemplateColumns = 'repeat(2,minmax(0,1fr))';
          } else {
            mapToolsGrid.style.gridTemplateColumns = 'repeat(4,minmax(0,1fr))';
          }
        }
      }
    }


    const mapPanelWin = document.getElementById('mapPanel');
    if (mapPanelWin) {
      mapPanelWin.addEventListener('mousedown', (e) => {
        const rect = mapPanelWin.getBoundingClientRect();
        // Only start drag when clicking in the top 20px of the window
        if (e.clientY > rect.top + 20) return;
        // Don't interfere with resize handle
        const target = e.target;
        if (target && target.closest && target.closest('.window-resizer')) return;

        e.preventDefault();
        activeWin = mapPanelWin;
        const appRect = getAppRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        document.body.style.cursor = 'move';
        window.addEventListener('mousemove', onWinDrag);
        window.addEventListener('mouseup', endWinDrag);
      });
    }

    function endWinResize(){
      if (!resizeWin) return;
      recordWindowState(resizeWin);
      resizeWin = null;
      document.body.style.cursor = '';
      window.removeEventListener('mousemove', onWinResize);
      window.removeEventListener('mouseup', endWinResize);
    }

    // Persist window positions & sizes in localStorage
    const WIN_STORAGE_KEY = 'sicaWindowState_v1';
    const DEFAULT_WIN_STATE = {"mapPanel":{"left":258,"top":0,"width":744.96875,"height":628.9765625},"infoPanel":{"left":997.984375,"top":0,"width":277.9921875,"height":621.9609375},"analyticsPanel":{"left":0,"top":197,"width":262,"height":432.9765625},"controlsPanel":{"left":0,"top":2,"width":260.9921875,"height":198.9921875}};


    function loadWindowState(){
      try{
        const raw = window.localStorage.getItem(WIN_STORAGE_KEY);
        if (!raw) return DEFAULT_WIN_STATE;
        const parsed = JSON.parse(raw);
        return (parsed && typeof parsed === 'object') ? parsed : {};
      } catch(e){
        return {};
      }
    }

    function saveWindowState(state){
      try{
        window.localStorage.setItem(WIN_STORAGE_KEY, JSON.stringify(state || {}));
      } catch(e){}
    }

    let winState = loadWindowState();

    function applyWindowState(id){
      if (window.matchMedia('(max-width: 900px)').matches) return;
      const win = document.getElementById(id);
      if (!win || !winState[id]) return;
      const s = winState[id];
      if (typeof s.left === 'number') win.style.left = s.left + 'px';
      if (typeof s.top === 'number') win.style.top = s.top + 'px';
      if (typeof s.width === 'number') win.style.width = s.width + 'px';
      if (typeof s.height === 'number') win.style.height = s.height + 'px';
    }

    function recordWindowState(win){
      if (!win || !win.id) return;
      const rect = win.getBoundingClientRect();
      const appRect = getAppRect();
      const id = win.id;
      if (!winState) winState = {};
      winState[id] = {
        left: rect.left - appRect.left,
        top: rect.top - appRect.top,
        width: rect.width,
        height: rect.height
      };
      saveWindowState(winState);
    }


  // --- Analytics panel: streets & transit routes ---
  const analyticsStreetList = document.getElementById('analyticsStreetList');
  const analyticsBusList = document.getElementById('analyticsBusList');
  const analyticsBikeList = document.getElementById('analyticsBikeList');
  const analyticsRailList = document.getElementById('analyticsRailList');
  const analyticsWaterList = document.getElementById('analyticsWaterList');
  const analyticsEmpty = document.getElementById('analyticsEmpty');
  const analyticsContent = document.getElementById('analyticsContent');

  let analyticsGroups = {};
  let streetIdToGroupKey = {};
  let analyticsActiveKey = null;
  function buildAnalyticsFromState(){
    analyticsGroups = {};
    streetIdToGroupKey = {};

    const streets = state.streets || [];
    streets.forEach(s=>{
      const layer = getStreetLayer(s);
      const name = (s.name || '').trim();
      const notes = (s.notes || '').trim();
      let groupKey, label, category;

      if (layer === 'bus'){
        let m = name.match(/(\d+)\s+bus/i);
        if (m){
          const num = m[1];
          groupKey = 'bus:' + num;
          label = num + ' Bus';
        } else {
          groupKey = 'bus:' + (name || notes || 'Bus Route').toLowerCase();
          label = name || notes || 'Bus Route';
        }
        category = 'bus';
      } else if (layer === 'rail'){
        let base = name || notes || 'Rail Line';
        if (/^train tracks$/i.test(name) && notes){
          base = notes;
        }
        groupKey = 'rail:' + base.toLowerCase();
        label = base;
        category = 'rail';
      } else if (layer === 'bike'){
        const base = name || 'Bike Lane';
        groupKey = 'bike:' + base.toLowerCase();
        label = base;
        category = 'bike';
      } else if (layer === 'water'){
        const base = name || notes || 'Waterway';
        groupKey = 'water:' + base.toLowerCase();
        label = base;
        category = 'water';
      } else {
        const base = name || 'Unnamed Street';
        groupKey = 'street:' + base.toLowerCase();
        label = base;
        category = 'street';
      }

      if (!analyticsGroups[groupKey]){
        analyticsGroups[groupKey] = {
          key: groupKey,
          label: label,
          layer: layer,
          category: category,
          streetIds: [],
          segments: 0,
          length: 0,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      analyticsGroups[groupKey].streetIds.push(s.id);

      const nodes = s.nodes || [];
      let segLen = 0;
      const g = analyticsGroups[groupKey];
      for (let i=1;i<nodes.length;i++){
        const dx = (nodes[i].x || 0) - (nodes[i-1].x || 0);
        const dy = (nodes[i].y || 0) - (nodes[i-1].y || 0);
        segLen += Math.sqrt(dx*dx + dy*dy);
      }
      g.length += segLen;
      g.segments += nodes.length > 1 ? (nodes.length - 1) : 0;
      for (let i=0;i<nodes.length;i++){
        const nx = nodes[i].x;
        const ny = nodes[i].y;
        if (typeof nx === 'number' && typeof ny === 'number'){
          if (nx < g.minX) g.minX = nx;
          if (nx > g.maxX) g.maxX = nx;
          if (ny < g.minY) g.minY = ny;
          if (ny > g.maxY) g.maxY = ny;
        }
      }

      streetIdToGroupKey[s.id] = groupKey;
    });

    renderAnalyticsLists();
  }

  function syncAnalyticsSelectionToStreet(streetId){
    const key = streetIdToGroupKey[streetId];
    if (!key) return;
    analyticsActiveKey = key;
    highlightAnalyticsGroup(key);
    renderAnalyticsLists();
  }

  function formatAnalyticsLength(lenFeet){
    if (!lenFeet || !isFinite(lenFeet)) return '';
    const miles = lenFeet / 5280;
    if (miles < 0.1) return miles.toFixed(2) + ' mi';
    if (miles < 10) return miles.toFixed(2) + ' mi';
    return miles.toFixed(1) + ' mi';
  }

  function renderAnalyticsLists(){
    if (!analyticsStreetList || !analyticsBusList || !analyticsBikeList || !analyticsRailList || !analyticsWaterList || !analyticsEmpty || !analyticsContent) return;

    analyticsStreetList.innerHTML = '';
    analyticsBusList.innerHTML = '';
    analyticsBikeList.innerHTML = '';
    analyticsRailList.innerHTML = '';
    analyticsWaterList.innerHTML = '';

    const groupsArr = Object.values(analyticsGroups);
    if (!groupsArr.length){
      analyticsEmpty.style.display = 'block';
      analyticsContent.style.display = 'none';
      return;
    }
    analyticsEmpty.style.display = 'none';
    analyticsContent.style.display = '';

    const streetGroups = groupsArr
      .filter(g => g.category === 'street')
      .sort((a,b)=> a.label.localeCompare(b.label, undefined, { numeric:true, sensitivity:'base' }));
    const busGroups = groupsArr
      .filter(g => g.category === 'bus')
      .sort((a,b)=> a.label.localeCompare(b.label, undefined, { numeric:true, sensitivity:'base' }));
    const bikeGroups = groupsArr
      .filter(g => g.category === 'bike')
      .sort((a,b)=> a.label.localeCompare(b.label, undefined, { numeric:true, sensitivity:'base' }));
    const railGroups = groupsArr
      .filter(g => g.category === 'rail')
      .sort((a,b)=> a.label.localeCompare(b.label, undefined, { numeric:true, sensitivity:'base' }));

    const waterGroups = groupsArr
      .filter(g => g.category === 'water')
      .sort((a,b)=> a.label.localeCompare(b.label, undefined, { numeric:true, sensitivity:'base' }));

    function addAnalyticsItem(parent, group){
      const li = document.createElement('li');
      li.dataset.key = group.key;
      if (group.key === analyticsActiveKey) li.classList.add('active');

      const titleSpan = document.createElement('span');
      titleSpan.textContent = group.label;

      const metaSpan = document.createElement('span');
      metaSpan.className = 'pill';
      const lengthLabel = formatAnalyticsLength(group.length);
      metaSpan.textContent = lengthLabel || '';

      li.appendChild(titleSpan);
      li.appendChild(metaSpan);

      li.addEventListener('click', ()=>{
        const ids = group.streetIds || [];
        if (ids.length){
          // Selecting a street here will also activate the corresponding analytics group
          selectStreet(ids[0]);
        } else {
          analyticsActiveKey = group.key;
          highlightAnalyticsGroup(group.key);
          renderAnalyticsLists();
        }
        zoomToAnalyticsGroup(group.key);

        // Mobile: after selecting a line/road, close the Routes overlay so the map is visible
        if (window.matchMedia('(max-width: 900px)').matches){
          document.body.classList.remove('mobile-pane-analytics');
        }
      });

      parent.appendChild(li);
    }

    streetGroups.forEach(g => addAnalyticsItem(analyticsStreetList, g));
    busGroups.forEach(g => addAnalyticsItem(analyticsBusList, g));
    bikeGroups.forEach(g => addAnalyticsItem(analyticsBikeList, g));
    railGroups.forEach(g => addAnalyticsItem(analyticsRailList, g));
    waterGroups.forEach(g => addAnalyticsItem(analyticsWaterList, g));
  }
  function highlightAnalyticsGroup(groupKey){
    const group = analyticsGroups[groupKey];
    if (!group) return;

    const streetPaths = svg.querySelectorAll('.street');
    streetPaths.forEach(p => p.classList.remove('highlighted'));
    const labelTexts = svg.querySelectorAll('text[data-street-id]');
    labelTexts.forEach(t => t.classList.remove('highlighted'));

    (group.streetIds || []).forEach(id => {
      const path = svg.querySelector('.street[data-id="' + id + '"]');
      if (path){
        path.classList.add('highlighted');
        // Bring to front within the streets layer so highlights stay visible at intersections
        if (path.parentNode) path.parentNode.appendChild(path);
      }
      const label = svg.querySelector('text[data-street-id="' + id + '"]');
      if (label){
        label.classList.add('highlighted');
        if (label.parentNode) label.parentNode.appendChild(label);
      }
    });

    // Also highlight transit stops (buildings) associated with the active bus/rail line(s)
    highlightedStreetIdsForStops = (group.streetIds || []).slice();
    computeStopHighlightIds();
    applyStopHighlightClasses();
  }

  function zoomToAnalyticsGroup(groupKey){
    const group = analyticsGroups[groupKey];
    if (!group) return;

    const minX = group.minX;
    const maxX = group.maxX;
    const minY = group.minY;
    const maxY = group.maxY;
    if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minY) || !isFinite(maxY)) return;

    // Raw width/height of the group in world units
    let w = maxX - minX;
    let h = maxY - minY;

    // Enforce a minimum footprint so tiny groups still zoom to something visible
    const MIN_SIZE = 40;
    if (w < MIN_SIZE) w = MIN_SIZE;
    if (h < MIN_SIZE) h = MIN_SIZE;

    // Use a single span so the box is roughly square. This makes the
    // zoom robust to any 90°/180° world rotation: whichever way the
    // street is oriented, we reserve enough vertical space.
    let span = Math.max(w, h);
    const MIN_SPAN = 80;
    if (span < MIN_SPAN) span = MIN_SPAN;

    // Padding around the span (world units)
    const padBase = 140;
    const padFraction = 0.25; // 25% of span
    const pad = Math.max(padBase, span * padFraction);

    // Center target (bbox center)
    const targetX = (minX + maxX) / 2;
    const targetY = (minY + maxY) / 2;

    // Choose an actual point on the line network closest to the target.
    // This avoids centering on a point that isn't actually on the polyline (common with curvy lines).
    let cx = targetX, cy = targetY;
    try {
      const streets = state.streets || [];
      let bestD2 = Infinity;
      let bestX = targetX;
      let bestY = targetY;

      function considerPoint(x, y){
        const dx = x - targetX;
        const dy = y - targetY;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2){ bestD2 = d2; bestX = x; bestY = y; }
      }

      function considerSegment(ax, ay, bx, by){
        const vx = bx - ax;
        const vy = by - ay;
        const vv = vx*vx + vy*vy;
        if (vv === 0){ considerPoint(ax, ay); return; }
        const wx = targetX - ax;
        const wy = targetY - ay;
        let t = (wx*vx + wy*vy) / vv;
        if (t < 0) t = 0;
        else if (t > 1) t = 1;
        considerPoint(ax + t*vx, ay + t*vy);
      }

      (group.streetIds || []).forEach(id => {
        const s = streets.find(st => st.id === id);
        if (!s) return;
        const nodes = (s.nodes || []).filter(n => typeof n.x === 'number' && typeof n.y === 'number');
        if (nodes.length === 1){
          considerPoint(nodes[0].x, nodes[0].y);
          return;
        }
        for (let i=1;i<nodes.length;i++){
          considerSegment(nodes[i-1].x, nodes[i-1].y, nodes[i].x, nodes[i].y);
        }
      });

      if (isFinite(bestD2)){
        cx = bestX;
        cy = bestY;
      }
    } catch(_){ /* fall back to bbox center */ }

    // Axis-aligned box we want to fit (before aspect correction)
    let boxW = span + 2 * pad;
    let boxH = span + 2 * pad;

    const rect = svg.getBoundingClientRect();
    if (!rect.width || !rect.height) return;
    const aspect = rect.width / rect.height;

    let newW = boxW;
    let newH = boxH;

    // Expand one dimension to match the viewport aspect, never shrink.
    if (newW / newH > aspect){
      // box wider than viewport: grow height
      newH = newW / aspect;
    } else {
      // box taller than viewport: grow width
      newW = newH * aspect;
    }

    // Cap zoom-out so we never show more than this many world pixels
    const MAX_VIEW_SPAN = 10000;
    const clampScale = Math.min(1, MAX_VIEW_SPAN/newW, MAX_VIEW_SPAN/newH);
    if (clampScale < 1){
      newW *= clampScale;
      newH *= clampScale;
    }

    // Center the view on the group
    const vx = cx - newW / 2;
    const vy = cy - newH / 2;

    svg.setAttribute('viewBox', `${vx} ${vy} ${newW} ${newH}`);
    applyWorldRotation();
  }

	  // Expose analytics helpers to the main renderer.
	  // The analytics UI lives inside this window-management IIFE, while renderAll/selectStreet live outside.
	  try {
	    window.__sicaAnalytics = {
	      buildFromState: buildAnalyticsFromState,
	      highlightGroup: highlightAnalyticsGroup,
	      syncSelectionToStreet: syncAnalyticsSelectionToStreet,
	      zoomToGroup: zoomToAnalyticsGroup,
	      getActiveKey: () => analyticsActiveKey,
	      setActiveKey: (k) => { analyticsActiveKey = k; },
	      getGroups: () => analyticsGroups
	    };
	  } catch(_){ }
// Apply saved positions/sizes on load
    applyWindowState('mapPanel');
    applyWindowState('infoPanel');
    applyWindowState('analyticsPanel');
    applyWindowState('controlsPanel');

    // Ensure map tools grid columns match the current controls panel width
    (function(){
      const controlsPanelEl = document.getElementById('controlsPanel');
      const mapToolsGrid = document.getElementById('mapToolsGrid');
      if (controlsPanelEl && mapToolsGrid) {
        const rect = controlsPanelEl.getBoundingClientRect();
        if (rect.width < 260) {
          mapToolsGrid.style.gridTemplateColumns = 'repeat(2,minmax(0,1fr))';
        } else {
          mapToolsGrid.style.gridTemplateColumns = 'repeat(4,minmax(0,1fr))';
        }
      }
    })();


  })();
  init();

})();
</script>
<script>
(function(){
  const nameEl = document.getElementById('mapNameDisplay');
  const fileInput = document.getElementById('fileInput');
  if (fileInput && nameEl) {
    fileInput.addEventListener('change', (e) => {
      const f = e.target && e.target.files && e.target.files[0];
      if (f) {
        const nice = f.name.replace(/\.[^.]+$/, '');
        nameEl.textContent = nice || f.name;
      }
    });
  }
  try {
    if (window.MAP_META && window.MAP_META.name && nameEl) {
      nameEl.textContent = String(window.MAP_META.name || '').replace(/\.[^.]+$/, '') || window.MAP_META.name;
    }
  } catch(_) {}
})();
</script>

<script>
(function(){
  const loadBtn = document.getElementById('loadBtn');
  const fileInput = document.getElementById('fileInput');
  if (loadBtn && fileInput) {
    loadBtn.addEventListener('click', () => fileInput.click());
  }
})();
</script>


<script>
/* MOBILE_LAYOUT_PATCH_v2 */
(function(){
  const mq = window.matchMedia('(max-width: 900px)');

  let quickOriginalParent = null;
  let quickOriginalNext = null;

  function addClose(panelId, titleText, bodyClass){
    const panel = document.getElementById(panelId);
    if (!panel) return;

    let handle = null;
    try { handle = panel.querySelector(':scope > .window-drag-handle'); } catch(_) {}
    if (!handle) handle = panel.querySelector('.window-drag-handle');
    if (!handle) return;

    // Ensure there's a title on the left
    let titleSpan = handle.querySelector('span');
    if (!titleSpan){
      titleSpan = document.createElement('span');
      titleSpan.textContent = titleText;
      handle.appendChild(titleSpan);
    } else if (!String(titleSpan.textContent || '').trim()){
      titleSpan.textContent = titleText;
    }

    // Mobile headers shouldn't be draggable
    handle.style.justifyContent = 'space-between';
    handle.style.cursor = 'default';

    if (handle.querySelector('.mobile-close')) return;

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'tool-btn muted-btn mobile-close';
    btn.textContent = 'Back';
    btn.style.margin = '0';
    btn.style.padding = '6px 10px';
    btn.style.minHeight = '30px';
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      document.body.classList.remove(bodyClass);
    });

    handle.appendChild(btn);
  }

  function ensureMobileInfoBar(){
    const quick = document.getElementById('quickEditBar');
    if (!quick) return;

    if (!quickOriginalParent){
      quickOriginalParent = quick.parentElement;
      quickOriginalNext = quick.nextElementSibling;
    }

    // Desktop: keep the quick edit UI out of the way.
    if (!mq.matches){
      if (quickOriginalParent && quick.parentElement !== quickOriginalParent){
        if (quickOriginalNext && quickOriginalNext.parentElement === quickOriginalParent){
          quickOriginalParent.insertBefore(quick, quickOriginalNext);
        } else {
          quickOriginalParent.appendChild(quick);
        }
      }
      const bar = document.getElementById('mobileInfoBar');
      if (bar) bar.style.display = 'none';
      document.body.classList.remove('mobile-pane-info','mobile-pane-analytics');
      return;
    }

    // Mobile: dock quick edit bar at the bottom of the screen.
    let bar = document.getElementById('mobileInfoBar');
    if (!bar){
      bar = document.createElement('div');
      bar.id = 'mobileInfoBar';
      document.body.appendChild(bar);
    }
    if (quick.parentElement !== bar){
      bar.appendChild(quick);
    }
    bar.style.display = 'block';
  }

  function ensureOverlayButtons(){
    if (!mq.matches) return;

    // Routes (Lines & Routes) overlay: add a Back button so you can return to the map
    addClose('analyticsPanel', 'Lines & Routes', 'mobile-pane-analytics');

    // Safety: if anything ever opens the inspector overlay on mobile, make it closable too
    addClose('infoPanel', 'Inspector', 'mobile-pane-info');
  }

  function sync(){
    ensureMobileInfoBar();
    ensureOverlayButtons();
  }

  sync();
  mq.addEventListener('change', sync);
})();
</script>


</body>
</html>
