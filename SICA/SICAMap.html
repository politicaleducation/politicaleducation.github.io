<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Neighborhood Map — Single-file (Dark)</title>
<style>
    /* Collapsible STREET sections */
    details#streetSetup, details#streetInfo{
      margin-top:12px;
      padding:10px;
      border:1px solid rgba(255,255,255,0.06);
      border-radius:10px;
      background:var(--glass);
    }
    details#streetInfo summary, details#streetSetup summary{
      list-style:none;
      cursor:pointer;
      font-weight:600;
      color:#e6eef3;
      margin:-4px 0 8px 0;
    }
    details#streetInfo summary::-webkit-details-marker,
    details#streetSetup summary::-webkit-details-marker{ display:none; }
    /* Tracing Image collapsible section styled like Street Info / Street Set Up */
    details#traceTools{
      margin-top:12px;
      padding:10px;
      border:1px solid rgba(255,255,255,0.06);
      border-radius:10px;
      background:var(--glass);
    }
    details#traceTools summary{
      list-style:none;
      cursor:pointer;
      font-weight:600;
      color:#e6eef3;
      margin:-4px 0 8px 0;
    }
    details#traceTools summary::-webkit-details-marker{ display:none; }


    /* Collapsible inspector sections */
    details#setup, details#fill{
      margin-top:12px;
      padding:10px;
      border:1px solid rgba(255,255,255,0.06);
      border-radius:10px;
      background:var(--glass);
    }
    details summary{
      list-style:none;
      cursor:pointer;
      font-weight:600;
      color:#e6eef3;
      margin:-4px 0 8px 0;
    }
    details summary::-webkit-details-marker{ display:none; }

    :root{
      --bg:#0b0f13;--panel:#0f1418;--muted:#9aa3ad;--accent:#6ee7b7;--card:#111418;--danger:#ff6b6b;
      --glass:rgba(255,255,255,0.03);
      font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;
      --stopAccent:#fbbf24;
}
    html,body{height:100%;background:linear-gradient(180deg,#051018 0%,var(--bg)100%);color:#e6eef3;margin:0;overflow:auto;scrollbar-width:none;-ms-overflow-style:none}
    html::-webkit-scrollbar,body::-webkit-scrollbar{display:none}
    .app{position:relative;display:block;min-height:100vh;padding:18px}
    header{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;padding:10px 0}
    h1{font-size:18px;margin:0;color:white}
    main{background:transparent;border-radius:0;padding:0;box-shadow:none}
    .map-wrap{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:8px;padding:12px}
    svg{width:100%;height:72vh;display:block;border-radius:6px;background:linear-gradient(180deg, rgba(0,0,0,0.18), rgba(255,255,255,0.02));cursor:grab;outline:none}
    svg.dragging{cursor:grabbing}
    .sidebar{background:var(--panel);border-radius:12px;padding:14px;height:calc(100vh - 88px);box-shadow:0 6px 20px rgba(0,0,0,0.6);overflow:auto}
    label{display:block;font-size:12px;color:var(--muted);margin-top:10px}
    input[type=text],input[type=color],select,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
    button{margin-top:12px;padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#052018;font-weight:600;cursor:pointer}
    .muted-btn{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px}
    .drag-on{background:var(--accent);color:#052018}
    .small{font-size:13px;color:var(--muted)}
    .building{cursor:pointer;transition:opacity .08s ease,transform .08s ease}
    .building:hover{opacity:0.96}
    .building.selected{stroke:var(--accent);stroke-width:3}
    .building.stop-highlight{stroke:var(--stopAccent);stroke-width:4;filter:drop-shadow(0 0 6px var(--stopAccent));}
    .legend{display:flex;gap:8px;align-items:center;margin-top:8px}
    .chip{padding:6px 8px;border-radius:10px;background:var(--glass);font-size:12px;color:var(--muted)}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
     .layer-controls{display:flex;gap:6px;align-items:center;flex-wrap:wrap;margin-left:8px}
     .layer-controls span{font-size:12px;color:var(--muted);margin-right:4px}

    .node-handle{
    cursor:pointer;
    stroke:#020617;
    stroke-width:2px;
    filter:drop-shadow(0 0 3px rgba(0,0,0,0.8));
  }
    footer{grid-column:1/-1;padding-top:8px;color:var(--muted);font-size:13px}
    .rotate-control{display:flex;gap:8px;align-items:center;margin-left:8px}
    #controlsPanel .controls{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    #mapToolsGrid{
      display:grid;
      grid-template-columns:repeat(4,minmax(0,1fr));
      column-gap:2px;
      row-gap:0;
      width:100%;
      margin-top:2px;
    }
    #mapToolsGrid .tool-label{
      grid-column:1/-1;
      font-size:10px;
      text-transform:uppercase;
      letter-spacing:0.08em;
      color:var(--muted);
      margin-top:4px;
    }
    .tool-btn{
      margin:0 0 2px 0;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:4px 6px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.08);
      background:var(--glass);
      color:#e6eef3;
      font-size:11px;
      font-weight:500;
      min-height:26px;
      cursor:pointer;
      text-decoration:none;
      white-space:nowrap;
    }
    #mapToolsGrid .tool-btn:hover{
      background:rgba(255,255,255,0.12);
    }
    .tool-btn:disabled{
      opacity:0.45;
      cursor:not-allowed;
    }
    #mapToolsGrid .tool-btn-file{
      background:rgba(56,189,248,0.12);
      border-color:rgba(56,189,248,0.55);
    }
    #mapToolsGrid .tool-btn-edit{
      background:rgba(52,211,153,0.14);
      border-color:rgba(52,211,153,0.55);
    }
    #mapToolsGrid .tool-btn-zoom{
      background:rgba(251,191,36,0.14);
      border-color:rgba(251,191,36,0.55);
    }
    #mapToolsGrid .tool-btn-layer{
      background:rgba(129,140,248,0.16);
      border-color:rgba(129,140,248,0.60);
    }
    #mapToolsGrid .tool-btn-orient{
      background:rgba(248,113,113,0.16);
      border-color:rgba(248,113,113,0.60);
    }
    #controlsPanel .header-left h1{
      font-size:14px;
    }

    
    /* Make inspector content scrollable within the resizable infoPanel */
    #inspector{
      flex:1;
      min-height:0;
      overflow-y:auto;
      padding:10px;

      /* Hide scrollbars but keep scrolling */
      scrollbar-width:none;          /* Firefox */
      -ms-overflow-style:none;       /* IE / Edge legacy */
    }
    #inspector::-webkit-scrollbar{   /* Chrome, Safari, Edge (Blink/WebKit) */
      display:none;
    }

    
    /* Mobile-only quick edit bar (selection label/info) is hidden on desktop */
    #quickEditBar{ display:none; }

@media (max-width: 900px){
  /* MOBILE LAYOUT: fullscreen map + TOP tools bar + BOTTOM quick-edit bar + overlay panes */

  /* Stop the page itself from scrolling while you pan/zoom the SVG */
  html, body { height: 100%; overflow: hidden; overscroll-behavior: none; }
  .app { padding: 0; min-height: 100vh; }

  /* Fullscreen map */
  #mapPanel{
    position: fixed !important;
    left: 0 !important;
    top: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    display: flex !important;
    flex-direction: column;
    border-radius: 0 !important;
    z-index: 10 !important;
  }
  #mapPanel .map-wrap{ padding: 0 !important; border-radius: 0 !important; }
  #mapPanel .map-wrap svg{
    height: 100% !important;
    border-radius: 0 !important;
  }

  /* TOP tools bar */
  #controlsPanel{
    position: fixed !important;
    left: 0 !important;
    right: 0 !important;
    top: 0 !important;
    bottom: auto !important;
    width: 100vw !important;
    display: flex !important;
    flex-direction: column;
    border-radius: 0 0 16px 16px !important;
    z-index: 40 !important;

    /* safe-area */
    padding-top: env(safe-area-inset-top);
  }
  /* Remove the "Map Tools" title bar + any resize chrome */
  #controlsPanel .window-drag-handle,
  #controlsPanel .window-resizer{ display: none !important; }

  /* Make the tools panel non-scrollable */
  #controlsPanel .controls-panel-body{
    overflow: hidden !important;
    padding: 8px 8px 10px !important;
    touch-action: manipulation;
  }

  /* Hide header bits you don't care about on mobile */
  #controlsPanel .header-left,
  #mapNameDisplay,
  #autosaveRow,
  #blockName{ display: none !important; }

  /* Map tools: compact 4-column grid */
  #mapToolsGrid{
    grid-template-columns: repeat(4, minmax(0,1fr)) !important;
    column-gap: 4px !important;
    row-gap: 4px !important;
    margin-top: 0 !important;
  }
  .tool-btn{
    min-height: 30px !important;
    font-size: 12px !important;
    padding: 6px 6px !important;
  }

  /* BOTTOM quick-edit bar (selection name + label/info) */
  #mobileInfoBar{
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 45;
    background: var(--panel);
    border-top: 1px solid rgba(255,255,255,0.09);
    box-shadow: 0 -10px 24px rgba(0,0,0,0.35);
    padding: 8px 8px calc(10px + env(safe-area-inset-bottom));

    /* Keep this panel from growing into the map; scroll internally instead */
    height: clamp(190px, 32vh, 420px);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
    touch-action: pan-y;

    /* Hide scrollbars but keep scrolling */
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  #mobileInfoBar::-webkit-scrollbar{ display:none; }
    /* Show quick edit bar on mobile */
  #quickEditBar{ display:block !important; }

#mobileInfoBar #quickEditBar{
    margin-top: 0 !important;
  }
  #mobileInfoBar #quickEditBar .quick-top{
    gap: 10px !important;
  }
  #mobileInfoBar #quickSelMeta{
    font-size: 12px !important;
  }
  #mobileInfoBar #quickNotesInput{
    max-height: 60px;
  }

  /* Disable window chrome that's annoying on touch (keep overlay headers for Close buttons) */
  #mapPanel .window-resizer,
  #mapPanel .window-drag-handle,
  #infoPanel .window-resizer,
  #analyticsPanel .window-resizer { display: none !important; }

  /* Fullscreen overlays (hidden until opened) */
  #infoPanel, #analyticsPanel{
    position: fixed !important;
    inset: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    border-radius: 0 !important;
    z-index: 60 !important;
    display: none !important;
  }
  body.mobile-pane-info #infoPanel{ display: flex !important; }
  body.mobile-pane-analytics #analyticsPanel{ display: flex !important; }

  /* Prevent iOS “zoom on focus” in forms */
  input, select, textarea { font-size: 16px; }

  /* Tell the browser we're handling touch gestures on the SVG */
  #mapSvg{
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
  }

  /* Make analytics list easier to tap */
  #analyticsPanel li{ padding: 10px 10px; }
}

  
    .header-left{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    .header-actions{display:flex;gap:8px}

    .ellipsis{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:60vw}
    .header-actions label.muted-btn{font-weight:600}
    .header-actions .muted-btn{margin-top:0;font-weight:600}
    .header-actions a.muted-btn{ text-decoration:none; display:inline-block; }
    .header-actions a.muted-btn:visited{ color:var(--muted); }

    #mapPanel, #infoPanel{
      position:absolute;
      box-shadow:0 14px 40px rgba(0,0,0,0.75);
      border-radius:12px;
      overflow:hidden;
      z-index:10;
      padding:0;
    }
    #controlsPanel{
      position:absolute;
      top:24px;
      left:24px;
      width:380px;
      min-height:100px;
      display:flex;
      flex-direction:column;
      background:var(--panel);
      border-radius:12px;
      box-shadow:0 14px 40px rgba(0,0,0,0.75);
      overflow:hidden;
      z-index:12;
    }
    #controlsPanel .controls-panel-body{
      padding:10px 12px 12px 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    /* Quick edit bar (always visible while scrolling Map Tools) */
    #quickEditBar{
      position: sticky;
      top: 0;
      z-index: 5;
      background: rgba(15,15,18,0.88);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      padding: 8px;
      backdrop-filter: blur(8px);
    }
    #quickEditBar .quick-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom:6px;
    }
    #quickSelMeta{
      font-size:12px;
      opacity:0.85;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    #quickEditBar .quick-input{
      padding: 8px;
      border-radius: 10px;
      font-size: 16px; /* avoid iOS zoom-on-focus */
    }
    #quickEditBar .quick-textarea{
      padding: 8px;
      border-radius: 10px;
      font-size: 16px; /* avoid iOS zoom-on-focus */
      resize: vertical;
      min-height: 60px;
    }
    #quickEditBar .quick-input:disabled,
    #quickEditBar .quick-textarea:disabled{
      opacity:0.55;
    }


    #quickEditBar .quick-top-actions{
      display:flex;
      gap:8px;
      align-items:center;
    }
    #quickEditBar .quick-grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 6px;
      margin-top: 6px;
    }
    #quickEditBar .quick-field{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    #quickEditBar .quick-label{
      font-size:11px;
      opacity:0.8;
      margin-top: 4px;
    }
    #quickEditBar .quick-span-2{
      grid-column: 1 / -1;
    }
    #quickEditBar select{
      padding: 8px;
      border-radius: 10px;
      font-size: 16px; /* avoid iOS zoom-on-focus */
    }
    #quickColorInput{
      height: 38px;
      padding: 0;
      border: none;
      background: transparent;
    }
    /* Hide UI the user doesn’t want */
    #mapNameDisplay,
    #autosaveRow,
    #blockName,

    .rotate-btn{
      display:none !important;
    }
    #controlsPanel .header-left{
      margin-bottom:2px;
    }
    #controlsPanel .controls{
      margin-top:4px;
    }
    #controlsPanel .legend{
      margin-top:6px;
    }
    #mapPanel{
      top:90px;
      left:24px;
      width:min(60vw, 960px);
      height:calc(100vh - 150px);
      display:flex;
      flex-direction:column;
    }
    #infoPanel{
      top:100px;
      right:24px;
      width:360px;
      height:calc(100vh - 170px);
      display:flex;
      flex-direction:column;
      padding:0;
    }
    #mapPanel .map-wrap{
      flex:1;
      display:flex;
      flex-direction:column;
    }
    #mapPanel .map-wrap svg{
      flex:1;
      height:auto;
    }
    .window-drag-handle{
      height:20px;
      padding:0 10px;
      font-size:12px;
      background:rgba(0,0,0,0.45);
      border-bottom:1px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      cursor:move;
    }
    /* Normalize window headers: make all four handles match Map Tools */
    #mapPanel > .window-drag-handle,
    #infoPanel > .window-drag-handle,
    #analyticsPanel > .window-drag-handle,
    #controlsPanel > .window-drag-handle{
      height:20px;
      padding:0 10px;
      font-size:12px;
      background:rgba(0,0,0,0.45);
      border-bottom:1px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      cursor:move;
      box-sizing:border-box;
    }
    /* unified handle: infoPanel uses global/window-header rule below */

    .window-resizer{
      position:absolute;
      width:12px;
      height:12px;
      right:4px;
      bottom:4px;
      cursor:se-resize;
      background:rgba(255,255,255,0.2);
      border-radius:3px;
    }

    #analyticsPanel{
      position:absolute;
      top:100px;
      left:calc(50% - 180px);
      width:320px;
      height:calc(100vh - 170px);
      display:flex;
      flex-direction:column;
      background:var(--panel);
      border-radius:12px;
      box-shadow:0 14px 40px rgba(0,0,0,0.75);
      overflow:hidden;
      z-index:11;
      padding:0;
    }
    /* unified handle: analyticsPanel uses global/window-header rule below */
    #analyticsPanel .analytics-body{
      flex:1;
      padding:10px;
      overflow:auto;
      font-size:12px;
      scrollbar-width:none; /* Firefox */
    }
    #analyticsPanel .analytics-body::-webkit-scrollbar{
      width:0;
      height:0;
    }
    #analyticsPanel .group-header{
      margin:8px 0 4px;
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:0.06em;
      color:var(--muted);
    }
    #analyticsPanel ul{
      list-style:none;
      margin:0;
      padding:0;
    }
    #analyticsPanel li{
      padding:4px 6px;
      border-radius:6px;
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:6px;
    }
    #analyticsPanel li:hover{
      background:rgba(255,255,255,0.04);
    }
    #analyticsPanel li.active{
      background:rgba(110,231,183,0.18);
      color:#e6eef3;
    }
    #analyticsPanel .pill{
      font-size:10px;
      padding:2px 6px;
      border-radius:999px;
      background:rgba(255,255,255,0.06);
      color:var(--muted);
      white-space:nowrap;
    }
    .street.highlighted{
      stroke:var(--accent) !important;
      stroke-opacity:0.55;
      filter:drop-shadow(0 0 4px rgba(110,231,183,0.25));
    }
    text.highlighted{
      fill:var(--accent) !important;
      opacity:0.85;
    }
    /* Selection (street) highlight: subtle, transparent glow */
    .street.selected-street{
      stroke:rgba(200,210,220,0.85) !important;
      stroke-opacity:0.85;
      filter:drop-shadow(0 0 3px rgba(255,255,255,0.18));
    }
    text.selected-street{
      fill:rgba(220,230,240,0.9) !important;
      opacity:0.9;
    }
</style>
</head>
<body>
<div class="app">

<main>
  <div id="mapPanel">
    <div class="window-drag-handle" data-window="mapPanel"></div>
    <div class="map-wrap">
      <svg aria-label="Neighborhood map" id="mapSvg" preserveaspectratio="xMidYMid meet" tabindex="0" viewbox="0 0 1000 700"></svg>
    </div>
    <div class="window-resizer" data-window="mapPanel"></div>
  </div>
</main>


<div id="controlsPanel">
  <div class="window-drag-handle" data-window="controlsPanel">
    <span>Map Tools</span>
  </div>
  <div class="controls-panel-body">
    <div class="header-left">
      <h1 id="mapNameDisplay" class="ellipsis">SICA Map</h1>
      <div id="autosaveRow" style="display:flex;align-items:center;gap:4px;margin-top:0px;flex-wrap:wrap">
        <span id="autosaveIndicator" style="font-size:12px;opacity:0.85">Last saved: —</span>
        <button class="tool-btn tool-btn-file" id="restoreAutosaveBtn" style="display:none;padding:6px 10px">Restore autosave</button>
        <button class="tool-btn tool-btn-file" id="cancelAutosaveBtn" style="display:none;padding:6px 10px">Cancel</button>
      </div>
      <div id="quickEditBar">
  <div class="quick-top">
    <span id="quickSelMeta">No selection</span>
    <div class="quick-top-actions">
      <button class="tool-btn muted-btn" id="quickRoutesBtn" type="button">Routes</button>
      <button class="tool-btn muted-btn" id="quickApplyBtn" type="button" disabled>Apply</button>
    </div>
  </div>

  <div class="quick-grid">
    <div class="quick-field quick-span-2">
      <label class="quick-label">Object name</label>
      <input id="quickNameInput" class="quick-input" type="text" placeholder="Object name" disabled />
    </div>

    <div class="quick-field quick-span-2">
      <label class="quick-label">Info / notes</label>
      <textarea id="quickNotesInput" class="quick-textarea" rows="2" placeholder="Info / notes" disabled></textarea>
    </div>
  </div>

  <div id="quickBuildingInfo" style="display:none">
    <div class="quick-grid">
      <div class="quick-field">
        <label class="quick-label">Type</label>
        <select id="quickTypeInput" disabled>
          <option value="residential">Residential</option>
          <option value="commercial">Commercial</option>
          <option value="civic">Civic</option>
          <option value="vacant">Vacant</option>
          <option value="other">Other</option>
          <option value="public_transport">Public Transport</option>
        </select>
      </div>

      <div class="quick-field">
        <label class="quick-label">Usage</label>
        <select id="quickUsageInput" disabled>
          <option value="high">High</option>
          <option value="medium">Medium</option>
          <option value="low">Low</option>
          <option value="none">None</option>
        </select>
      </div>

      <div class="quick-field">
        <label class="quick-label">Funding</label>
        <select id="quickFundingInput" disabled>
          <option value="high">High</option>
          <option value="medium">Medium</option>
          <option value="low">Low</option>
          <option value="none">None</option>
        </select>
      </div>

      <div class="quick-field quick-span-2">
        <label class="quick-label">Occupants</label>
        <textarea id="quickOccupantsInput" class="quick-textarea" rows="2" placeholder="Occupants" disabled></textarea>
      </div>
    </div>
  </div>

  <div id="quickSetupInputs" style="display:none">
    <div class="quick-grid">
      <div class="quick-field">
        <label class="quick-label">Color</label>
        <input id="quickColorInput" type="color" disabled />
      </div>

      <div class="quick-field">
        <label class="quick-label">Length</label>
        <input id="quickLengthInput" class="quick-input" type="text" inputmode="decimal" disabled />
      </div>

      <div class="quick-field">
        <label class="quick-label">Width</label>
        <input id="quickWidthInput" class="quick-input" type="text" inputmode="decimal" disabled />
      </div>

      <div class="quick-field">
        <label class="quick-label">Angle (°)</label>
        <input id="quickAngleInput" class="quick-input" type="text" inputmode="decimal" disabled />
      </div>
    </div>
  </div>
</div>
    </div>
    <div class="controls">
      <span id="blockName" style="display:none"></span>
      <div id="mapToolsGrid">
        <button class="tool-btn tool-btn-file" id="loadBtn">Load</button>
        <button class="tool-btn tool-btn-file" id="downloadBtn">Save</button>
        <button class="tool-btn tool-btn-file" id="undoBtn" title="Undo (Ctrl/Cmd+Z)" disabled>Undo</button>
        <button class="tool-btn tool-btn-file" id="redoBtn" title="Redo (Ctrl/Cmd+Y or Ctrl/Cmd+Shift+Z)" disabled>Redo</button>

        <button class="tool-btn tool-btn-edit" id="addBuildingBtn">+ building</button>
        <button class="tool-btn tool-btn-edit" id="addStreetBtn">+ street</button>
        <button class="tool-btn tool-btn-zoom" id="zoomInBtn">+</button>
        <button class="tool-btn tool-btn-zoom" id="zoomOutBtn">−</button>

        <button class="tool-btn tool-btn-layer layer-toggle" data-layer="streets">Streets</button>
        <button class="tool-btn tool-btn-layer layer-toggle" data-layer="bike">Bike</button>
        <button class="tool-btn tool-btn-layer layer-toggle" data-layer="rail">Rail</button>
        <button class="tool-btn tool-btn-layer layer-toggle" data-layer="bus">Bus</button>

        <button class="tool-btn tool-btn-orient rotate-btn" data-angle="0">N</button>
        <button class="tool-btn tool-btn-orient rotate-btn" data-angle="180">S</button>
        <button class="tool-btn tool-btn-orient rotate-btn" data-angle="90">E</button>
        <button class="tool-btn tool-btn-orient rotate-btn" data-angle="-90">W</button>



        <input accept=".js,.json" id="fileInput" style="display:none" type="file"/>
      </div>
    </div>
  </div>
<div class="window-resizer" data-window="controlsPanel"></div>
</div>

<aside class="sidebar" id="infoPanel">
  <div class="window-drag-handle" data-window="infoPanel"></div>
<div id="inspector">
<div id="noSelection" style="margin-top:6px">No object selected.</div>
<div id="form" style="display:none;margin-top:8px">
<h3 id="inspectorTitle" style="margin:6px 0">Inspector</h3>

<!-- BUILDINGS: Top actions row -->
<div class="inspector-actions" style="display:flex;gap:0px;flex-wrap:wrap;align-items:center;margin:0px 0">
  <button class="tool-btn muted-btn" id="toggleDragBtn">Drag: Off</button>
  <button class="tool-btn" id="saveBtn">Save</button>
  <button class="tool-btn muted-btn" id="copyBuildingBtn">Copy</button>
  <button class="tool-btn muted-btn" id="pasteBuildingBtn">Paste</button>
  <button class="tool-btn" id="deleteBtn" style="background:var(--danger);color:white">Delete</button>
</div>

<details id="setup">
<summary>Building Set Up</summary>
<label for="bColor">Color</label>
<input id="bColor" type="color"/>
<label for="bAlign">Label position</label>
<select id="bAlign">
<option value="top">Top</option>
<option value="bottom">Bottom</option>
</select>
<label for="bOrient">Label orientation</label>
<select id="bOrient">
<option value="horizontal">Horizontal</option>
<option value="vertical">Vertical (90°)</option>
</select>
<label class="small">Geometry (x, y, Length, Width)</label>
<div style="display:flex;gap:6px">
<input id="bX" type="text"/>
<input id="bY" type="text"/>
<input id="bW" type="text"/>
<input id="bH" type="text"/>
</div>
<label class="small">Angle (°)</label>
<input id="bAngle" type="text"/>
</details>
<details id="fill">
<summary>Building Info</summary>
<label for="bLabel">Label</label>
<input id="bLabel" type="text"/>
<label for="bType">Type</label>
<select id="bType">
<option value="residential">Residential</option>
<option value="commercial">Commercial</option>
<option value="civic">Civic</option>
<option value="vacant">Vacant</option>
<option value="other">Other</option>
<option value="public_transport">Public Transport</option>
</select>
<label for="bUsage">Usage</label>
<select id="bUsage">
<option value="high">High</option>
<option value="medium">Medium</option>
<option value="low">Low</option>
<option value="none">None</option>
</select>
<label for="bFunding">Funding</label>
<select id="bFunding">
<option value="high">High</option>
<option value="medium">Medium</option>
<option value="low">Low</option>
<option value="none">None</option>
</select>
<label for="bOcc">Occupants</label>
<textarea id="bOcc" rows="4"></textarea>
<label for="bNotes">Notes</label>
<textarea id="bNotes" rows="3"></textarea>
</details>
</div>

<details id="traceTools" class="section">
  <summary>Tracing Image</summary>

  <label class="small" style="margin-top:8px">Load background image (real map)</label>
  <input type="file" id="traceImageInput" accept="image/png,image/jpeg,image/webp"/>

  <label class="small" style="margin-top:8px">Rotation (deg)</label>
  <div style="display:flex;gap:6px;align-items:center">
    <input type="range" id="traceRotationInput" min="-180" max="180" step="1" value="0" style="flex:1"/>
    <input type="number" id="traceRotationInputBox" min="-180" max="180" step="0.1" style="width:70px"/>
  </div>

  <label class="small" style="margin-top:8px">Offset X (ft)</label>
  <input type="number" id="traceOffsetX" step="10"/>

  <label class="small" style="margin-top:4px">Offset Y (ft)</label>
  <input type="number" id="traceOffsetY" step="10"/>

  <label class="small" style="margin-top:4px">Scale</label>
  <div style="display:flex;gap:6px;align-items:center">
    <input type="range" id="traceScaleInput" min="0.1" max="10" step="0.05" value="1" style="flex:1"/>
    <input type="number" id="traceScaleInputBox" min="0.1" max="10" step="0.05" style="width:70px"/>
  </div>

  <button class="muted-btn" id="traceToggleBtn" style="margin-top:8px">Hide tracing image</button>
  <button class="muted-btn" id="traceDragBtn" style="margin-top:4px">Drag image: Off</button>
</details>
</div>
<div class="window-resizer" data-window="infoPanel"></div>
</aside>

<aside class="sidebar" id="analyticsPanel">
  <div class="window-drag-handle" data-window="analyticsPanel">
    <span>Lines &amp; Routes</span>
  </div>
  <div class="analytics-body">
    <div id="analyticsEmpty" class="small">No streets or routes loaded.</div>
    <div id="analyticsContent" style="display:none">
      <div class="group-header" style="margin-top:10px">Rail (Subway &amp; Regional)</div>
      <ul id="analyticsRailList"></ul>
      <div class="group-header" style="margin-top:10px">Bus lines</div>
      <ul id="analyticsBusList"></ul>
      <div class="group-header" style="margin-top:10px">Bike lanes</div>
      <ul id="analyticsBikeList"></ul>
      <div class="group-header" style="margin-top:10px">Rivers &amp; Waterways</div>
      <ul id="analyticsWaterList"></ul>
      <div class="group-header">Streets</div>
      <ul id="analyticsStreetList"></ul>
    </div>
  </div>
  <div class="window-resizer" data-window="analyticsPanel"></div>
</aside>

<script src="BrooklynMap.js" onerror="window.__AUTOLOAD_PHILLY_FAILED=true;"></script>
<script>
(function(){
  const svg = document.getElementById('mapSvg');

  // Shared helper for simple 90°/180° rotation-aware navigation
  function adjustForRotation(dx, dy) {
    if (worldAngle === 90) return [dy, -dx];
    if (worldAngle === -90) return [-dy, dx];
    if (worldAngle === 180 || worldAngle === -180) return [-dx, -dy];
    return [dx, dy];
  }

  const blockNameEl = document.getElementById('blockName');
  const noSelection = document.getElementById('noSelection');
  const form = document.getElementById('form');
  const inspector = document.getElementById('inspector');
  const toggleDragBtn = document.getElementById('toggleDragBtn');
  
  const mapNameDisplayEl = document.getElementById('mapNameDisplay');
  const autosaveIndicatorEl = document.getElementById('autosaveIndicator');
  const restoreAutosaveBtn = document.getElementById('restoreAutosaveBtn');
  const cancelAutosaveBtn = document.getElementById('cancelAutosaveBtn');

  // Map file metadata (optional; included when you Save -> data.js)
  if (typeof window.MAP_META !== 'object' || !window.MAP_META) window.MAP_META = {};
  let currentFileSavedAt = Number((window.MAP_META && window.MAP_META.savedAt) || 0) || 0;

    

  const traceInput = document.getElementById('traceImageInput');
  const traceRotationInput = document.getElementById('traceRotationInput');
  const traceRotationInputBox = document.getElementById('traceRotationInputBox');
  const traceToggleBtn = document.getElementById('traceToggleBtn');
  const traceOffsetXInput = document.getElementById('traceOffsetX');
  const traceOffsetYInput = document.getElementById('traceOffsetY');
  const traceScaleInput = document.getElementById('traceScaleInput');
  const traceScaleInputBox = document.getElementById('traceScaleInputBox');
  const traceDragBtn = document.getElementById('traceDragBtn');
  let selectedId = null;
  let selectedType = null;
  let selectedIds = new Set();  // multi-selection of buildings
  let clipboard = null;  // for copy/paste of buildings & streets
  let drag = null;           // building drag
  let nodeDrag = null;       // street node drag
  let activeStreetId = null;

  // buildings that should be visually highlighted as transit stops on the active line
  let stopHighlightIds = new Set();
  let highlightedStreetIdsForStops = []; // street segments currently highlighted as a line/route (used to highlight stops)


  // remembers which end of a street you last extended (start vs end), so Delete node removes the last-added end
  const streetNodeLastSide = Object.create(null);

  // translate mode vars
  let streetTranslateMode = false;
  let streetTranslateDrag = null;

  // remember street details open state across re-renders
  let lastStreetInfoOpen = false;
  let lastStreetSetupOpen = false;

  // dragging is OFF by default
  let dragEnabled = false;

  // Tracing image state
  let traceImageUrl = null;
  let traceImageName = ''; // filename for per-image tracing presets
  let traceImageVisible = true;
  let traceImageX = 0;
  let traceImageY = 0;
  let traceImageBaseWidth = 0;
  let traceImageBaseHeight = 0;
  let traceImageScale = 1;
  let traceImageAngle = 0;
  const traceImageOpacity = 1;
  let traceDragMode = false;
  let traceDrag = null;

  // world rotation angle (degrees)
  let worldAngle = 0;

  // pan dragging
  let panDrag = null;

  // track whether a pan occurred to suppress background click-clear
  let didPan = false;

  // pinch zoom state
  let pinchState = null;

  let state = window.MAP_DATA || {
    blockName: '',
    viewBox: [0,0,1000,700],
    buildings: [],
    streets: []
  };

  // If we autoloaded a sibling data file (Philadelphia.js), set the title now (before autosave keying).
  try {
    if (window.MAP_DATA && mapNameDisplayEl) {
      const metaName = (window.MAP_META && window.MAP_META.name) ? String(window.MAP_META.name).trim() : '';
      const title = metaName || (state && state.blockName) || '';
      if (title) mapNameDisplayEl.textContent = title.replace(/\.[^.]+$/, '');
      if (state && title && !state.blockName) state.blockName = title;
    }
  } catch(_) {}


  // =========================
  // Quick edit bar (mobile-docked) for the currently selected object
  const quickSelMetaEl = document.getElementById('quickSelMeta');
  const quickNameInputEl = document.getElementById('quickNameInput');
  const quickNotesInputEl = document.getElementById('quickNotesInput');
  const quickApplyBtnEl = document.getElementById('quickApplyBtn');
  const quickRoutesBtnEl = document.getElementById('quickRoutesBtn');

  const quickBuildingInfoWrapEl = document.getElementById('quickBuildingInfo');
  const quickTypeInputEl = document.getElementById('quickTypeInput');
  const quickUsageInputEl = document.getElementById('quickUsageInput');
  const quickFundingInputEl = document.getElementById('quickFundingInput');
  const quickOccupantsInputEl = document.getElementById('quickOccupantsInput');

  const quickSetupWrapEl = document.getElementById('quickSetupInputs');
  const quickColorInputEl = document.getElementById('quickColorInput');
  const quickLengthInputEl = document.getElementById('quickLengthInput');
  const quickWidthInputEl = document.getElementById('quickWidthInput');
  const quickAngleInputEl = document.getElementById('quickAngleInput');

  let quickLoaded = {
    type:null, id:null,
    name:'', notes:'',
    color:'', length:'', width:'', angle:'',
    bType:'', usage:'', funding:'', occupants:''
  };

  function getQuickSelection(){
    try {
      if (selectedType === 'building' && selectedId) {
        const b = (state.buildings || []).find(x => x.id === selectedId);
        if (!b) return null;
        return { type: 'building', id: selectedId, obj: b };
      }
      if (selectedType === 'street' && selectedId) {
        const s = (state.streets || []).find(x => x.id === selectedId);
        if (!s) return null;
        return { type: 'street', id: selectedId, obj: s };
      }
      return null;
    } catch(_) { return null; }
  }

  function quickGetStreetAngleDeg(s){
    try{
      if (!s || !Array.isArray(s.nodes) || s.nodes.length < 2) return 0;
      const a = s.nodes[0];
      const b = s.nodes[s.nodes.length - 1];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      return Math.atan2(dy, dx) * 180 / Math.PI;
    } catch(_) { return 0; }
  }

  function quickRotateStreetToAngle(s, targetDeg){
    if (!s || !Array.isArray(s.nodes) || s.nodes.length < 2) return;
    const first = s.nodes[0];
    const cx = first.x;
    const cy = first.y;
    const last = s.nodes[s.nodes.length - 1];
    const dx = last.x - cx;
    const dy = last.y - cy;
    const currentRad = Math.atan2(dy, dx);
    const targetRad = targetDeg * Math.PI / 180;
    const delta = targetRad - currentRad;

    const cosD = Math.cos(delta);
    const sinD = Math.sin(delta);
    for (let i = 1; i < s.nodes.length; i++) {
      const node = s.nodes[i];
      const rx = (node.x - cx) * cosD - (node.y - cy) * sinD;
      const ry = (node.x - cx) * sinD + (node.y - cy) * cosD;
      node.x = Math.round(cx + rx);
      node.y = Math.round(cy + ry);
    }
  }

  function quickSetStreetLength(s, lenVal){
    if (!s || !Array.isArray(s.nodes) || s.nodes.length < 2) return;
    if (!(lenVal > 0) || Number.isNaN(lenVal)) return;
    const nodes = s.nodes;
    const a = nodes[0];
    const b = nodes[nodes.length - 1];
    const curDx = b.x - a.x;
    const curDy = b.y - a.y;
    const curLen = Math.sqrt(curDx * curDx + curDy * curDy);
    if (!(curLen > 0)) return;
    const scale = lenVal / curLen;
    b.x = Math.round(a.x + curDx * scale);
    b.y = Math.round(a.y + curDy * scale);
  }

  function refreshQuickEditBar(){
    if (!quickSelMetaEl || !quickNameInputEl || !quickNotesInputEl || !quickApplyBtnEl) return;

    const sel = getQuickSelection();
    if (!sel){
      quickLoaded = { type:null, id:null, name:'', notes:'', color:'', length:'', width:'', angle:'', bType:'', usage:'', funding:'', occupants:'' };
      quickSelMetaEl.textContent = 'No selection';

      // Ensure no lingering street/route highlights when nothing is selected
      try { activeStreetId = null; } catch(_) {}
      try { clearSelectedStreetHighlight(); } catch(_) {}
      try { clearRouteHighlight(); } catch(_) {}

      // clear + disable
      [quickNameInputEl, quickNotesInputEl, quickTypeInputEl, quickUsageInputEl, quickFundingInputEl,
       quickOccupantsInputEl, quickColorInputEl, quickLengthInputEl, quickWidthInputEl, quickAngleInputEl]
        .forEach(el => { if (el){ el.value = ''; el.disabled = true; } });

      if (quickBuildingInfoWrapEl) quickBuildingInfoWrapEl.style.display = 'none';
      if (quickSetupWrapEl) quickSetupWrapEl.style.display = 'none';

      quickApplyBtnEl.disabled = true;
      return;
    }

    const isBuilding = (sel.type === 'building');
    quickSelMetaEl.textContent = isBuilding ? 'Building' : 'Street';

    // Always show setup inputs when something is selected
    if (quickSetupWrapEl) quickSetupWrapEl.style.display = '';
    if (quickBuildingInfoWrapEl) quickBuildingInfoWrapEl.style.display = isBuilding ? '' : 'none';

    const nameVal = isBuilding ? (sel.obj.label || '') : (sel.obj.name || '');
    const notesVal = (sel.obj.notes || '');

    let colorVal = '';
    let lengthVal = '';
    let widthVal = '';
    let angleVal = '';

    if (isBuilding){
      colorVal = toHexColor(sel.obj.color || getFillForType(sel.obj.type));
      lengthVal = String((typeof sel.obj.h === 'number') ? sel.obj.h : (sel.obj.h || ''));
      widthVal = String((typeof sel.obj.w === 'number') ? sel.obj.w : (sel.obj.w || ''));
      angleVal = String((typeof sel.obj.angle === 'number') ? sel.obj.angle : (sel.obj.angle || 0));
    } else {
      colorVal = toHexColor(sel.obj.color || 'rgba(60,66,72,0.95)');
      lengthVal = String(Math.round(computeStreetEndToEndLength(sel.obj) || 0));
      widthVal = String((typeof sel.obj.width === 'number') ? Math.round(sel.obj.width) : (sel.obj.width || 60));
      angleVal = String(Number(quickGetStreetAngleDeg(sel.obj)).toFixed(1));
    }

    quickLoaded = {
      type: sel.type,
      id: sel.id,
      name: String(nameVal),
      notes: String(notesVal),
      color: String(colorVal),
      length: String(lengthVal),
      width: String(widthVal),
      angle: String(angleVal),
      bType: isBuilding ? String(sel.obj.type || 'other') : '',
      usage: isBuilding ? String(sel.obj.usage || 'none') : '',
      funding: isBuilding ? String(sel.obj.funding || 'none') : '',
      occupants: isBuilding ? String(sel.obj.occupants || '') : ''
    };

    // Populate + enable base fields
    if (quickNameInputEl){ quickNameInputEl.value = nameVal; quickNameInputEl.disabled = false; }
    if (quickNotesInputEl){ quickNotesInputEl.value = notesVal; quickNotesInputEl.disabled = false; }

    // Setup fields (both)
    if (quickColorInputEl){ quickColorInputEl.value = colorVal || '#888888'; quickColorInputEl.disabled = false; }
    if (quickLengthInputEl){ quickLengthInputEl.value = lengthVal; quickLengthInputEl.disabled = false; }
    if (quickWidthInputEl){ quickWidthInputEl.value = widthVal; quickWidthInputEl.disabled = false; }
    if (quickAngleInputEl){ quickAngleInputEl.value = angleVal; quickAngleInputEl.disabled = false; }

    // Building-only fields
    if (isBuilding){
      if (quickTypeInputEl){ quickTypeInputEl.value = (sel.obj.type || 'other'); quickTypeInputEl.disabled = false; }
      if (quickUsageInputEl){ quickUsageInputEl.value = (sel.obj.usage || 'none'); quickUsageInputEl.disabled = false; }
      if (quickFundingInputEl){ quickFundingInputEl.value = (sel.obj.funding || 'none'); quickFundingInputEl.disabled = false; }
      if (quickOccupantsInputEl){ quickOccupantsInputEl.value = (sel.obj.occupants || ''); quickOccupantsInputEl.disabled = false; }
    } else {
      [quickTypeInputEl, quickUsageInputEl, quickFundingInputEl, quickOccupantsInputEl]
        .forEach(el => { if (el){ el.value = ''; el.disabled = true; } });
    }

    quickApplyBtnEl.disabled = true;
  }

  function updateQuickApplyEnabled(){
    if (!quickApplyBtnEl) return;
    const sel = getQuickSelection();
    if (!sel) { quickApplyBtnEl.disabled = true; return; }

    const isBuilding = (sel.type === 'building');

    const now = {
      name: String(quickNameInputEl ? (quickNameInputEl.value || '') : ''),
      notes: String(quickNotesInputEl ? (quickNotesInputEl.value || '') : ''),
      color: String(quickColorInputEl ? (quickColorInputEl.value || '') : ''),
      length: String(quickLengthInputEl ? (quickLengthInputEl.value || '') : ''),
      width: String(quickWidthInputEl ? (quickWidthInputEl.value || '') : ''),
      angle: String(quickAngleInputEl ? (quickAngleInputEl.value || '') : ''),
      bType: isBuilding ? String(quickTypeInputEl ? (quickTypeInputEl.value || '') : '') : '',
      usage: isBuilding ? String(quickUsageInputEl ? (quickUsageInputEl.value || '') : '') : '',
      funding: isBuilding ? String(quickFundingInputEl ? (quickFundingInputEl.value || '') : '') : '',
      occupants: isBuilding ? String(quickOccupantsInputEl ? (quickOccupantsInputEl.value || '') : '') : ''
    };

    const dirty =
      now.name !== String(quickLoaded.name) ||
      now.notes !== String(quickLoaded.notes) ||
      now.color !== String(quickLoaded.color) ||
      now.length !== String(quickLoaded.length) ||
      now.width !== String(quickLoaded.width) ||
      now.angle !== String(quickLoaded.angle) ||
      (isBuilding && (
        now.bType !== String(quickLoaded.bType) ||
        now.usage !== String(quickLoaded.usage) ||
        now.funding !== String(quickLoaded.funding) ||
        now.occupants !== String(quickLoaded.occupants)
      ));

    quickApplyBtnEl.disabled = !dirty;
  }

  // Enable Apply when any input changes
  [quickNameInputEl, quickNotesInputEl, quickColorInputEl, quickLengthInputEl, quickWidthInputEl, quickAngleInputEl,
   quickTypeInputEl, quickUsageInputEl, quickFundingInputEl, quickOccupantsInputEl]
    .forEach(el => { if (el) el.addEventListener('input', updateQuickApplyEnabled); });

  if (quickApplyBtnEl) quickApplyBtnEl.addEventListener('click', (evt)=>{
    evt.preventDefault(); evt.stopPropagation();
    const sel = getQuickSelection();
    if (!sel) return;

    const isBuilding = (sel.type === 'building');

    // Snapshot new values
    const newName = String(quickNameInputEl ? (quickNameInputEl.value || '') : '');
    const newNotes = String(quickNotesInputEl ? (quickNotesInputEl.value || '') : '');
    const newColor = String(quickColorInputEl ? (quickColorInputEl.value || '') : '');

    const newLength = Number(quickLengthInputEl ? quickLengthInputEl.value : NaN);
    const newWidth  = Number(quickWidthInputEl ? quickWidthInputEl.value : NaN);
    const newAngle  = Number(quickAngleInputEl ? quickAngleInputEl.value : NaN);

    const newBType = isBuilding ? String(quickTypeInputEl ? (quickTypeInputEl.value || '') : '') : '';
    const newUsage = isBuilding ? String(quickUsageInputEl ? (quickUsageInputEl.value || '') : '') : '';
    const newFunding = isBuilding ? String(quickFundingInputEl ? (quickFundingInputEl.value || '') : '') : '';
    const newOccupants = isBuilding ? String(quickOccupantsInputEl ? (quickOccupantsInputEl.value || '') : '') : '';

    // If nothing changed, just refresh
    updateQuickApplyEnabled();
    if (quickApplyBtnEl.disabled) { refreshQuickEditBar(); return; }

    pushHistory('Quick edit');

    if (isBuilding) {
      sel.obj.label = newName;
      sel.obj.notes = newNotes;

      if (newBType) sel.obj.type = newBType;
      sel.obj.usage = newUsage || sel.obj.usage;
      sel.obj.funding = newFunding || sel.obj.funding;
      sel.obj.occupants = newOccupants;

      if (newColor) sel.obj.color = newColor;

      if (!Number.isNaN(newWidth) && newWidth > 0) sel.obj.w = newWidth;
      if (!Number.isNaN(newLength) && newLength > 0) sel.obj.h = newLength;
      if (!Number.isNaN(newAngle)) sel.obj.angle = newAngle;

      // keep inspector fields in sync if it's open
      const bLabelEl = document.getElementById('bLabel'); if (bLabelEl) bLabelEl.value = newName;
      const bNotesEl = document.getElementById('bNotes'); if (bNotesEl) bNotesEl.value = newNotes;
      const bTypeEl = document.getElementById('bType'); if (bTypeEl && newBType) bTypeEl.value = newBType;
      const bUsageEl = document.getElementById('bUsage'); if (bUsageEl) bUsageEl.value = newUsage || bUsageEl.value;
      const bFundingEl = document.getElementById('bFunding'); if (bFundingEl) bFundingEl.value = newFunding || bFundingEl.value;
      const bOccEl = document.getElementById('bOcc'); if (bOccEl) bOccEl.value = newOccupants;
      const bColorEl = document.getElementById('bColor'); if (bColorEl && newColor) bColorEl.value = newColor;
      const bWEl = document.getElementById('bW'); if (bWEl && !Number.isNaN(newWidth) && newWidth > 0) bWEl.value = String(newWidth);
      const bHEl = document.getElementById('bH'); if (bHEl && !Number.isNaN(newLength) && newLength > 0) bHEl.value = String(newLength);
      const bAngleEl = document.getElementById('bAngle'); if (bAngleEl && !Number.isNaN(newAngle)) bAngleEl.value = String(newAngle);
      refreshInspectorTitle(newName);
    } else {
      sel.obj.name = newName;
      sel.obj.notes = newNotes;
      if (newColor) sel.obj.color = newColor;

      if (!Number.isNaN(newWidth) && newWidth > 0) sel.obj.width = newWidth;
      quickSetStreetLength(sel.obj, newLength);
      if (!Number.isNaN(newAngle)) quickRotateStreetToAngle(sel.obj, newAngle);

      // keep street inspector fields in sync if open
      const sNameEl = document.getElementById('streetName'); if (sNameEl) sNameEl.value = newName;
      const sNotesEl = document.getElementById('streetNotes'); if (sNotesEl) sNotesEl.value = newNotes;
      const sColorEl = document.getElementById('streetColor'); if (sColorEl && newColor) sColorEl.value = newColor;

      const sLenEl = document.getElementById('streetGW'); if (sLenEl && !Number.isNaN(newLength) && newLength > 0) sLenEl.value = String(Math.round(newLength));
      const sWidEl = document.getElementById('streetGH'); if (sWidEl && !Number.isNaN(newWidth) && newWidth > 0) sWidEl.value = String(Math.round(newWidth));
      const sAngEl = document.getElementById('streetAngle'); if (sAngEl && !Number.isNaN(newAngle)) sAngEl.value = String(newAngle);

      const st = document.getElementById('streetInspectorTitle');
      if (st) st.textContent = (newName && String(newName).trim()) ? newName : 'Street';
    }

    if (typeof scheduleAutosave === 'function') scheduleAutosave('quick edit');
    renderAll();
    applySelectedStreetHighlight(id);
    refreshQuickEditBar();
  });

  // Routes button moved into the info/label panel (mobile)
  if (quickRoutesBtnEl) quickRoutesBtnEl.addEventListener('click', (evt)=>{
    evt.preventDefault(); evt.stopPropagation();
    const wasOpen = document.body.classList.contains('mobile-pane-analytics');
    document.body.classList.remove('mobile-pane-info','mobile-pane-analytics');
    if (!wasOpen) document.body.classList.add('mobile-pane-analytics');
  });

// initialize
  refreshQuickEditBar();


  // =========================
  // Autosave (localStorage)
  const AUTOSAVE_VERSION = 1;
  const AUTOSAVE_DEBOUNCE_MS = 450;
  let autosaveTimer = null;
  let autosaveAppliedThisSession = false;
  
  function safeId(raw){
    return String(raw || '')
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9_-]+/g, '_')
      .replace(/^_+|_+$/g, '')
      .slice(0, 80) || 'default';
  }
  
  function getCurrentMapId(){
    try {
      if (window.MAP_META && typeof window.MAP_META.id === 'string' && window.MAP_META.id) return safeId(window.MAP_META.id);
      if (window.MAP_META && typeof window.MAP_META.name === 'string' && window.MAP_META.name) return safeId(window.MAP_META.name);
    } catch(_) {}
    const name = (mapNameDisplayEl && mapNameDisplayEl.textContent) ? mapNameDisplayEl.textContent : '';
    return safeId(name || (state && state.blockName) || 'default');
  }
  
  function getAutosaveKey(){
    return 'SICAMap_autosave_v' + AUTOSAVE_VERSION + '__' + getCurrentMapId();
  }
  
  function formatClock(ts){
    if (!ts) return '—';
    try {
      return new Date(ts)
        .toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true })
        .toLowerCase();
    } catch(_) {
      return '—';
    }
  }
  
  function setAutosaveIndicator(ts){
    if (!autosaveIndicatorEl) return;
    autosaveIndicatorEl.textContent = 'Last saved: ' + (ts ? formatClock(ts) : '—');
  }
  
  function readAutosave(){
    try {
      const raw = localStorage.getItem(getAutosaveKey());
      if (!raw) return null;
      const obj = JSON.parse(raw);
      if (!obj || typeof obj !== 'object') return null;
      if (!obj.ts || !obj.state) return null;
      return obj;
    } catch(_) {
      return null;
    }
  }
  
  function writeAutosave(obj){
    try {
      localStorage.setItem(getAutosaveKey(), JSON.stringify(obj));
    } catch(_) {}
  }
  
  function buildStateToSave(){
    // Clone state so we can strip out any tracing image URL/data before saving
    const s = JSON.parse(JSON.stringify(state));
    if (s && s.trace && s.trace.url) {
      delete s.trace.url;
    }
    return s;
  }
  
  function scheduleAutosave(reason){
    if (autosaveTimer) clearTimeout(autosaveTimer);
    autosaveTimer = setTimeout(() => {
      try {
        const ts = Date.now();
        const payload = {
          v: AUTOSAVE_VERSION,
          ts,
          reason: String(reason || ''),
          mapId: getCurrentMapId(),
          fileSavedAt: currentFileSavedAt || 0,
          state: buildStateToSave()
        };
        writeAutosave(payload);
        setAutosaveIndicator(ts);
      } catch(_) {}
    }, AUTOSAVE_DEBOUNCE_MS);
  }
  
  function setRestorePromptVisible(visible){
    if (restoreAutosaveBtn) restoreAutosaveBtn.style.display = visible ? 'inline-flex' : 'none';
    if (cancelAutosaveBtn) cancelAutosaveBtn.style.display = visible ? 'inline-flex' : 'none';
  }
  
  function getDismissKey(){
    return 'SICAMap_autosave_dismissed_ts__' + getCurrentMapId();
  }
  
  function shouldOfferRestore(payload){
    if (!payload || !payload.ts) return false;
    const dismissed = Number(sessionStorage.getItem(getDismissKey()) || 0) || 0;
    if (payload.ts <= dismissed) return false;
    // Only offer restore when autosave is newer than what's in the loaded file
    if ((currentFileSavedAt || 0) && payload.ts <= currentFileSavedAt) return false;
    return true;
  }
  
  function refreshAutosaveUI(showRestorePrompt){
    const payload = readAutosave();
    setAutosaveIndicator(payload ? payload.ts : 0);
    if (showRestorePrompt && shouldOfferRestore(payload)) {
      setRestorePromptVisible(true);
    } else {
      setRestorePromptVisible(false);
    }
  }
  
  function applyAutosave(payload){
    if (!payload || !payload.state) return;
    try {
      state = normalizeState(payload.state);
      // Keep tracing image / overlay consistent with restored state
      hydrateTraceFromState();
      // Clear selection (restored state may not match selected IDs)
      selectedId = null;
      selectedType = null;
      if (selectedIds) selectedIds.clear();
      activeStreetId = null;
      try { clearSelectedStreetHighlight(); } catch(_) {}
      try { clearRouteHighlight(); } catch(_) {}
      activeStreetId = null;
      autosaveAppliedThisSession = true;
      renderAll();
      setAutosaveIndicator(payload.ts || 0);
      setRestorePromptVisible(false);
    } catch(err) {
      console.error(err);
      alert('Failed to restore autosave: ' + (err && err.message ? err.message : String(err)));
    }
  }
  
  // Initial autosave UI on page load
  refreshAutosaveUI(true);
  if (restoreAutosaveBtn) {
    restoreAutosaveBtn.addEventListener('click', () => {
      const payload = readAutosave();
      applyAutosave(payload);
    });
  }
  if (cancelAutosaveBtn) {
    cancelAutosaveBtn.addEventListener('click', () => {
      const payload = readAutosave();
      const ts = payload && payload.ts ? payload.ts : Date.now();
      try { sessionStorage.setItem(getDismissKey(), String(ts)); } catch(_) {}
      setRestorePromptVisible(false);
    });
  }
  

  // =========================
  // Undo / Redo (edit history)
  // =========================
  const UNDO_LIMIT = 200;
  let undoStack = [];
  let redoStack = [];
  let historyLock = false;

  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  function getUndoSnapshotJson(){
    // Deep-clone state. Keep the current camera position (viewBox) OUT of history
    // so Undo/Redo doesn't jump your view around.
    const snap = JSON.parse(JSON.stringify(state || {}));
    if (snap && snap.viewBox) delete snap.viewBox;
    return JSON.stringify(snap);
  }

  function updateUndoRedoUI(){
    if (undoBtn) undoBtn.disabled = (undoStack.length === 0);
    if (redoBtn) redoBtn.disabled = (redoStack.length === 0);
  }

  function pushHistoryFromJson(json, label){
    if (historyLock) return;
    const last = undoStack.length ? undoStack[undoStack.length - 1].json : null;
    if (last === json) return; // avoid duplicate no-op entries
    undoStack.push({ json, label: label || '' });
    if (undoStack.length > UNDO_LIMIT) undoStack.shift();
    redoStack.length = 0;
    updateUndoRedoUI();
    scheduleAutosave(label || 'Edit');
  }

  function pushHistory(label){
    pushHistoryFromJson(getUndoSnapshotJson(), label);
  }

  function restoreFromHistoryJson(json){
    const vb = (state && Array.isArray(state.viewBox)) ? state.viewBox.slice() : [0,0,1000,700];
    let next = null;
    try { next = JSON.parse(json); } catch(_) { return; }
    next.viewBox = vb;

    state = normalizeState(next);

    // Keep tracing image / overlay consistent with restored state
    hydrateTraceFromState();

    renderAll();
    reconcileSelectionAfterUndoRedo();
  }

  function reconcileSelectionAfterUndoRedo(){
    // Try to preserve your selection if the thing still exists; otherwise clear inspector UI.
    if (selectedType === 'building' && selectedId) {
      const exists = (state.buildings || []).some(b => b.id === selectedId);
      if (exists) { selectBuilding(selectedId); return; }
    }
    if (selectedType === 'street' && selectedId) {
      const exists = (state.streets || []).some(s => s.id === selectedId);
      if (exists) { selectStreet(selectedId); return; }
    }
    if (selectedType === 'multi' && selectedIds && selectedIds.size > 0) {
      const existing = new Set((state.buildings || []).map(b => b.id));
      const kept = new Set([...selectedIds].filter(id => existing.has(id)));
      selectedIds = kept;
      if (selectedIds.size > 0) {
        selectedType = 'multi';
        selectedId = null;
        showMultiInspector();
        renderAll();
        return;
      }
    }

    selectedId = null;
    selectedType = null;
    if (selectedIds) selectedIds.clear();
    activeStreetId = null;
    form.style.display = 'none';
    noSelection.style.display = 'block';
    removeStreetInspector();
    clearSelectedStreetHighlight();
    clearRouteHighlight();
    renderAll();
    refreshQuickEditBar();
  }

  function undo(){
    if (!undoStack.length) return;
    const current = getUndoSnapshotJson();
    const entry = undoStack.pop();
    redoStack.push({ json: current, label: entry.label || '' });

    historyLock = true;
    restoreFromHistoryJson(entry.json);
    historyLock = false;

    updateUndoRedoUI();
  }

  function redo(){
    if (!redoStack.length) return;
    const current = getUndoSnapshotJson();
    const entry = redoStack.pop();
    undoStack.push({ json: current, label: entry.label || '' });
    if (undoStack.length > UNDO_LIMIT) undoStack.shift();

    historyLock = true;
    restoreFromHistoryJson(entry.json);
    historyLock = false;

    updateUndoRedoUI();
  }

  if (undoBtn) undoBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); undo(); });
  if (redoBtn) redoBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); redo(); });
  updateUndoRedoUI();

  // Keyboard shortcuts: Undo / Redo
// - Undo: Ctrl/Cmd+Z
// - Redo: Ctrl/Cmd+Y  OR  Ctrl/Cmd+Shift+Z
window.addEventListener('keydown', (e) => {
  const ae = document.activeElement;
  const tag = ae && ae.tagName;
  const isEditable = (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (ae && ae.isContentEditable));
  if (isEditable) return;

  const mod = e.ctrlKey || e.metaKey;
  if (!mod) return;

  const key = String(e.key || '').toLowerCase();
  if (key === 'z') {
    e.preventDefault();
    if (e.shiftKey) redo();
    else undo();
  } else if (key === 'y') {
    e.preventDefault();
    redo();
  }
}, { capture: true });

const NS = 'http://www.w3.org/2000/svg';

  // Simple layer visibility model for different transportation modes
  const layerVisibility = {
    streets: true,
    water: true,
    bike: true,
    rail: true,
    bus: true
  };
  // Used to auto-classify waterways into their own layer
  const WATER_LAYER_RE = /\b(river|lake|pond|ocean|sea|bay|harbor|harbour|creek|stream|canal|waterway|inlet|gulf|sound|strait|lagoon|reservoir|marsh|wetland)\b/;


  function getStreetLayer(s){
    const name = (s.name || '').toLowerCase();
    const notes = (s.notes || '').toLowerCase();
    const color = (s.color || '').toLowerCase();
    // Rivers & waterways: keyword match in name/notes
    if (WATER_LAYER_RE.test(name) || WATER_LAYER_RE.test(notes)) return 'water';
    // Bike lanes: explicit in name/notes
    if (name.includes('bike lane') || notes.includes('bike lane')) return 'bike';
    // Bus routes: anything explicitly called a bus
    if (name.includes(' bus') || name.endsWith('bus') || name.includes('buses') || notes.includes(' bus')) return 'bus';
    // Rail (regional + subway/metro)
    if (name.includes('regional rail') || notes.includes('regional rail')) return 'rail';
    if (name.includes('train tracks') || notes.includes('train')) return 'rail';
    if (name.includes('subway') || notes.includes('subway')) return 'rail';
    if (name.includes('metro') || notes.includes('metro')) return 'rail';
    if (name.includes('trolley') || notes.includes('trolley')) return 'rail';
    if (name.includes('tram') || notes.includes('tram')) return 'rail';
    // Named "lines" like Broad St. Line, etc.
    if (name.includes(' line')) return 'rail';
    // Fallback: basic street network
    return 'streets';
  }

  function isLayerVisibleForStreet(s){
    const layer = getStreetLayer(s);
    return layerVisibility[layer] !== false;
  }

  
  const STOP_KEYWORDS_RE = /\b(stop|station|transportation center|transportation centre|transit center|hub)\b/i;

  function getLineNameTokensForMatching(street){
    const raw = (street && street.name ? String(street.name) : '').trim();
    if (!raw) return [];
    const toks = [];

    // full name
    toks.push(raw.toLowerCase());

    // split common separators (for names like "Norristown Line & Lansdale/Doylestown Line")
    raw.split(/\s*(?:&|\/|,|\band\b)\s*/i).forEach(part => {
      const p = String(part || '').trim();
      if (p) toks.push(p.toLowerCase());
    });

    // extract route-ish tokens (numbers/letter suffixes like "47", "MFL", "B", "10")
    const routeBits = raw.match(/\b\d{1,3}[a-zA-Z]?\b/g) || [];
    routeBits.forEach(b => toks.push(String(b).toLowerCase()));

    // de-dupe & remove overly-short tokens (except pure numbers)
    const uniq = [];
    const seen = new Set();
    for (const t of toks) {
      const tt = t.trim();
      if (!tt) continue;
      const isNum = /^\d+$/.test(tt);
      if (!isNum && tt.length < 3) continue;
      if (seen.has(tt)) continue;
      seen.add(tt);
      uniq.push(tt);
    }
    return uniq;
  }

  function computeStopHighlightIds(){
    stopHighlightIds = new Set();

    let streetIds = [];
    if (selectedType === 'street' && activeStreetId) {
      streetIds = [activeStreetId];
    } else if (Array.isArray(highlightedStreetIdsForStops) && highlightedStreetIdsForStops.length) {
      streetIds = highlightedStreetIdsForStops.slice();
    } else {
      return;
    }

    const streetsById = Object.create(null);
    (state.streets || []).forEach(s => { streetsById[s.id] = s; });

    const buildingTextCache = (state.buildings || []).map(b => {
      const label = (b.label || '').toString();
      const notes = (b.notes || '').toString();
      return { id: b.id, hay: (label + ' ' + notes).toLowerCase() };
    });

    streetIds.forEach(stId => {
      const s = streetsById[stId];
      if (!s) return;

      const layer = getStreetLayer(s);
      if (layer !== 'bus' && layer !== 'rail') return;

      const tokens = getLineNameTokensForMatching(s);
      if (!tokens.length) return;

      buildingTextCache.forEach(bb => {
        if (stopHighlightIds.has(bb.id)) return;
        if (!STOP_KEYWORDS_RE.test(bb.hay)) return;

        for (const tok of tokens) {
          if (tok && bb.hay.includes(tok)) {
            stopHighlightIds.add(bb.id);
            break;
          }
        }
      });
    });
  }
function getFillForType(type){
    switch(type){
      case 'commercial': return 'rgba(246,194,62,0.95)';
      case 'civic': return 'rgba(110,231,183,0.95)';
      case 'vacant': return 'rgba(255,255,255,0.03)';
      case 'residential': return 'rgba(110,190,231,0.95)';
      case 'school': return 'rgba(180,120,255,0.95)';
      default: return 'rgba(255,255,255,0.06)';
    }
  }

  function createWorldGroup() {
    const g = document.createElementNS(NS, 'g');
    g.id = 'world';
    return g;
  }

  function clientToSvg(clientX, clientY){
    const pt = svg.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const screenCTM = svg.getScreenCTM();
    if (!screenCTM) return { x: clientX, y: clientY };
    const svgP = pt.matrixTransform(screenCTM.inverse());
    return { x: svgP.x, y: svgP.y };
  }

  function getWorldPoint(evt){
    const pt = svg.createSVGPoint();
    if (evt.touches && evt.touches.length){ pt.x = evt.touches[0].clientX; pt.y = evt.touches[0].clientY; }
    else { pt.x = evt.clientX; pt.y = evt.clientY; }
    const screenCTM = svg.getScreenCTM();
    if (!screenCTM) return { x: pt.x, y: pt.y };
    const svgP = pt.matrixTransform(screenCTM.inverse());

    const world = document.getElementById('world');
    if (!world) return { x: svgP.x, y: svgP.y };
    const worldCTM = world.getCTM();
    if (!worldCTM) return { x: svgP.x, y: svgP.y };
    const inv = worldCTM.inverse();
    const worldP = svg.createSVGPoint();
    worldP.x = svgP.x; worldP.y = svgP.y;
    const w = worldP.matrixTransform(inv);
    return { x: w.x, y: w.y };
  }

  function applyWorldRotation(){
    const world = document.getElementById('world');
    if (!world) return;
    const vb = svg.viewBox.baseVal;
    const cx = vb.x + vb.width/2;
    const cy = vb.y + vb.height/2;
    world.setAttribute('transform', `rotate(${worldAngle}, ${cx}, ${cy})`);
  }

function getViewBoxNumbers(){
  const vb = svg.viewBox && svg.viewBox.baseVal;
  if (vb && Number.isFinite(vb.width) && vb.width > 0 && Number.isFinite(vb.height) && vb.height > 0){
    return { x: vb.x, y: vb.y, w: vb.width, h: vb.height };
  }
  const vbStr = svg.getAttribute('viewBox') || '0 0 1000 700';
  const parts = vbStr.trim().split(/[,\s]+/).map(Number);
  return { x: parts[0] || 0, y: parts[1] || 0, w: parts[2] || 1000, h: parts[3] || 700 };
}

function getViewCenter(){
  const vb = getViewBoxNumbers();
  return { x: vb.x + vb.w / 2, y: vb.y + vb.h / 2, vb };
}

  function isBackgroundTarget(target){
    if (!target) return false;
    if (target === svg) return true;
    if (target.id === 'world') return true;
    const interactiveClasses = new Set(['building','node-handle','street']);
    if (target.closest && target.closest('#world')){
      if (target.classList){
        for (const cls of interactiveClasses){ if (target.classList.contains(cls)) return false; }
      }
      return true;
    }
    return false;
  }

  function createWrappedText(svgEl, text, bx, by, bw, bh, fontSize, lineHeight, align, orient) {
    const NS = svgEl.namespaceURI;
    const g = document.createElementNS(NS, 'g');
    const textEl = document.createElementNS(NS, 'text');

    const oneLine = (text || '').replace(/\s*\n\s*/g, ' ').trim() || '';

    textEl.setAttribute('font-size', fontSize);
    textEl.setAttribute('font-family', 'Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial');
    textEl.setAttribute('text-anchor', 'middle');
    textEl.setAttribute('pointer-events', 'none');

    const minCenterWidth = 480;
    const cx = bx + bw / 2;
    const cy = by + bh / 2;

    if (bw <= minCenterWidth) {
      textEl.setAttribute('x', cx);
      textEl.setAttribute('y', cy);
      textEl.setAttribute('dominant-baseline', 'middle');
      if (orient === 'vertical') {
        textEl.setAttribute('transform', `rotate(90 ${cx} ${cy})`);
      }
      textEl.textContent = oneLine;
      g.appendChild(textEl);
      return g;
    }

    const padding = 6;
    const pyTop = by + padding + fontSize / 2;
    const pyBottom = by + bh - padding - fontSize / 2;
    const positionY = (align === 'bottom') ? pyBottom : pyTop;

    if (orient === 'horizontal') {
      textEl.setAttribute('x', cx);
      textEl.setAttribute('y', positionY);
      textEl.setAttribute('dominant-baseline', 'middle');
      textEl.textContent = oneLine;
      g.appendChild(textEl);
      return g;
    } else {
      textEl.setAttribute('x', cx);
      textEl.setAttribute('y', positionY);
      textEl.setAttribute('dominant-baseline', 'middle');
      textEl.setAttribute('transform', `rotate(90 ${cx} ${cy})`);
      textEl.textContent = oneLine;
      g.appendChild(textEl);
      return g;
    }
  }

  function renderStreetsInto(world){
    (state.streets || []).forEach(s=>{
      if (!isLayerVisibleForStreet(s)) return;
      const layer = getStreetLayer(s);
      const nodes = s.nodes || [];
      const pathD = nodes.map((n,i) => (i===0 ? 'M' : 'L') + n.x + ' ' + n.y).join(' ');
      const path = document.createElementNS(NS,'path');
      path.setAttribute('d', pathD);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', s.color || 'rgba(60,66,72,0.95)');
      path.setAttribute('stroke-width', s.width || 50);
      path.setAttribute('stroke-linecap', 'butt');
      path.setAttribute('stroke-linejoin', 'miter');
      path.classList.add('street');
      path.dataset.id = s.id;
      path.dataset.layer = layer;
      world.appendChild(path);

      const hit = document.createElementNS(NS,'path');
      hit.setAttribute('d', pathD);
      hit.setAttribute('fill','none');
      hit.setAttribute('stroke','transparent');
      hit.setAttribute('stroke-width', (s.width || 50) + 18);
      hit.style.cursor = 'pointer';
      hit.dataset.id = s.id;
      hit.dataset.layer = layer;
      hit.addEventListener('click', e => {
        e.stopPropagation();
        // For map clicks, select in inspector but DO NOT update Lines & Routes
        suppressAnalyticsFromSelectStreet = true;
        try {
          selectStreet(s.id);
        } finally {
          suppressAnalyticsFromSelectStreet = false;
        }
      });

      hit.addEventListener('mousedown', e => {
        if (streetTranslateMode) { e.stopPropagation(); startStreetTranslate(e, s.id); }});
      hit.addEventListener('touchstart', e => { e.stopPropagation(); if (streetTranslateMode) startStreetTranslate(e, s.id); }, {passive:false});

      world.appendChild(hit);

      if (s.name) {
        const textPathId = 'tp_' + s.id;
        path.setAttribute('id', textPathId);
        const txt = document.createElementNS(NS,'text');
        txt.dataset.layer = layer;
        txt.dataset.streetId = s.id;
        const tp = document.createElementNS(NS,'textPath');
        tp.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href', '#' + textPathId);
        tp.setAttribute('startOffset','50%');
        tp.setAttribute('text-anchor','middle');
        tp.setAttribute('fill','rgba(255,255,255,0.85)');
        tp.setAttribute('font-size',12);
        tp.textContent = s.name;
        txt.appendChild(tp);
        world.appendChild(txt);
      }
    });
  }

  function renderBuildingsInto(world){
    (state.buildings || []).forEach(b=>{
      const rect = document.createElementNS(NS,'rect');
      rect.setAttribute('x', b.x); rect.setAttribute('y', b.y);
      rect.setAttribute('width', b.w); rect.setAttribute('height', b.h);
      rect.setAttribute('rx', 6); rect.setAttribute('ry', 6);
      rect.classList.add('building'); rect.dataset.id = b.id;
      if (stopHighlightIds && stopHighlightIds.has(b.id)) {
        rect.classList.add('stop-highlight');
      }
      if (selectedIds && selectedIds.has(b.id)) {
        rect.classList.add('selected');
      }
      rect.setAttribute('fill', b.color || getFillForType(b.type));
      rect.setAttribute('stroke', b.stroke || 'rgba(0,0,0,0.6)');
      rect.setAttribute('stroke-width', 2);
      rect.style.cursor = 'move';
      rect.style.pointerEvents = 'auto';

      const angle = Number(b.angle) || 0;
      let baseTransform = '';
      if (angle) {
        const cx = b.x + b.w / 2;
        const cy = b.y + b.h / 2;
        baseTransform = `rotate(${angle}, ${cx}, ${cy})`;
        rect.setAttribute('data-base-transform', baseTransform);
        rect.setAttribute('transform', baseTransform);
      } else {
        rect.removeAttribute('data-base-transform');
      }

      rect.addEventListener('mouseenter', () => {
        if (!drag) {
          const bt = rect.getAttribute('data-base-transform') || '';
          rect.setAttribute('transform', bt ? bt + ' translate(0,-3)' : 'translate(0,-3)');
        }
      });
      rect.addEventListener('mouseleave', () => {
        const bt = rect.getAttribute('data-base-transform');
        if (bt) rect.setAttribute('transform', bt);
        else rect.removeAttribute('transform');
      });

      rect.addEventListener('mousedown', e => {
        e.stopPropagation();
        const bt = rect.getAttribute('data-base-transform');
        if (bt) rect.setAttribute('transform', bt);
        else rect.removeAttribute('transform');
        if (dragEnabled) startDrag(e, b);
      });
      rect.addEventListener('touchstart', e => {
        e.stopPropagation();
        const bt = rect.getAttribute('data-base-transform');
        if (bt) rect.setAttribute('transform', bt);
        else rect.removeAttribute('transform');
        if (dragEnabled) startDrag(e, b);
      }, {passive:false});

      rect.addEventListener('click', e => { e.stopPropagation(); handleBuildingClick(e, b); });

      world.appendChild(rect);

      const align = b.align || 'top';
      const orient = b.orient || 'horizontal';
      const labelGroup = createWrappedText(svg, b.label || '', b.x, b.y, b.w, b.h, 14, 16, align, orient);
      labelGroup.setAttribute('pointer-events','none');

      const textNodes = labelGroup.querySelectorAll('text');
      textNodes.forEach(t => t.setAttribute('fill', (b.type === 'vacant') ? 'rgba(255,255,255,0.95)' : 'rgba(0,0,0,0.9)'));

      if (angle) {
        const cx = b.x + b.w / 2;
        const cy = b.y + b.h / 2;
        labelGroup.setAttribute('transform', `rotate(${angle}, ${cx}, ${cy})`);
      }

      world.appendChild(labelGroup);
    });
  }

  function renderNodeHandlesInto(world){
  // Always remove any existing node handles layer so we can re-append it on top
  const existing = world.querySelector('#nodeHandlesLayer');
  if (existing && existing.parentNode === world) {
    world.removeChild(existing);
  }

  const handlesGroup = document.createElementNS(NS,'g');
  handlesGroup.setAttribute('id', 'nodeHandlesLayer');

  (state.streets || []).forEach(s => {
    if (s.id !== activeStreetId) return;
    (s.nodes || []).forEach((n, idx) => {
      // Visible handle: white, doubled radius from the original
      const c = document.createElementNS(NS,'circle');
      c.setAttribute('cx', n.x);
      c.setAttribute('cy', n.y);
      c.setAttribute('r', 25); // original was 7 -> now doubled
      c.setAttribute('fill', '#ffffff');
      c.classList.add('node-handle');
      c.dataset.sid = s.id;
      c.dataset.idx = String(idx);
      c.style.pointerEvents = 'all';
      c.addEventListener('mousedown', e => { e.stopPropagation(); startNodeDrag(e, s.id, idx); });
      c.addEventListener('touchstart', e => { e.stopPropagation(); startNodeDrag(e, s.id, idx); }, { passive:false });
      handlesGroup.appendChild(c);

      // Larger invisible hit area for easier clicking/tapping
      const hit = document.createElementNS(NS,'circle');
      hit.setAttribute('cx', n.x);
      hit.setAttribute('cy', n.y);
      hit.setAttribute('r', 24);
      hit.setAttribute('fill', 'transparent');
      hit.dataset.sid = s.id;
      hit.dataset.idx = String(idx);
      hit.style.cursor = 'pointer';
      hit.style.pointerEvents = 'all';
      hit.addEventListener('mousedown', e => { e.stopPropagation(); startNodeDrag(e, s.id, idx); });
      hit.addEventListener('touchstart', e => { e.stopPropagation(); startNodeDrag(e, s.id, idx); }, { passive:false });
      handlesGroup.appendChild(hit);
    });
  });

  // Append at the very end so the handles are always on top of streets, including highlights
  world.appendChild(handlesGroup);
}





  
  function hydrateTraceFromState(){
    // When loading a map from data.js, restore any saved tracing image settings
    if (!state || !state.trace) {
      // No trace settings in this state snapshot.
      // Preserve any currently-loaded tracing image so Undo/Redo doesn't unexpectedly clear it.
      const hasImg = !!traceImageUrl;

      if (traceOffsetXInput) traceOffsetXInput.value = hasImg ? String(Math.round(traceImageX)) : '';
      if (traceOffsetYInput) traceOffsetYInput.value = hasImg ? String(Math.round(traceImageY)) : '';

      const s = hasImg ? traceImageScale : 1;
      const a = hasImg ? traceImageAngle : 0;

      if (traceScaleInput) traceScaleInput.value = s;
      if (traceScaleInputBox) traceScaleInputBox.value = s;
      if (traceRotationInput) traceRotationInput.value = a;
      if (traceRotationInputBox) traceRotationInputBox.value = a;

      if (traceToggleBtn) {
        traceToggleBtn.textContent = traceImageVisible ? 'Hide tracing image' : 'Show tracing image';
      }
      return;
    }

    const byName = (state && state.traceByName && typeof state.traceByName === 'object') ? state.traceByName : null;
    const t = (traceImageName && byName && byName[traceImageName]) ? byName[traceImageName] : (state.trace || {});
    // Do NOT restore traceImageUrl from saved state to avoid embedding large data URLs in data.js
    // traceImageUrl is session-only; keep the currently loaded image (if any).
    traceImageVisible = (typeof t.visible === 'boolean') ? t.visible : true;
    traceImageX = (typeof t.x === 'number') ? t.x : 0;
    traceImageY = (typeof t.y === 'number') ? t.y : 0;
    traceImageBaseWidth = (typeof t.baseWidth === 'number') ? t.baseWidth : 0;
    traceImageBaseHeight = (typeof t.baseHeight === 'number') ? t.baseHeight : 0;
    traceImageScale = (typeof t.scale === 'number') ? t.scale : 1;
    traceImageAngle = (typeof t.angle === 'number') ? t.angle : 0;

    if (traceOffsetXInput) traceOffsetXInput.value = Math.round(traceImageX);
    if (traceOffsetYInput) traceOffsetYInput.value = Math.round(traceImageY);
    if (traceScaleInput) traceScaleInput.value = traceImageScale;
    if (traceScaleInputBox) traceScaleInputBox.value = traceImageScale;
    if (traceRotationInput) traceRotationInput.value = traceImageAngle;
    if (traceRotationInputBox) traceRotationInputBox.value = traceImageAngle;
    if (traceToggleBtn) {
      traceToggleBtn.textContent = traceImageVisible ? 'Hide tracing image' : 'Show tracing image';
    }
  }


  function applyStopHighlightClasses(){
    // Update existing SVG elements without forcing a full re-render
    const rects = svg.querySelectorAll('.building');
    rects.forEach(r => r.classList.remove('stop-highlight'));
    if (!stopHighlightIds || !stopHighlightIds.size) return;
    stopHighlightIds.forEach(id => {
      const r = svg.querySelector('.building[data-id="' + id + '"]');
      if (r) r.classList.add('stop-highlight');
    });
  }


  // --- Street highlight helpers (selection + route) ---
  function clearSelectedStreetHighlight(){
    const streetPaths = svg.querySelectorAll('.street.selected-street');
    streetPaths.forEach(p => p.classList.remove('selected-street'));
    const labels = svg.querySelectorAll('text.selected-street');
    labels.forEach(t => t.classList.remove('selected-street'));
  }

  function applySelectedStreetHighlight(id){
    clearSelectedStreetHighlight();
    if (!id) return;
    const path = svg.querySelector('.street[data-id="' + id + '"]');
    if (path) path.classList.add('selected-street');
    const label = svg.querySelector('text[data-street-id="' + id + '"]');
    if (label) label.classList.add('selected-street');
  }

  function clearRouteHighlight(){
    // Safely clear any active line/route highlight (and any stop highlights).
    try { if (typeof analyticsActiveKey !== 'undefined') analyticsActiveKey = null; } catch(_) {}
    try { if (typeof highlightedStreetIdsForStops !== 'undefined') highlightedStreetIdsForStops = []; } catch(_) {}
    try { if (typeof stopHighlightIds !== 'undefined') stopHighlightIds = new Set(); } catch(_) {}

    const streetPaths = svg.querySelectorAll('.street.highlighted');
    streetPaths.forEach(p => p.classList.remove('highlighted'));
    const labelTexts = svg.querySelectorAll('text.highlighted');
    labelTexts.forEach(t => t.classList.remove('highlighted'));
    applyStopHighlightClasses();
  }

function renderAll(){
    // Keep ONLY tracing image transform settings in state so they are saved into data.js
    // We intentionally do NOT store the image data/url so data.js stays small.
    if (!state.trace) {
      state.trace = {};
    }
    state.trace.visible    = traceImageVisible;
    state.trace.x          = traceImageX;
    state.trace.y          = traceImageY;
    state.trace.baseWidth  = traceImageBaseWidth;
    state.trace.baseHeight = traceImageBaseHeight;
    state.trace.scale      = traceImageScale;
    state.trace.angle      = traceImageAngle;

    // Also persist per-image tracing presets keyed by filename (so multiple different tracing images can keep their own transform)
    if (!state.traceByName || typeof state.traceByName !== 'object') state.traceByName = {};
    if (traceImageName) {
      state.traceByName[traceImageName] = {
        visible: traceImageVisible,
        x: traceImageX,
        y: traceImageY,
        baseWidth: traceImageBaseWidth,
        baseHeight: traceImageBaseHeight,
        scale: traceImageScale,
        angle: traceImageAngle
      };
      state.traceActiveName = traceImageName;
    }


    svg.innerHTML = '';
    const world = createWorldGroup();

    // optional tracing background image (in world coordinates)
    if (traceImageUrl && traceImageVisible) {
      const img = document.createElementNS(NS, 'image');

      // Use saved world coordinates & scale so zoom (viewBox changes) doesn't resize the image itself
      const w = traceImageBaseWidth * traceImageScale || 0;
      const h = traceImageBaseHeight * traceImageScale || 0;

      img.setAttribute('x', traceImageX);
      img.setAttribute('y', traceImageY);
      if (w > 0) img.setAttribute('width', w);
      if (h > 0) img.setAttribute('height', h);

      // Apply independent rotation around image center
      if (w > 0 && h > 0) {
        const cx = traceImageX + w / 2;
        const cy = traceImageY + h / 2;
        img.setAttribute('transform', 'rotate(' + traceImageAngle + ' ' + cx + ' ' + cy + ')');
      }

      img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', traceImageUrl);
      img.setAttribute('opacity', traceImageOpacity); // always 100%
      img.setAttribute('pointer-events', traceDragMode ? 'visiblePainted' : 'none');
      img.setAttribute('id', 'traceImageLayer');
      world.appendChild(img);
    }

    renderStreetsInto(world);
    computeStopHighlightIds();
    renderBuildingsInto(world);
    renderNodeHandlesInto(world);
    svg.appendChild(world);
    applyWorldRotation();
  }

  // --- Default tracing image autoload ---
  // If a sibling image named BrooklynMap.jpg exists, load it automatically as the tracing image.
  // If it doesn't exist, keep the existing behavior (user can load a tracing image manually).
  let __defaultTraceAttempted = false;
  function attemptAutoloadDefaultTracingImage(filename){
    if (__defaultTraceAttempted) return;
    __defaultTraceAttempted = true;
    if (!filename) return;

    // Don't override an image the user already loaded in this session
    if (traceImageUrl) return;

    const probe = new Image();
    probe.onload = () => {
      // If the user loaded something while we were probing, don't override it
      if (traceImageUrl) return;

      traceImageUrl = filename;     // keep as a simple relative URL (no data URL needed)
      traceImageName = filename;
      traceImageVisible = true;

      // Apply any saved transform metadata for this filename (preferred),
      // otherwise fall back to the generic trace settings, and finally to the current viewBox.
      const byName = (state && state.traceByName && typeof state.traceByName === 'object') ? state.traceByName : null;
      const t = (traceImageName && byName && byName[traceImageName]) ? byName[traceImageName] : ((state && state.trace) ? state.trace : null);

      if (t && typeof t === 'object') {
        if (typeof t.x === 'number') traceImageX = t.x;
        if (typeof t.y === 'number') traceImageY = t.y;
        if (typeof t.baseWidth === 'number') traceImageBaseWidth = t.baseWidth;
        if (typeof t.baseHeight === 'number') traceImageBaseHeight = t.baseHeight;
        if (typeof t.scale === 'number') traceImageScale = t.scale;
        if (typeof t.angle === 'number') traceImageAngle = t.angle;
        if (typeof t.visible === 'boolean') traceImageVisible = t.visible;
      }

      // Ensure the image has a usable base size so it actually renders.
      // (On a brand-new map, state.trace may exist but be empty/zeroed.)
      if (!(traceImageBaseWidth > 0 && traceImageBaseHeight > 0)) {
        const vb = svg.viewBox.baseVal;
        traceImageX = vb.x;
        traceImageY = vb.y;
        traceImageBaseWidth = vb.width;
        traceImageBaseHeight = vb.height;
        if (!(traceImageScale > 0)) traceImageScale = 1;
        if (!Number.isFinite(traceImageAngle)) traceImageAngle = 0;
      }

      if (traceToggleBtn) traceToggleBtn.textContent = traceImageVisible ? 'Hide tracing image' : 'Show tracing image';
      if (traceOffsetXInput) traceOffsetXInput.value = Math.round(traceImageX);
      if (traceOffsetYInput) traceOffsetYInput.value = Math.round(traceImageY);
      if (traceScaleInput) traceScaleInput.value = traceImageScale;
      if (traceScaleInputBox) traceScaleInputBox.value = traceImageScale;
      if (traceRotationInput) traceRotationInput.value = traceImageAngle;
      if (traceRotationInputBox) traceRotationInputBox.value = traceImageAngle;

      renderAll();
    };
    probe.onerror = () => {
      // BrooklynMap.jpg isn't present — do nothing and keep existing behavior.
    };
    probe.src = filename;
  }


  function init(){
    state = normalizeState(state);
    blockNameEl.textContent = state.blockName || 'Neighborhood';
    svg.setAttribute('viewBox', state.viewBox.join(' '));
    svg.tabIndex = 0;

    // Initialize layer toggle buttons
    const layerButtons = document.querySelectorAll('.layer-toggle');
    layerButtons.forEach(btn => {
      const layer = btn.dataset.layer;
      if (!layer) return;
      if (layerVisibility[layer]) {
        btn.classList.add('drag-on');
      } else {
        btn.classList.remove('drag-on');
      }
      btn.addEventListener('click', () => {
        layerVisibility[layer] = !layerVisibility[layer];
        if (layerVisibility[layer]) {
          btn.classList.add('drag-on');
        } else {
          btn.classList.remove('drag-on');
        }
        renderAll();
      });
    });

    // If the loaded map has a saved tracing image, restore it
    hydrateTraceFromState();

    renderAll();
    updateToggleDragButton();
    attemptAutoloadDefaultTracingImage('BrooklynMap.jpg');
  }

  function startDrag(evt, b){
    evt.preventDefault();
    clearAllRectTransforms();
    const p = getWorldPoint(evt);

    const _preHistoryJson = getUndoSnapshotJson();

    if (selectedType === 'multi' && selectedIds && selectedIds.size > 1 && selectedIds.has(b.id)) {
      const ids = Array.from(selectedIds);
      const origPositions = {};
      (state.buildings || []).forEach(bb => {
        if (ids.indexOf(bb.id) !== -1) {
          origPositions[bb.id] = { x: bb.x, y: bb.y };
        }
      });
      drag = { mode: 'multi', ids, sx: p.x, sy: p.y, origPositions };
    } else {
      drag = { mode: 'single', id: b.id, sx: p.x, sy: p.y, origX: b.x, origY: b.y };
    }

    if (drag) {
      drag._historyPre = _preHistoryJson;
      drag._historyPushed = false;
      drag._historyLabel = (drag.mode === 'multi') ? 'Move buildings' : 'Move building';
    }

    window.addEventListener('mousemove', onDrag);
    window.addEventListener('touchmove', onDrag, {passive:false});
    window.addEventListener('mouseup', endDrag);
    window.addEventListener('touchend', endDrag);
  }
  function onDrag(evt){
    if (!drag) return;
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const dx = p.x - drag.sx;
    const dy = p.y - drag.sy;


    if (!drag._historyPushed && (dx !== 0 || dy !== 0)) {
      pushHistoryFromJson(drag._historyPre, drag._historyLabel);
      drag._historyPushed = true;
    }

    if (drag.mode === 'multi') {
      (drag.ids || []).forEach(id => {
        const b = (state.buildings || []).find(x => x.id === id);
        const orig = drag.origPositions && drag.origPositions[id];
        if (b && orig) {
          b.x = Math.round(orig.x + dx);
          b.y = Math.round(orig.y + dy);
        }
      });
      renderAll();
    } else {
      const b = (state.buildings || []).find(x => x.id === drag.id);
      if (!b) return;
      b.x = Math.round(drag.origX + dx);
      b.y = Math.round(drag.origY + dy);
      if (selectedId === b.id && selectedType === 'building'){
        const bxEl = document.getElementById('bX');
        const byEl = document.getElementById('bY');
        if (bxEl) bxEl.value = b.x;
        if (byEl) byEl.value = b.y;
      }
      renderAll();
    }
  }
  function endDrag(){
    if (!drag) return;
    drag = null;
    clearAllRectTransforms();
    window.removeEventListener('mousemove', onDrag);
    window.removeEventListener('touchmove', onDrag);
    window.removeEventListener('mouseup', endDrag);
    window.removeEventListener('touchend', endDrag);
  }

function clearAllRectTransforms(){
    const rects = svg.querySelectorAll('rect.building');
    rects.forEach(r => {
      const bt = r.getAttribute('data-base-transform');
      if (bt) r.setAttribute('transform', bt);
      else r.removeAttribute('transform');
    });
  }

  function startNodeDrag(evt, streetId, idx){
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const _preHistoryJson = getUndoSnapshotJson();
    const s = (state.streets || []).find(x => x.id === streetId);
    if(!s || !s.nodes || s.nodes.length <= idx) return;
    const n = s.nodes[idx];
    nodeDrag = { streetId, nodeIdx: idx, sx: p.x, sy: p.y, origX: n.x, origY: n.y, _historyPre: _preHistoryJson, _historyPushed: false };
    window.addEventListener('mousemove', onNodeDrag);
    window.addEventListener('touchmove', onNodeDrag, {passive:false});
    window.addEventListener('mouseup', endNodeDrag);
    window.addEventListener('touchend', endNodeDrag);
  }
  function onNodeDrag(evt){
    if(!nodeDrag) return;
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const dx = p.x - nodeDrag.sx;
    const dy = p.y - nodeDrag.sy;

    if (!nodeDrag._historyPushed && (dx !== 0 || dy !== 0)) {
      pushHistoryFromJson(nodeDrag._historyPre, 'Move street node');
      nodeDrag._historyPushed = true;
    }
    const s = (state.streets || []).find(x => x.id === nodeDrag.streetId);
    if(!s) return;
    const idx = nodeDrag.nodeIdx;
    s.nodes[idx].x = Math.round(nodeDrag.origX + dx);
    s.nodes[idx].y = Math.round(nodeDrag.origY + dy);

    // Keep street inspector geometry/angle in sync while dragging nodes
    if (selectedType === 'street' && selectedId === s.id) {
      const nodes = s.nodes || [];
      let gx = 0, gy = 0;
      let len = computeStreetEndToEndLength(s) || 0;
      let widthVal = s.width || 60;
      if (nodes.length >= 1) {
        gx = nodes[0].x;
        gy = nodes[0].y;
      }
      let angleDeg = 0;
      if (nodes.length >= 2) {
        const first = nodes[0];
        const last = nodes[nodes.length - 1];
        const dx2 = last.x - first.x;
        const dy2 = last.y - first.y;
        const ang = Math.atan2(dy2, dx2) * 180 / Math.PI;
        if (Number.isFinite(ang)) angleDeg = ang;
      }
      const gxEl = document.getElementById('streetGX');
      const gyEl = document.getElementById('streetGY');
      const lenEl = document.getElementById('streetGW');
      const widthEl = document.getElementById('streetGH');
      const angleEl = document.getElementById('streetAngle');
      if (gxEl) gxEl.value = Math.round(gx);
      if (gyEl) gyEl.value = Math.round(gy);
      if (lenEl) lenEl.value = Math.round(len);
      if (widthEl) widthEl.value = Math.round(widthVal);
      if (angleEl) angleEl.value = angleDeg.toFixed(1);
    }

    renderAll();
  }
  function endNodeDrag(){
    if(!nodeDrag) return;
    nodeDrag = null;
    window.removeEventListener('mousemove', onNodeDrag);
    window.removeEventListener('touchmove', onNodeDrag);
    window.removeEventListener('mouseup', endNodeDrag);
    window.removeEventListener('touchend', endNodeDrag);
  }

  function startStreetTranslate(evt, streetId) {
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const _preHistoryJson = getUndoSnapshotJson();
    const s = (state.streets || []).find(x => x.id === streetId);
    if (!s) return;
    streetTranslateDrag = {
      streetId,
      sx: p.x,
      sy: p.y,
      origNodes: s.nodes.map(n => ({ x: n.x, y: n.y })),
      _historyPre: _preHistoryJson,
      _historyPushed: false
    };
    window.addEventListener('mousemove', onStreetTranslate);
    window.addEventListener('touchmove', onStreetTranslate, {passive:false});
    window.addEventListener('mouseup', endStreetTranslate);
    window.addEventListener('touchend', endStreetTranslate);
  }
  function onStreetTranslate(evt) {
    if (!streetTranslateDrag) return;
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const dx = p.x - streetTranslateDrag.sx;
    const dy = p.y - streetTranslateDrag.sy;

    if (!streetTranslateDrag._historyPushed && (dx !== 0 || dy !== 0)) {
      pushHistoryFromJson(streetTranslateDrag._historyPre, 'Move street');
      streetTranslateDrag._historyPushed = true;
    }
    const s = (state.streets || []).find(x => x.id === streetTranslateDrag.streetId);
    if (!s) return;
    s.nodes.forEach((n, i) => {
      n.x = Math.round(streetTranslateDrag.origNodes[i].x + dx);
      n.y = Math.round(streetTranslateDrag.origNodes[i].y + dy);
    });

    // Keep street inspector geometry/angle in sync while translating street
    if (selectedType === 'street' && selectedId === s.id) {
      const nodes = s.nodes || [];
      let gx = 0, gy = 0;
      let len = computeStreetEndToEndLength(s) || 0;
      let widthVal = s.width || 60;
      if (nodes.length >= 1) {
        gx = nodes[0].x;
        gy = nodes[0].y;
      }
      let angleDeg = 0;
      if (nodes.length >= 2) {
        const first = nodes[0];
        const last = nodes[nodes.length - 1];
        const dx2 = last.x - first.x;
        const dy2 = last.y - first.y;
        const ang = Math.atan2(dy2, dx2) * 180 / Math.PI;
        if (Number.isFinite(ang)) angleDeg = ang;
      }
      const gxEl = document.getElementById('streetGX');
      const gyEl = document.getElementById('streetGY');
      const lenEl = document.getElementById('streetGW');
      const widthEl = document.getElementById('streetGH');
      const angleEl = document.getElementById('streetAngle');
      if (gxEl) gxEl.value = Math.round(gx);
      if (gyEl) gyEl.value = Math.round(gy);
      if (lenEl) lenEl.value = Math.round(len);
      if (widthEl) widthEl.value = Math.round(widthVal);
      if (angleEl) angleEl.value = angleDeg.toFixed(1);
    }

    renderAll();
  }
  function endStreetTranslate() {
    if (!streetTranslateDrag) return;
    streetTranslateDrag = null;
    window.removeEventListener('mousemove', onStreetTranslate);
    window.removeEventListener('touchmove', onStreetTranslate);
    window.removeEventListener('mouseup', endStreetTranslate);
    window.removeEventListener('touchend', endStreetTranslate);
  }

  
    
    
function refreshInspectorTitle(label){
      const el = document.getElementById('inspectorTitle');
      if (el) el.textContent = (label && String(label).trim()) ? label : 'Building';
    }
    
function showMultiInspector(){
    noSelection.style.display = 'none';
    form.style.display = 'block';
    removeStreetInspector();
    const setup = document.getElementById('setup');
    const fill = document.getElementById('fill');
    if (setup) setup.style.display = 'none';
    if (fill) fill.style.display = 'none';
    const tEl = document.getElementById('inspectorTitle');
    if (tEl) {
      const count = selectedIds.size || 0;
      tEl.textContent = count > 1 ? (count + ' items selected') : 'Item';
    }
  
    refreshQuickEditBar();
  }

  function selectBuilding(id){
    selectedId = id; selectedType = 'building'; activeStreetId = null;
    clearSelectedStreetHighlight();
    selectedIds.clear();
    selectedIds.add(id);
    const b = (state.buildings || []).find(x => x.id === id);
    if(!b) return;
    noSelection.style.display = 'none'; form.style.display = 'block';
    removeStreetInspector();
    const setup = document.getElementById('setup');
    const fill = document.getElementById('fill');
    if (setup) setup.style.display = '';
    if (fill) fill.style.display = '';
    document.getElementById('bLabel').value = b.label || '';
    document.getElementById('bType').value = b.type || 'other';
    document.getElementById('bColor').value = toHexColor(b.color || getFillForType(b.type));
    document.getElementById('bAlign').value = b.align || 'top';
    document.getElementById('bOrient').value = b.orient || 'horizontal';
    document.getElementById('bOcc').value = b.occupants || '';
    document.getElementById('bNotes').value = b.notes || '';
    document.getElementById('bUsage').value = b.usage || 'none';
    document.getElementById('bFunding').value = b.funding || 'none';
    document.getElementById('bX').value = b.x;
    document.getElementById('bY').value = b.y;
    document.getElementById('bW').value = b.w;
    document.getElementById('bH').value = b.h;
    const bAngleEl = document.getElementById('bAngle');
    if (bAngleEl) bAngleEl.value = (typeof b.angle === 'number') ? b.angle : (b.angle || 0);

    const tEl = document.getElementById('inspectorTitle');
    if (tEl) tEl.textContent = (b.label && String(b.label).trim()) ? b.label : 'Building';
    const lblEl = document.getElementById('bLabel');
    if (lblEl) {
      lblEl.oninput = null;
      lblEl.addEventListener('input', function(){
        if (tEl) tEl.textContent = (this.value && String(this.value).trim()) ? this.value : 'Building';
      });
    }
    renderAll();
    refreshQuickEditBar();
  }

  function handleBuildingClick(evt, b){
    const multiKey = evt.shiftKey || evt.metaKey || evt.ctrlKey;
    if (multiKey){
      if (selectedIds.has(b.id)){
        selectedIds.delete(b.id);
      } else {
        selectedIds.add(b.id);
      }

      if (selectedIds.size === 0){
        selectedId = null;
        selectedType = null;
        activeStreetId = null;
        form.style.display = 'none';
        noSelection.style.display = 'block';
        removeStreetInspector();
      } else if (selectedIds.size === 1){
        const onlyId = Array.from(selectedIds)[0];
        selectBuilding(onlyId);
        return;
      } else {
        selectedId = null;
        selectedType = 'multi';
        activeStreetId = null;
        showMultiInspector();
      }
      renderAll();
      refreshQuickEditBar();
    } else {
      selectedIds.clear();
      selectBuilding(b.id);
    }
  }

  function selectStreet(id){
    selectedIds.clear();
    selectedId = id; selectedType = 'street'; activeStreetId = id;
    noSelection.style.display = 'none'; form.style.display = 'none';
    injectStreetInspector((state.streets || []).find(s => s.id === id));

    renderAll();
    applySelectedStreetHighlight(id);
    refreshQuickEditBar();
  }

  function removeStreetInspector(){
    const old = document.getElementById('streetInspector'); if(old) old.remove();
  }

  function injectStreetInspector(s){
    removeStreetInspector();
    if(!s) return;
    const inspector = document.getElementById('inspector');
    const prevInfo = inspector ? inspector.querySelector('#streetInfo') : null;
    const prevSetup = inspector ? inspector.querySelector('#streetSetup') : null;
    if (prevInfo) lastStreetInfoOpen = !!prevInfo.open;
    if (prevSetup) lastStreetSetupOpen = !!prevSetup.open;

    const stub = document.createElement('div'); stub.id = 'streetInspector'; stub.style.marginTop='12px';
    const currentLen = computeStreetEndToEndLength(s);
    let gx = 0, gy = 0;
    let gw = currentLen || 0;
    let gh = s.width || 60;
    if (Array.isArray(s.nodes) && s.nodes.length >= 1) {
      gx = s.nodes[0].x;
      gy = s.nodes[0].y;
    }
    let streetAngleDeg = 0;
    if (Array.isArray(s.nodes) && s.nodes.length >= 2) {
      const first = s.nodes[0];
      const last = s.nodes[s.nodes.length - 1];
      const dx = last.x - first.x;
      const dy = last.y - first.y;
      const ang = Math.atan2(dy, dx) * 180 / Math.PI;
      if (Number.isFinite(ang)) streetAngleDeg = ang;
    }
    stub.innerHTML = `
      <h3 id="streetInspectorTitle" style="margin:6px 0">${escapeHtml(s.name||'Street')}</h3>

      <!-- STREETS: Top actions row -->
      <div class="street-actions" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0">
        <button id="toggleTranslateBtn" class="tool-btn muted-btn ${streetTranslateMode ? 'drag-on' : ''}">${streetTranslateMode ? 'Drag: On' : 'Drag: Off'}</button>
        <button class="tool-btn" id="saveStreetBtn">Save</button>
        <button class="tool-btn muted-btn" id="copyStreetBtn">Copy</button>
        <button class="tool-btn muted-btn" id="pasteStreetBtn">Paste</button>
        <button class="tool-btn" id="deleteStreetBtn" style="background:var(--danger);color:white">Delete</button>
      </div>

      

      <details id="streetSetup">
        <summary>Street Set Up</summary>
        <label class="small">Color</label>
        <input id="streetColor" type="color" value="${toHexColor(s.color || 'rgba(60,66,72,0.95)')}" />
        <label class="small">Geometry (x, y, Length, Width)</label>
        <div style="display:flex;gap:6px">
          <input id="streetGX" type="text" value="${Math.round(gx)}" />
          <input id="streetGY" type="text" value="${Math.round(gy)}" />
          <input id="streetGW" type="text" value="${Math.round(gw)}" />
          <input id="streetGH" type="text" value="${Math.round(gh)}" />
        </div>
        <label class="small">Angle (°)</label>
        <input id="streetAngle" type="text" value="${streetAngleDeg.toFixed(1)}" />
        <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
          <button id="addNodeStartBtn" class="muted-btn">Add Node Start</button>
          <button id="addNodeEndBtn" class="muted-btn">Add Node End</button>
          <button id="delNodeBtn" class="muted-btn" style="background:var(--danger);color:white" ${ (s.nodes && s.nodes.length > 2) ? "" : "disabled" }>Delete node</button>
        </div>
      
      <!-- Layer order controls -->
      <div class="street-layer" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0">
        <span class="small" style="margin-right:6px">Layer:</span>
        <button id="layerUpBtn" class="muted-btn" title="Move one step toward front">Up</button>
        <button id="layerDownBtn" class="muted-btn" title="Move one step toward back">Down</button>
        <button id="layerFrontBtn" class="muted-btn" title="Bring to front">Front</button>
        <button id="layerBackBtn" class="muted-btn" title="Send to back">Back</button>
      </div>
      </details>
      <details id="streetInfo">
        <summary>Street Info</summary>
        <label class="small">Name</label>
        <input id="streetName" type="text" value="${escapeHtml(s.name||'')}" />
        <label class="small">Notes</label>
        <textarea id="streetNotes" rows="3">${escapeHtml((s.notes||''))}</textarea>
      </details>
    `;
    const traceSection = inspector ? inspector.querySelector('#traceTools') : null;
    if (traceSection && traceSection.parentNode === inspector){
      inspector.insertBefore(stub, traceSection);
    } else {
      inspector.appendChild(stub);
    }
    const streetTitleEl = document.getElementById('streetInspectorTitle');
    const streetNameEl = document.getElementById('streetName');
    if (streetTitleEl && streetNameEl) {
      streetTitleEl.textContent = (streetNameEl.value && streetNameEl.value.trim()) ? streetNameEl.value : 'Street';
      streetNameEl.addEventListener('input', function(){
        streetTitleEl.textContent = (this.value && String(this.value).trim()) ? this.value : 'Street';
      });
    }

    const _info = stub.querySelector('#streetInfo');
    const _setup = stub.querySelector('#streetSetup');
    if (_info) { _info.open = !!lastStreetInfoOpen; _info.addEventListener('toggle', ()=>{ lastStreetInfoOpen = _info.open; }); }
    if (_setup) { _setup.open = !!lastStreetSetupOpen; _setup.addEventListener('toggle', ()=>{ lastStreetSetupOpen = _setup.open; }); }

    const tb = document.getElementById('toggleTranslateBtn');
    if (typeof updateStreetDragButton === 'function') updateStreetDragButton();
    if (tb) {
      tb.addEventListener('click', (evt) => { 
        evt.preventDefault(); evt.stopPropagation(); 
        streetTranslateMode = !streetTranslateMode; dragEnabled = streetTranslateMode; tb.textContent = streetTranslateMode ? 'Drag: On' : 'Drag: Off'; if (streetTranslateMode) tb.classList.add('drag-on'); else tb.classList.remove('drag-on'); updateToggleDragButton(); activeStreetId = s.id;
        renderAll();
      });
    }

    document.getElementById('saveStreetBtn').addEventListener('click', (evt)=>{ evt.preventDefault(); evt.stopPropagation();
      pushHistory('Edit street'); 
      s.name = document.getElementById('streetName').value;
      { const st = document.getElementById('streetInspectorTitle'); if (st) st.textContent = (s.name && String(s.name).trim()) ? s.name : 'Street'; }
      const _notesEl = document.getElementById('streetNotes'); if(_notesEl){ s.notes = _notesEl.value; }
      s.color = document.getElementById('streetColor').value;
      const gxVal = Number(document.getElementById('streetGX').value);
      const gyVal = Number(document.getElementById('streetGY').value);
      const lenVal = Number(document.getElementById('streetGW').value);
      const geomWidthVal = Number(document.getElementById('streetGH').value);

      // Apply X,Y,Length edits assuming a mostly two-node street (segment)
      if (Array.isArray(s.nodes) && s.nodes.length >= 2) {
        const nodes = s.nodes;
        const first = nodes[0];

        // Move street so first node is at (gx, gy)
        if (!Number.isNaN(gxVal) && !Number.isNaN(gyVal)) {
          const dx = gxVal - first.x;
          const dy = gyVal - first.y;
          for (let i = 0; i < nodes.length; i++) {
            nodes[i].x = Math.round(nodes[i].x + dx);
            nodes[i].y = Math.round(nodes[i].y + dy);
          }
        }

        // Adjust length along current direction (anchor at first node)
        if (lenVal > 0 && !Number.isNaN(lenVal)) {
          const a = nodes[0];
          const b = nodes[nodes.length - 1];
          const curDx = b.x - a.x;
          const curDy = b.y - a.y;
          const curLen = Math.sqrt(curDx * curDx + curDy * curDy);
          if (curLen > 0) {
            const scale = lenVal / curLen;
            const newBx = a.x + curDx * scale;
            const newBy = a.y + curDy * scale;
            b.x = Math.round(newBx);
            b.y = Math.round(newBy);
          }
        }
      } else if (Array.isArray(s.nodes) && s.nodes.length === 1) {
        if (!Number.isNaN(gxVal) && !Number.isNaN(gyVal)) {
          s.nodes[0].x = Math.round(gxVal);
          s.nodes[0].y = Math.round(gyVal);
        }
      }

      // Determine street width purely from the Geometry Width field
      let newWidth = s.width;
      if (!Number.isNaN(geomWidthVal) && geomWidthVal > 0) {
        newWidth = geomWidthVal;
      }
      s.width = newWidth;

      // Keep the Geometry Width input in sync with the street width
      const widthGeomEl = document.getElementById('streetGH');
      if (widthGeomEl) widthGeomEl.value = String(Math.round(newWidth));

      const angleEl = document.getElementById('streetAngle');
      if (angleEl && Array.isArray(s.nodes) && s.nodes.length >= 2) {
        const targetDeg = Number(angleEl.value);
        if (!Number.isNaN(targetDeg)) {
          const first = s.nodes[0];
          const cx = first.x;
          const cy = first.y;
          const last = s.nodes[s.nodes.length - 1];
          const dx = last.x - cx;
          const dy = last.y - cy;
          const currentRad = Math.atan2(dy, dx);
          const targetRad = targetDeg * Math.PI / 180;
          const delta = targetRad - currentRad;
          const cosD = Math.cos(delta);
          const sinD = Math.sin(delta);
          for (let i = 1; i < s.nodes.length; i++) {
            const node = s.nodes[i];
            const rx = (node.x - cx) * cosD - (node.y - cy) * sinD;
            const ry = (node.x - cx) * sinD + (node.y - cy) * cosD;
            node.x = Math.round(cx + rx);
            node.y = Math.round(cy + ry);
          }
        }
      }
      renderAll();
    });

    document.getElementById('deleteStreetBtn').addEventListener('click', (evt)=>{ evt.preventDefault(); evt.stopPropagation(); 
      if(!confirm('Delete this street?')) return;
      pushHistory('Delete street');
      state.streets = (state.streets || []).filter(x => x.id !== s.id);
      removeStreetInspector(); activeStreetId = null; renderAll();
    });

    const addNodeStartBtn = document.getElementById('addNodeStartBtn');
    if (addNodeStartBtn) addNodeStartBtn.addEventListener('click', (evt)=>{ evt.preventDefault(); evt.stopPropagation();
      pushHistory('Add street node (start)');
      streetNodeLastSide[s.id] = 'start';
      s.nodes = s.nodes || [];
      if (s.nodes.length === 0) {
        s.nodes.push({ x: 200, y: 200 }, { x: 240, y: 220 });
      } else if (s.nodes.length === 1) {
        const a = s.nodes[0] || { x: 200, y: 200 };
        s.nodes.unshift({ x: a.x - 40, y: a.y - 20 });
      } else {
        const a = s.nodes[0];
        const b = s.nodes[1];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const len = Math.hypot(dx, dy) || 1;
        const step = 40;
        const ux = dx / len;
        const uy = dy / len;
        s.nodes.unshift({ x: Math.round(a.x + ux * step), y: Math.round(a.y + uy * step) });
      }
      renderAll();
      injectStreetInspector(s);
    });

    const addNodeEndBtn = document.getElementById('addNodeEndBtn');
    if (addNodeEndBtn) addNodeEndBtn.addEventListener('click', (evt)=>{ evt.preventDefault(); evt.stopPropagation();
      pushHistory('Add street node (end)');
      streetNodeLastSide[s.id] = 'end';
      s.nodes = s.nodes || [];
      if (s.nodes.length === 0) {
        s.nodes.push({ x: 200, y: 200 }, { x: 240, y: 220 });
      } else if (s.nodes.length === 1) {
        const a = s.nodes[0] || { x: 200, y: 200 };
        s.nodes.push({ x: a.x + 40, y: a.y + 20 });
      } else {
        const a = s.nodes[s.nodes.length - 1];
        const b = s.nodes[s.nodes.length - 2];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const len = Math.hypot(dx, dy) || 1;
        const step = 40;
        const ux = dx / len;
        const uy = dy / len;
        s.nodes.push({ x: Math.round(a.x + ux * step), y: Math.round(a.y + uy * step) });
      }
      renderAll();
      injectStreetInspector(s);
    });

    const copyStreetBtn = document.getElementById('copyStreetBtn');
    if (copyStreetBtn) {
      copyStreetBtn.addEventListener('click', (evt)=>{ 
        evt.preventDefault(); 
        evt.stopPropagation(); 
        clipboard = { kind: 'street', data: JSON.parse(JSON.stringify(s)) };
        alert('Street copied.');
      });
    }

    const pasteStreetBtn = document.getElementById('pasteStreetBtn');
    if (pasteStreetBtn) {
      pasteStreetBtn.addEventListener('click', (evt)=>{ 
        evt.preventDefault(); 
        evt.stopPropagation(); 
        if (!clipboard || clipboard.kind !== 'street' || !clipboard.data) {
          alert('No street in the clipboard.');
          return;
        }
        const orig = clipboard.data;
        const id = 's' + Date.now() + Math.floor(Math.random() * 1000);
        const offset = 25;
        const newStreet = Object.assign({}, orig, {
          id,
          nodes: (orig.nodes || []).map(n => ({
            x: (n.x || 0) + offset,
            y: (n.y || 0) + offset
          }))
        });
        state.streets = state.streets || [];
        state.streets.push(newStreet);
        renderAll();
        selectStreet(id);
      });
    }

    const delBtn = document.getElementById('delNodeBtn');
    if (delBtn) delBtn.addEventListener('click', (evt)=>{ evt.preventDefault(); evt.stopPropagation();
      if (!Array.isArray(s.nodes) || s.nodes.length <= 2) return;
      pushHistory('Remove street node');
      const side = streetNodeLastSide[s.id] || 'end';
      if (side === 'start') s.nodes.shift();
      else s.nodes.pop();
      renderAll();
      injectStreetInspector(s);
    });

    // Layer order wiring
    document.getElementById('layerUpBtn').addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); moveStreet('up', s.id); });
    document.getElementById('layerDownBtn').addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); moveStreet('down', s.id); });
    document.getElementById('layerFrontBtn').addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); moveStreet('front', s.id); });
    document.getElementById('layerBackBtn').addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); moveStreet('back', s.id); });
  }

  // --- layer order helper ---
  function moveStreet(dir, id){
    const arr = state.streets || [];
    const i = arr.findIndex(s => s.id === id);
    if (i < 0) return;

    const swap = (a, b) => { const t = arr[a]; arr[a] = arr[b]; arr[b] = t; };

    if (dir === 'up' && i < arr.length - 1) swap(i, i + 1);
    else if (dir === 'down' && i > 0) swap(i, i - 1);
    else if (dir === 'front' && i < arr.length - 1) { const [s] = arr.splice(i,1); arr.push(s); }
    else if (dir === 'back' && i > 0) { const [s] = arr.splice(i,1); arr.unshift(s); }

    renderAll();
    injectStreetInspector(arr.find(s => s.id === id));
    activeStreetId = id;
  }

  function computeStreetLength(st) {
    if (!st || !Array.isArray(st.nodes) || st.nodes.length === 0) return 0;
    let len = 0;
    for (let i = 1; i < st.nodes.length; i++) {
      const a = st.nodes[i-1];
      const b = st.nodes[i];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      len += Math.hypot(dx, dy);
    }
    return len;
  }

  // Straight-line (end-to-end) length from first to last node.
  // Used for the Street Set Up "Length" control so saving name/notes doesn't distort polylines.
  function computeStreetEndToEndLength(st) {
    if (!st || !Array.isArray(st.nodes) || st.nodes.length < 2) return 0;
    const a = st.nodes[0];
    const b = st.nodes[st.nodes.length - 1];
    return Math.hypot(b.x - a.x, b.y - a.y);
  }


  function computeStreetBBox(st) {
    if (!st || !Array.isArray(st.nodes) || !st.nodes.length) return null;
    let minX = st.nodes[0].x, maxX = st.nodes[0].x, minY = st.nodes[0].y, maxY = st.nodes[0].y;
    for (let i = 1; i < st.nodes.length; i++) {
      const n = st.nodes[i];
      if (n.x < minX) minX = n.x;
      if (n.x > maxX) maxX = n.x;
      if (n.y < minY) minY = n.y;
      if (n.y > maxY) maxY = n.y;
    }
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }



  document.getElementById('saveBtn').addEventListener('click', ()=>{
    if(selectedType !== 'building' || !selectedId) return;
    const b = (state.buildings || []).find(x=>x.id===selectedId);
    if(!b) return;
    pushHistory('Edit building');
    b.label = document.getElementById('bLabel').value;
    b.type  = document.getElementById('bType').value;
    b.color = document.getElementById('bColor').value;
    b.align = document.getElementById('bAlign').value || 'top';
    b.orient = document.getElementById('bOrient').value || 'horizontal';
    b.occupants = document.getElementById('bOcc').value;
    b.notes = document.getElementById('bNotes').value;
    b.usage = document.getElementById('bUsage').value;
    b.funding = document.getElementById('bFunding').value;
 b.x = Number(document.getElementById('bX').value) || b.x;
 b.y = Number(document.getElementById('bY').value) || b.y;
    const bAngleEl = document.getElementById('bAngle');
    if (bAngleEl) {
      const aVal = Number(bAngleEl.value);
      if (!Number.isNaN(aVal)) b.angle = aVal;
    }
    refreshInspectorTitle(b.label);
    b.w = Number(document.getElementById('bW').value) || b.w;
        b.h = Number(document.getElementById('bH').value) || b.h;
    renderAll();
});

  document.getElementById('deleteBtn').addEventListener('click', ()=>{
    if (selectedType === 'building' && selectedId) {
      if (!confirm('Delete this building?')) return;
      pushHistory('Delete building');
      state.buildings = (state.buildings || []).filter(x => x.id !== selectedId);
      selectedId = null;
      selectedType = null;
      selectedIds.clear();
      form.style.display = 'none';
      noSelection.style.display = 'block';
      activeStreetId = null;
      try { clearSelectedStreetHighlight(); } catch(_) {}
      try { clearRouteHighlight(); } catch(_) {}
      renderAll();
    } else if (selectedType === 'multi' && selectedIds && selectedIds.size > 0) {
      if (!confirm('Delete ' + selectedIds.size + ' buildings?')) return;
      pushHistory('Delete buildings');
      const idsToDelete = new Set(selectedIds);
      state.buildings = (state.buildings || []).filter(x => !idsToDelete.has(x.id));
      selectedId = null;
      selectedType = null;
      selectedIds.clear();
      form.style.display = 'none';
      noSelection.style.display = 'block';
      activeStreetId = null;
      try { clearSelectedStreetHighlight(); } catch(_) {}
      try { clearRouteHighlight(); } catch(_) {}
      renderAll();
    }
  });



  document.getElementById('copyBuildingBtn').addEventListener('click', ()=>{
    if (selectedType === 'building' && selectedId) {
      const b = (state.buildings || []).find(x => x.id === selectedId);
      if (!b) return;
      clipboard = { kind: 'building', data: JSON.parse(JSON.stringify(b)) };
      alert('Building copied.');
    } else if (selectedType === 'multi' && selectedIds && selectedIds.size > 0) {
      const buildings = (state.buildings || []).filter(bb => selectedIds.has(bb.id));
      if (!buildings.length) {
        alert('No buildings selected to copy.');
        return;
      }
      clipboard = { kind: 'building-multi', data: JSON.parse(JSON.stringify(buildings)) };
      alert(buildings.length + ' buildings copied.');
    } else {
      alert('Select a building first to copy.');
    }
  });

  document.getElementById('pasteBuildingBtn').addEventListener('click', ()=>{
    pushHistory('Paste building');
    if (!clipboard || !clipboard.data) {
      alert('No building in the clipboard.');
      return;
    }
    const offset = 25;
    state.buildings = state.buildings || [];
    const newIds = [];

    if (clipboard.kind === 'building') {
      const orig = clipboard.data;
      const id = 'b' + Date.now() + Math.floor(Math.random() * 1000);
      const b = Object.assign({}, orig, {
        id,
        x: (orig.x || 0) + offset,
        y: (orig.y || 0) + offset
      });
      state.buildings.push(b);
      newIds.push(id);
    } else if (clipboard.kind === 'building-multi') {
      const origArr = clipboard.data || [];
      let i = 0;
      origArr.forEach(orig => {
        const id = 'b' + Date.now() + Math.floor(Math.random() * 1000) + '_' + (i++);
        const b = Object.assign({}, orig, {
          id,
          x: (orig.x || 0) + offset,
          y: (orig.y || 0) + offset
        });
        state.buildings.push(b);
        newIds.push(id);
      });
    } else {
      alert('Clipboard does not contain buildings.');
      return;
    }

    renderAll();

    if (newIds.length === 1) {
      selectBuilding(newIds[0]);
    } else if (newIds.length > 1) {
      selectedIds.clear();
      newIds.forEach(id => selectedIds.add(id));
      selectedId = null;
      selectedType = 'multi';
      activeStreetId = null;
      showMultiInspector();
      renderAll();
    }
  });


toggleDragBtn.addEventListener('click', ()=>{
    dragEnabled = !dragEnabled;
    streetTranslateMode = dragEnabled;
    updateToggleDragButton();
    if (typeof updateStreetDragButton === 'function') updateStreetDragButton();
    renderAll();
  });
  function updateToggleDragButton(){
    if (dragEnabled){
      toggleDragBtn.textContent = 'Drag: On';
      toggleDragBtn.classList.add('drag-on');
    } else {
      toggleDragBtn.textContent = 'Drag: Off';
      toggleDragBtn.classList.remove('drag-on');
    }
  }

  // Keep the street inspector 'Drag' button UI in sync
  function updateStreetDragButton(){
    const tb = document.getElementById('toggleTranslateBtn');
    if (!tb) return;
    tb.textContent = streetTranslateMode ? 'Drag: On' : 'Drag: Off';
    if (streetTranslateMode) tb.classList.add('drag-on'); else tb.classList.remove('drag-on');
  }

  
document.getElementById('addBuildingBtn').addEventListener('click', ()=>{
  pushHistory('Add building');
  const id = 'b' + Date.now();
  const defaultType = 'residential';

  const w = 120;
  const h = 90;
  const { x: cx, y: cy } = getViewCenter();

  const b = {
    id,
    x: Math.round(cx - w/2),
    y: Math.round(cy - h/2),
    w,
    h,
    label: 'New Building',
    type: defaultType,
    occupants: '',
    color: getFillForType(defaultType),
    stroke: 'rgba(0,0,0,0.6)',
    align: 'top',
    orient: 'horizontal'
  };
  state.buildings = state.buildings || [];
  state.buildings.push(b);

  renderAll();
  selectBuilding(id);
});

  
document.getElementById('addStreetBtn').addEventListener('click', ()=>{
  pushHistory('Add street');
  const id = 's' + Date.now();
  const { x: cx, y: cy, vb } = getViewCenter();

  // Create a short segment that scales with the current zoom level
  const seg = Math.max(140, Math.min(400, (vb.w || 1000) * 0.30));
  const half = seg / 2;

  const s = {
    id,
    name: 'New Street',
    width: 60,
    color: 'rgba(60,66,72,0.95)',
    nodes: [
      { x: Math.round(cx - half), y: Math.round(cy) },
      { x: Math.round(cx + half), y: Math.round(cy) }
    ]
  };
  state.streets = state.streets || [];
  state.streets.push(s);

  renderAll();
  selectStreet(id);
});

  document.getElementById('downloadBtn').addEventListener('click', ()=>{
    // Clone state so we can strip out any tracing image URL/data before saving
    const stateToSave = JSON.parse(JSON.stringify(state));
    if (stateToSave.trace && stateToSave.trace.url) {
      delete stateToSave.trace.url;
    }
    // Stamp metadata into the saved file so we can compare against autosave on future loads
    const now = Date.now();
    if (typeof window.MAP_META !== 'object' || !window.MAP_META) window.MAP_META = {};
    if (mapNameDisplayEl && mapNameDisplayEl.textContent) window.MAP_META.name = String(mapNameDisplayEl.textContent).trim();
    window.MAP_META.savedAt = now;
    currentFileSavedAt = now;
    const content =
      'window.MAP_META = ' + JSON.stringify(window.MAP_META, null, 2) + ';\n' +
      'window.MAP_DATA = ' + JSON.stringify(stateToSave, null, 2) + ';';
    const blob = new Blob([content], { type: 'text/javascript' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'data.js';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    // Update autosave + indicator at the moment of manual save
    try {
      writeAutosave({
        v: AUTOSAVE_VERSION,
        ts: now,
        reason: 'manual-save',
        mapId: getCurrentMapId(),
        fileSavedAt: currentFileSavedAt || 0,
        state: stateToSave
      });
    } catch(_) {}
    setAutosaveIndicator(now);
    setRestorePromptVisible(false);
  });

  document.getElementById('fileInput').addEventListener('change', (e) => {
    const f = e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        let text = String(reader.result || '').trim();
        let loaded = null;
        // Support both JS (data.js) and raw JSON exports
        if (/window\.MAP_DATA/.test(text) || /window\.MAP_META/.test(text)) {
          (function(){ eval(text); })();
          loaded = window.MAP_DATA;
          // Update current file-saved timestamp if present in the loaded file
          currentFileSavedAt = Number((window.MAP_META && window.MAP_META.savedAt) || 0) || 0;
        } else {
          loaded = JSON.parse(text);
        }
        if (!loaded) throw new Error('Could not extract MAP data from file');
        loaded = normalizeState(loaded);
        state = loaded;
        undoStack.length = 0;
        redoStack.length = 0;
        updateUndoRedoUI();
        blockNameEl.textContent = formatFileDisplayName(f.name) || (state.blockName || 'Neighborhood');
        if (state.viewBox && Array.isArray(state.viewBox) && state.viewBox.length === 4) {
          svg.setAttribute('viewBox', state.viewBox.join(' '));
        }

        // Restore any tracing image settings stored in the loaded data
        hydrateTraceFromState();

        renderAll();
        refreshAutosaveUI(true);
        alert('Loaded data.js successfully');
      } catch (err) {
        console.error(err);
        alert('Failed to load file: ' + (err && err.message ? err.message : String(err)));
      }
    };
    reader.readAsText(f);
  });

  svg.addEventListener('click', (e) => {
    if (didPan) { didPan = false; e.preventDefault(); e.stopPropagation(); return; }
    if (isBackgroundTarget(e.target)){
      selectedId = null; selectedType = null; activeStreetId = null;
      if (selectedIds) selectedIds.clear();
      form.style.display = 'none'; noSelection.style.display = 'block';
      removeStreetInspector();
      clearSelectedStreetHighlight();
      clearRouteHighlight();
      renderAll();
      refreshQuickEditBar();
    }
  });

  const zoomFactor = 2.50;
  document.getElementById('zoomInBtn').addEventListener('click', ()=>{
    const vb = svg.viewBox.baseVal;
    const w = vb.width / zoomFactor;
    const h = vb.height / zoomFactor;
    const cx = vb.x + vb.width/2;
    const cy = vb.y + vb.height/2;
    svg.setAttribute('viewBox', `${cx - w/2} ${cy - h/2} ${w} ${h}`);
    applyWorldRotation();
  });
  document.getElementById('zoomOutBtn').addEventListener('click', ()=>{
    const vb = svg.viewBox.baseVal;
    const w = vb.width * zoomFactor;
    const h = vb.height * zoomFactor;
    const cx = vb.x + vb.width/2;
    const cy = vb.y + vb.height/2;
    svg.setAttribute('viewBox', `${cx - w/2} ${cy - h/2} ${w} ${h}`);
    applyWorldRotation();
  });

  const rotateButtons = document.querySelectorAll(".rotate-btn");
  rotateButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      worldAngle = Number(btn.dataset.angle);
      applyWorldRotation();
      try { svg.focus(); } catch (err) {}
    });
  });

  function panView(dx, dy){
    ;[dx, dy] = adjustForRotation(dx, dy);

    if (worldAngle === 90) { const t = dx; dx = dy; dy = -t; }
    else if (worldAngle === -90) { const t = dx; dx = -dy; dy = t; }
    else if (worldAngle === 180 || worldAngle === -180) { dx = -dx; dy = -dy; }

    const vb = svg.viewBox.baseVal;
    const nx = vb.x + dx;
    const ny = vb.y + dy;
    svg.setAttribute('viewBox', `${nx} ${ny} ${vb.width} ${vb.height}`);
    applyWorldRotation();
  }
  window.addEventListener('keydown', (e) => {
    const tag = document.activeElement && document.activeElement.tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;
    const step = 50;
    if (e.key === 'ArrowLeft'){ panView(-step, 0); e.preventDefault(); }
    else if (e.key === 'ArrowRight'){ panView(step, 0); e.preventDefault(); }
    else if (e.key === 'ArrowUp'){ panView(0, -step); e.preventDefault(); }
    else if (e.key === 'ArrowDown'){ panView(0, step); e.preventDefault(); }
  });

  function pixelDeltaToViewBoxDelta(dxPx, dyPx){
    const vb = svg.viewBox.baseVal;
    const rect = svg.getBoundingClientRect();
    const dx = dxPx * (vb.width / rect.width);
    const dy = dyPx * (vb.height / rect.height);
    return { dx, dy };
  }

  
  // Mouse pan (disabled when tracing image drag is on)
  svg.addEventListener('mousedown', (e) => {
    if (typeof traceDragMode !== 'undefined' && traceDragMode) return;

    didPan = false;
    if (!isBackgroundTarget(e.target)) {
      if (e.target.id !== 'world') return;
    }

    const vb = svg.viewBox.baseVal;
    panDrag = {
      sx: e.clientX,
      sy: e.clientY,
      orig: [vb.x, vb.y, vb.width, vb.height]
    };

    svg.classList.add('dragging');
    window.addEventListener('mousemove', onPanDrag);
    window.addEventListener('mouseup', endPanDrag);
  });

  // Touch pan + pinch (also disabled when tracing drag is on)
  svg.addEventListener('touchstart', (e) => {
    if (typeof traceDragMode !== 'undefined' && traceDragMode) return;

    didPan = false;

    // Pinch start (two fingers)
    if (e.touches && e.touches.length === 2) {
      e.preventDefault();
      const t0 = e.touches[0];
      const t1 = e.touches[1];
      const dx = t1.clientX - t0.clientX;
      const dy = t1.clientY - t0.clientY;
      const dist = Math.hypot(dx, dy);
      const midX = (t0.clientX + t1.clientX) / 2;
      const midY = (t0.clientY + t1.clientY) / 2;

      pinchState = {
        lastDist: dist,
        lastCenterClient: { x: midX, y: midY }
      };

      try { svg.focus(); } catch (err) {}
      window.addEventListener('touchmove', onPinchMove, { passive: false });
      window.addEventListener('touchend', onPinchEnd);
      return;
    }

    // Single-finger pan
    if (!e.touches || e.touches.length !== 1) return;
    const t = e.target;
    if (!isBackgroundTarget(t) && t.id !== 'world') return;

    const vb = svg.viewBox.baseVal;
    panDrag = {
      sx: e.touches[0].clientX,
      sy: e.touches[0].clientY,
      orig: [vb.x, vb.y, vb.width, vb.height]
    };

    svg.classList.add('dragging');
    window.addEventListener('touchmove', onPanDrag, { passive: false });
    window.addEventListener('touchend', endPanDrag);
  }, { passive: false });

  function onPanDrag(e) {
    didPan = true;
    if (!panDrag) return;

    e.preventDefault();

    let cx, cy;
    if (e.touches && e.touches.length) {
      cx = e.touches[0].clientX;
      cy = e.touches[0].clientY;
    } else {
      cx = e.clientX;
      cy = e.clientY;
    }

    const dxPx = cx - panDrag.sx;
    const dyPx = cy - panDrag.sy;
    const rotatedPx = adjustForRotation(dxPx, dyPx);
    const delta = pixelDeltaToViewBoxDelta(rotatedPx[0], rotatedPx[1]);

    const vb = svg.viewBox.baseVal;
    const nx = panDrag.orig[0] - delta.dx;
    const ny = panDrag.orig[1] - delta.dy;

    svg.setAttribute('viewBox', `${nx} ${ny} ${vb.width} ${vb.height}`);
    applyWorldRotation();
  }

  function endPanDrag() {
    if (!panDrag) return;

    panDrag = null;
    svg.classList.remove('dragging');
    window.removeEventListener('mousemove', onPanDrag);
    window.removeEventListener('mouseup', endPanDrag);
    window.removeEventListener('touchmove', onPanDrag);
    window.removeEventListener('touchend', endPanDrag);
  }

  function onPinchMove(e) {
    if (!pinchState || !e.touches || e.touches.length < 2) return;

    e.preventDefault();
    const t0 = e.touches[0];
    const t1 = e.touches[1];
    const dx = t1.clientX - t0.clientX;
    const dy = t1.clientY - t0.clientY;
    const dist = Math.hypot(dx, dy);
    if (!dist || !pinchState.lastDist) return;

    const midX = (t0.clientX + t1.clientX) / 2;
    const midY = (t0.clientY + t1.clientY) / 2;

    const pinchSensitivity = 1.4;
    const perFrameScale = dist / pinchState.lastDist;
    const adjustedPerFrame = Math.pow(perFrameScale, pinchSensitivity);

    const vb = svg.viewBox.baseVal;
    const currW = vb.width;
    const currH = vb.height;

    let newW = currW / adjustedPerFrame;
    let newH = currH / adjustedPerFrame;

    const MIN_W = 20;
    const MAX_W = 80000;
    if (newW < MIN_W) newW = MIN_W;
    if (newW > MAX_W) newW = MAX_W;
    newH = (newW * currH) / currW;

    const svgPt = clientToSvg(midX, midY);
    const relX = (svgPt.x - vb.x) / currW;
    const relY = (svgPt.y - vb.y) / currH;

    const newX = svgPt.x - relX * newW;
    const newY = svgPt.y - relY * newH;

    svg.setAttribute('viewBox', `${newX} ${newY} ${newW} ${newH}`);
    applyWorldRotation();

    pinchState.lastDist = dist;
    pinchState.lastCenterClient.x = midX;
    pinchState.lastCenterClient.y = midY;
  }

  function onPinchEnd(e) {
    pinchState = null;
    window.removeEventListener('touchmove', onPinchMove);
    window.removeEventListener('touchend', onPinchEnd);
  }

  svg.addEventListener('wheel', function onWheel(e){
    const tag = document.activeElement && document.activeElement.tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

    if (e.ctrlKey) {
      e.preventDefault();

      const vb = svg.viewBox.baseVal;
      const currW = vb.width;
      const currH = vb.height;

      const zoomSensitivity = 0.0025;
      const factor = Math.exp(e.deltaY * zoomSensitivity);

      let newW = currW * factor;
      let newH = currH * factor;

      const MIN_W = 20;
      const MAX_W = 80000;
      if (newW < MIN_W) newW = MIN_W;
      if (newW > MAX_W) newW = MAX_W;
      newH = newW * currH / currW;

      const clientX = (e.clientX !== undefined) ? e.clientX : (svg.getBoundingClientRect().left + svg.getBoundingClientRect().width/2);
      const clientY = (e.clientY !== undefined) ? e.clientY : (svg.getBoundingClientRect().top + svg.getBoundingClientRect().height/2);

      const svgPt = clientToSvg(clientX, clientY);

      const relX = (svgPt.x - vb.x) / currW;
      const relY = (svgPt.y - vb.y) / currH;

      const newX = svgPt.x - relX * newW;
      const newY = svgPt.y - relY * newH;

      svg.setAttribute('viewBox', `${newX} ${newY} ${newW} ${newH}`);
      applyWorldRotation();
      return;
    }

    e.preventDefault();

    const dxPx = e.deltaX;
    const dyPx = e.deltaY;

    const rotatedPx = adjustForRotation(dxPx, dyPx);

    const delta = pixelDeltaToViewBoxDelta(rotatedPx[0], rotatedPx[1]);
    const vb = svg.viewBox.baseVal;
    const nx = vb.x + delta.dx;
    const ny = vb.y + delta.dy;
    svg.setAttribute('viewBox', `${nx} ${ny} ${vb.width} ${vb.height}`);
    applyWorldRotation();
  }, { passive: false });

  function normalizeState(s){
    const sane = Object.assign({}, s || {});
    sane.blockName = sane.blockName || 'Neighborhood';
    sane.viewBox = Array.isArray(sane.viewBox) && sane.viewBox.length === 4 ? sane.viewBox.slice() : [0,0,1000,700];
    sane.buildings = Array.isArray(sane.buildings) ? sane.buildings.map(normalizeBuilding) : [];
    sane.streets = Array.isArray(sane.streets) ? sane.streets.map(normalizeStreet) : [];
    return sane;
  }
  function normalizeBuilding(b){
    const nb = Object.assign({}, b || {});
    nb.id = nb.id || ('b' + Date.now() + Math.floor(Math.random()*1000));
    nb.x = Number(nb.x) || 0;
    nb.y = Number(nb.y) || 0;
    nb.w = Number(nb.w) || 40;
    nb.h = Number(nb.h) || 30;
    nb.label = nb.label || '';
    nb.type = nb.type || 'other';
    nb.color = nb.color || getFillForType(nb.type);
    nb.stroke = nb.stroke || 'rgba(0,0,0,0.6)';
    nb.occupants = nb.occupants || '';
    nb.align = nb.align || 'top';
    nb.orient = nb.orient || 'horizontal';
    nb.notes = nb.notes || ''; nb.usage = nb.usage || 'none'; nb.funding = nb.funding || 'none';
    return nb;
  }
  function normalizeStreet(s){
    const ns = Object.assign({}, s || {});
    ns.id = ns.id || ('s' + Date.now() + Math.floor(Math.random()*1000));
    ns.name = ns.name || '';
    ns.width = Number(ns.width) || 60;
    ns.color = ns.color || 'rgba(60,66,72,0.95)';
    ns.nodes = Array.isArray(ns.nodes) ? ns.nodes.map(n => ({ x: Number(n.x) || 0, y: Number(n.y) || 0 })) : [{ x: 100, y: 100 }, { x: 400, y: 100 }];
    return ns;
  }
  function escapeHtml(s){ return String(s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;'); }
  function toHexColor(c){
    if(!c) return '#ffffff';
    c = String(c);
    if(c[0] === '#') return c;
    const m = c.match(/rgba?\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})/i);
    if(m){
      const r = Number(m[1]), g = Number(m[2]), b = Number(m[3]);
      return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
    }
    return '#ffffff';
  }
  function formatFileDisplayName(filename) {
    if (!filename) return 'Neighborhood';
    const short = String(filename).split('/').pop().split('\\\\').pop();
    const dot = short.lastIndexOf('.');
    const base = dot > 0 ? short.slice(0, dot) : short;
    return base.replace(/_/g, ' ');
  }


  // === Tracing image controls ===
  if (traceInput) {
    traceInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        // Keep the image data only in memory; do NOT put it in state so data.js stays small.
        traceImageUrl = reader.result;
        traceImageVisible = true;

        // If we have saved transform metadata for this filename, reuse it so the image
        // snaps back to its previous position/scale/rotation when reloaded.
        traceImageName = file.name || '';
        const byName = state && state.traceByName ? state.traceByName : null;
        const t = (traceImageName && byName && byName[traceImageName]) ? byName[traceImageName] : (state && state.trace ? state.trace : null);

        if (t) {
          if (typeof t.x === 'number') traceImageX = t.x;
          if (typeof t.y === 'number') traceImageY = t.y;
          if (typeof t.baseWidth === 'number') traceImageBaseWidth = t.baseWidth;
          if (typeof t.baseHeight === 'number') traceImageBaseHeight = t.baseHeight;
          if (typeof t.scale === 'number') traceImageScale = t.scale;
          if (typeof t.angle === 'number') traceImageAngle = t.angle;
          if (typeof t.visible === 'boolean') traceImageVisible = t.visible;
        } else {
          // Fall back to initializing placement to current viewBox
          const vb = svg.viewBox.baseVal;
          traceImageX = vb.x;
          traceImageY = vb.y;
          traceImageBaseWidth = vb.width;
          traceImageBaseHeight = vb.height;
          traceImageScale = 1;
          traceImageAngle = 0;
        }

        // Ensure usable base size so the image renders (especially on a fresh map)
        if (!(traceImageBaseWidth > 0 && traceImageBaseHeight > 0)) {
          const vb = svg.viewBox.baseVal;
          traceImageX = vb.x;
          traceImageY = vb.y;
          traceImageBaseWidth = vb.width;
          traceImageBaseHeight = vb.height;
          if (!(traceImageScale > 0)) traceImageScale = 1;
          if (!Number.isFinite(traceImageAngle)) traceImageAngle = 0;
        }

        if (traceToggleBtn) {
          traceToggleBtn.textContent = 'Hide tracing image';
        }
        if (traceOffsetXInput) traceOffsetXInput.value = Math.round(traceImageX);
        if (traceOffsetYInput) traceOffsetYInput.value = Math.round(traceImageY);
        if (traceScaleInput) traceScaleInput.value = traceImageScale;
        if (traceScaleInputBox) traceScaleInputBox.value = traceImageScale;
        if (traceRotationInput) traceRotationInput.value = traceImageAngle;
        if (traceRotationInputBox) traceRotationInputBox.value = traceImageAngle;

        renderAll();
      };
      reader.readAsDataURL(file);
    });
  }

  if (traceRotationInput) {
    traceRotationInput.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v)) {
        traceImageAngle = v;
        renderAll();
      }
    });
  }

  if (traceRotationInputBox) {
    traceRotationInputBox.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v)) {
        traceImageAngle = v;
        if (traceRotationInput) traceRotationInput.value = v;
        renderAll();
      }
    });
  }

  if (traceToggleBtn) {
    traceToggleBtn.addEventListener('click', (e) => {
      e.preventDefault();
      traceImageVisible = !traceImageVisible;
      traceToggleBtn.textContent = traceImageVisible ? 'Hide tracing image' : 'Show tracing image';
      renderAll();
    });
  }

  if (traceOffsetXInput) {
    traceOffsetXInput.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v)) {
        traceImageX = v;
        renderAll();
      }
    });
  }

  if (traceOffsetYInput) {
    traceOffsetYInput.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v)) {
        traceImageY = v;
        renderAll();
      }
    });
  }

  if (traceScaleInput) {
    traceScaleInput.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v) && v > 0) {
        traceImageScale = v;
        if (traceScaleInputBox) traceScaleInputBox.value = v;
        renderAll();
      }
    });
  }

  if (traceScaleInputBox) {
    traceScaleInputBox.addEventListener('input', (e) => {
      const v = Number(e.target.value);
      if (!Number.isNaN(v) && v > 0) {
        traceImageScale = v;
        if (traceScaleInput) traceScaleInput.value = v;
        renderAll();
      }
    });
  }

  if (traceDragBtn) {
    traceDragBtn.addEventListener('click', () => {
      traceDragMode = !traceDragMode;
      traceDragBtn.textContent = traceDragMode ? 'Drag image: On' : 'Drag image: Off';
      renderAll();
    });
  }

  function startTraceDrag(evt) {
    if (!traceImageUrl) return;
    evt.preventDefault();
    const p = getWorldPoint(evt);
    traceDrag = { sx: p.x, sy: p.y, origX: traceImageX, origY: traceImageY };
    window.addEventListener('mousemove', onTraceDrag);
    window.addEventListener('touchmove', onTraceDrag, { passive: false });
    window.addEventListener('mouseup', endTraceDrag);
    window.addEventListener('touchend', endTraceDrag);
  }

  function onTraceDrag(evt) {
    if (!traceDrag) return;
    evt.preventDefault();
    const p = getWorldPoint(evt);
    const dx = p.x - traceDrag.sx;
    const dy = p.y - traceDrag.sy;
    traceImageX = traceDrag.origX + dx;
    traceImageY = traceDrag.origY + dy;
    if (traceOffsetXInput) traceOffsetXInput.value = Math.round(traceImageX);
    if (traceOffsetYInput) traceOffsetYInput.value = Math.round(traceImageY);
    renderAll();
  }

  function endTraceDrag() {
    if (!traceDrag) return;
    traceDrag = null;
    window.removeEventListener('mousemove', onTraceDrag);
    window.removeEventListener('touchmove', onTraceDrag);
    window.removeEventListener('mouseup', endTraceDrag);
    window.removeEventListener('touchend', endTraceDrag);
  }

  // Only allow starting a trace drag when trace drag mode is on and the tracing image is hit
  svg.addEventListener('mousedown', (e) => {
    if (!traceDragMode || !traceImageUrl) return;
    if (e.target && e.target.id === 'traceImageLayer') {
      startTraceDrag(e);
    }
  });

  svg.addEventListener('touchstart', (e) => {
    if (!traceDragMode || !traceImageUrl) return;
    const t = e.target;
    if (t && t.id === 'traceImageLayer') {
      startTraceDrag(e);
    }
  }, { passive: false });

  // === Floating window drag / resize for map & info ===
  (function(){
    const appEl = document.querySelector('.app');
    if (!appEl) return;
    const handles = document.querySelectorAll('.window-drag-handle');
    const resizers = document.querySelectorAll('.window-resizer');
    let activeWin = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let resizeWin = null;
    let resizeStartX = 0;
    let resizeStartY = 0;
    let resizeStartW = 0;
    let resizeStartH = 0;

    function getAppRect(){
      return appEl.getBoundingClientRect();
    }

    handles.forEach(h => {
      h.addEventListener('mousedown', (e) => {
        const id = h.getAttribute('data-window');
        const win = document.getElementById(id);
        if (!win) return;
        e.preventDefault();
        activeWin = win;
        const winRect = win.getBoundingClientRect();
        const appRect = getAppRect();
        dragOffsetX = e.clientX - winRect.left;
        dragOffsetY = e.clientY - winRect.top;
        document.body.style.cursor = 'move';
        window.addEventListener('mousemove', onWinDrag);
        window.addEventListener('mouseup', endWinDrag);
      });
    });

    function onWinDrag(e){
      if (!activeWin) return;
      e.preventDefault();
      const appRect = getAppRect();
      let x = e.clientX - appRect.left - dragOffsetX;
      let y = e.clientY - appRect.top - dragOffsetY;
      const maxX = appRect.width - 120;
      const maxY = appRect.height - 80;
      if (x < 0) x = 0;
      if (y < 0) y = 0;
      if (x > maxX) x = maxX;
      if (y > maxY) y = maxY;
      activeWin.style.left = x + 'px';
      activeWin.style.top = y + 'px';
    }

    function endWinDrag(){
      if (!activeWin) return;
      recordWindowState(activeWin);
      activeWin = null;
      document.body.style.cursor = '';
      window.removeEventListener('mousemove', onWinDrag);
      window.removeEventListener('mouseup', endWinDrag);
    }

    resizers.forEach(r => {
      r.addEventListener('mousedown', (e) => {
        const id = r.getAttribute('data-window');
        const win = document.getElementById(id);
        if (!win) return;
        e.preventDefault();
        resizeWin = win;
        const rect = win.getBoundingClientRect();
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        resizeStartW = rect.width;
        resizeStartH = rect.height;
        document.body.style.cursor = 'se-resize';
        window.addEventListener('mousemove', onWinResize);
        window.addEventListener('mouseup', endWinResize);
      });
    });

    function onWinResize(e){
      if (!resizeWin) return;
      e.preventDefault();
      const dx = e.clientX - resizeStartX;
      const dy = e.clientY - resizeStartY;
      let newW = resizeStartW + dx;
      let newH = resizeStartH + dy;
      const minW = (resizeWin.id === 'controlsPanel') ? 130 : 260;
      const minH = (resizeWin.id === 'controlsPanel') ? 100 : 220;
      if (newW < minW) newW = minW;
      if (newH < minH) newH = minH;
      resizeWin.style.width = newW + 'px';
      resizeWin.style.height = newH + 'px';

      // Adjust map tools grid columns when the controls panel is resized
      if (resizeWin.id === 'controlsPanel') {
        const mapToolsGrid = document.getElementById('mapToolsGrid');
        if (mapToolsGrid) {
          if (newW >= 600) {
            mapToolsGrid.style.gridTemplateColumns = 'repeat(7,minmax(0,1fr))';
          } else if (newW < 260) {
            mapToolsGrid.style.gridTemplateColumns = 'repeat(2,minmax(0,1fr))';
          } else {
            mapToolsGrid.style.gridTemplateColumns = 'repeat(4,minmax(0,1fr))';
          }
        }
      }
    }


    const mapPanelWin = document.getElementById('mapPanel');
    if (mapPanelWin) {
      mapPanelWin.addEventListener('mousedown', (e) => {
        const rect = mapPanelWin.getBoundingClientRect();
        // Only start drag when clicking in the top 20px of the window
        if (e.clientY > rect.top + 20) return;
        // Don't interfere with resize handle
        const target = e.target;
        if (target && target.closest && target.closest('.window-resizer')) return;

        e.preventDefault();
        activeWin = mapPanelWin;
        const appRect = getAppRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        document.body.style.cursor = 'move';
        window.addEventListener('mousemove', onWinDrag);
        window.addEventListener('mouseup', endWinDrag);
      });
    }

    function endWinResize(){
      if (!resizeWin) return;
      recordWindowState(resizeWin);
      resizeWin = null;
      document.body.style.cursor = '';
      window.removeEventListener('mousemove', onWinResize);
      window.removeEventListener('mouseup', endWinResize);
    }

    // Persist window positions & sizes in localStorage
    const WIN_STORAGE_KEY = 'sicaWindowState_v1';
    const DEFAULT_WIN_STATE = {"mapPanel":{"left":258,"top":0,"width":744.96875,"height":628.9765625},"infoPanel":{"left":997.984375,"top":0,"width":277.9921875,"height":621.9609375},"analyticsPanel":{"left":0,"top":197,"width":262,"height":432.9765625},"controlsPanel":{"left":0,"top":2,"width":260.9921875,"height":198.9921875}};


    function loadWindowState(){
      try{
        const raw = window.localStorage.getItem(WIN_STORAGE_KEY);
        if (!raw) return DEFAULT_WIN_STATE;
        const parsed = JSON.parse(raw);
        return (parsed && typeof parsed === 'object') ? parsed : {};
      } catch(e){
        return {};
      }
    }

    function saveWindowState(state){
      try{
        window.localStorage.setItem(WIN_STORAGE_KEY, JSON.stringify(state || {}));
      } catch(e){}
    }

    let winState = loadWindowState();

    function applyWindowState(id){
      if (window.matchMedia('(max-width: 900px)').matches) return;
      const win = document.getElementById(id);
      if (!win || !winState[id]) return;
      const s = winState[id];
      if (typeof s.left === 'number') win.style.left = s.left + 'px';
      if (typeof s.top === 'number') win.style.top = s.top + 'px';
      if (typeof s.width === 'number') win.style.width = s.width + 'px';
      if (typeof s.height === 'number') win.style.height = s.height + 'px';
    }

    function recordWindowState(win){
      if (!win || !win.id) return;
      const rect = win.getBoundingClientRect();
      const appRect = getAppRect();
      const id = win.id;
      if (!winState) winState = {};
      winState[id] = {
        left: rect.left - appRect.left,
        top: rect.top - appRect.top,
        width: rect.width,
        height: rect.height
      };
      saveWindowState(winState);
    }

    
  // --- Analytics panel: streets & transit routes ---
  const analyticsStreetList = document.getElementById('analyticsStreetList');
  const analyticsBusList = document.getElementById('analyticsBusList');
  const analyticsBikeList = document.getElementById('analyticsBikeList');
  const analyticsRailList = document.getElementById('analyticsRailList');
  const analyticsWaterList = document.getElementById('analyticsWaterList');
  const analyticsEmpty = document.getElementById('analyticsEmpty');
  const analyticsContent = document.getElementById('analyticsContent');

  let analyticsGroups = {};
  let streetIdToGroupKey = {};
  let analyticsActiveKey = null;
  let suppressAnalyticsFromSelectStreet = false;

  function buildAnalyticsFromState(){
    analyticsGroups = {};
    streetIdToGroupKey = {};

    const streets = state.streets || [];
    streets.forEach(s=>{
      const layer = getStreetLayer(s);
      const name = (s.name || '').trim();
      const notes = (s.notes || '').trim();
      let groupKey, label, category;

      if (layer === 'bus'){
        let m = name.match(/(\d+)\s+bus/i);
        if (m){
          const num = m[1];
          groupKey = 'bus:' + num;
          label = num + ' Bus';
        } else {
          groupKey = 'bus:' + (name || notes || 'Bus Route').toLowerCase();
          label = name || notes || 'Bus Route';
        }
        category = 'bus';
      } else if (layer === 'rail'){
        let base = name || notes || 'Rail Line';
        if (/^train tracks$/i.test(name) && notes){
          base = notes;
        }
        groupKey = 'rail:' + base.toLowerCase();
        label = base;
        category = 'rail';
      } else if (layer === 'bike'){
        const base = name || 'Bike Lane';
        groupKey = 'bike:' + base.toLowerCase();
        label = base;
        category = 'bike';
      } else if (layer === 'water'){
        const base = name || notes || 'Waterway';
        groupKey = 'water:' + base.toLowerCase();
        label = base;
        category = 'water';
      } else {
        const base = name || 'Unnamed Street';
        groupKey = 'street:' + base.toLowerCase();
        label = base;
        category = 'street';
      }

      if (!analyticsGroups[groupKey]){
        analyticsGroups[groupKey] = {
          key: groupKey,
          label: label,
          layer: layer,
          category: category,
          streetIds: [],
          segments: 0,
          length: 0,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      analyticsGroups[groupKey].streetIds.push(s.id);

      const nodes = s.nodes || [];
      let segLen = 0;
      const g = analyticsGroups[groupKey];
      for (let i=1;i<nodes.length;i++){
        const dx = (nodes[i].x || 0) - (nodes[i-1].x || 0);
        const dy = (nodes[i].y || 0) - (nodes[i-1].y || 0);
        segLen += Math.sqrt(dx*dx + dy*dy);
      }
      g.length += segLen;
      g.segments += nodes.length > 1 ? (nodes.length - 1) : 0;
      for (let i=0;i<nodes.length;i++){
        const nx = nodes[i].x;
        const ny = nodes[i].y;
        if (typeof nx === 'number' && typeof ny === 'number'){
          if (nx < g.minX) g.minX = nx;
          if (nx > g.maxX) g.maxX = nx;
          if (ny < g.minY) g.minY = ny;
          if (ny > g.maxY) g.maxY = ny;
        }
      }

      streetIdToGroupKey[s.id] = groupKey;
    });

    renderAnalyticsLists();
  }

  function formatAnalyticsLength(lenFeet){
    if (!lenFeet || !isFinite(lenFeet)) return '';
    const miles = lenFeet / 5280;
    if (miles < 0.1) return miles.toFixed(2) + ' mi';
    if (miles < 10) return miles.toFixed(2) + ' mi';
    return miles.toFixed(1) + ' mi';
  }

  function renderAnalyticsLists(){
    if (!analyticsStreetList || !analyticsBusList || !analyticsBikeList || !analyticsRailList || !analyticsWaterList || !analyticsEmpty || !analyticsContent) return;

    analyticsStreetList.innerHTML = '';
    analyticsBusList.innerHTML = '';
    analyticsBikeList.innerHTML = '';
    analyticsRailList.innerHTML = '';
    analyticsWaterList.innerHTML = '';

    const groupsArr = Object.values(analyticsGroups);
    if (!groupsArr.length){
      analyticsEmpty.style.display = 'block';
      analyticsContent.style.display = 'none';
      return;
    }
    analyticsEmpty.style.display = 'none';
    analyticsContent.style.display = '';

    const streetGroups = groupsArr
      .filter(g => g.category === 'street')
      .sort((a,b)=> a.label.localeCompare(b.label, undefined, { numeric:true, sensitivity:'base' }));
    const busGroups = groupsArr
      .filter(g => g.category === 'bus')
      .sort((a,b)=> a.label.localeCompare(b.label, undefined, { numeric:true, sensitivity:'base' }));
    const bikeGroups = groupsArr
      .filter(g => g.category === 'bike')
      .sort((a,b)=> a.label.localeCompare(b.label, undefined, { numeric:true, sensitivity:'base' }));
    const railGroups = groupsArr
      .filter(g => g.category === 'rail')
      .sort((a,b)=> a.label.localeCompare(b.label, undefined, { numeric:true, sensitivity:'base' }));

    const waterGroups = groupsArr
      .filter(g => g.category === 'water')
      .sort((a,b)=> a.label.localeCompare(b.label, undefined, { numeric:true, sensitivity:'base' }));

    function addAnalyticsItem(parent, group){
      const li = document.createElement('li');
      li.dataset.key = group.key;
      if (group.key === analyticsActiveKey) li.classList.add('active');

      const titleSpan = document.createElement('span');
      titleSpan.textContent = group.label;

      const metaSpan = document.createElement('span');
      metaSpan.className = 'pill';
      const lengthLabel = formatAnalyticsLength(group.length);
      metaSpan.textContent = lengthLabel || '';

      li.appendChild(titleSpan);
      li.appendChild(metaSpan);

      li.addEventListener('click', ()=>{
        const ids = group.streetIds || [];
        if (ids.length){
          // This will also sync the analytics panel via handleStreetSelectedFromMap
          selectStreet(ids[0]);
        } else {
          analyticsActiveKey = group.key;
          highlightAnalyticsGroup(group.key);
          renderAnalyticsLists();
        }
        zoomToAnalyticsGroup(group.key);
      });

      parent.appendChild(li);
    }

    streetGroups.forEach(g => addAnalyticsItem(analyticsStreetList, g));
    busGroups.forEach(g => addAnalyticsItem(analyticsBusList, g));
    bikeGroups.forEach(g => addAnalyticsItem(analyticsBikeList, g));
    railGroups.forEach(g => addAnalyticsItem(analyticsRailList, g));
    waterGroups.forEach(g => addAnalyticsItem(analyticsWaterList, g));
  }

  function highlightAnalyticsGroup(groupKey){
    const group = analyticsGroups[groupKey];
    if (!group) return;

    const streetPaths = svg.querySelectorAll('.street');
    streetPaths.forEach(p => p.classList.remove('highlighted'));
    const labelTexts = svg.querySelectorAll('text[data-street-id]');
    labelTexts.forEach(t => t.classList.remove('highlighted'));

    (group.streetIds || []).forEach(id => {
      const path = svg.querySelector('.street[data-id="' + id + '"]');
      if (path){
        path.classList.add('highlighted');
        if (path.parentNode) {
        const handlesLayer = path.parentNode.querySelector && path.parentNode.querySelector('#nodeHandlesLayer');
        if (handlesLayer) path.parentNode.insertBefore(path, handlesLayer);
        else path.parentNode.appendChild(path);
      }
      }
      const label = svg.querySelector('text[data-street-id="' + id + '"]');
      if (label){
        label.classList.add('highlighted');
        if (label.parentNode) {
        const handlesLayer = label.parentNode.querySelector && label.parentNode.querySelector('#nodeHandlesLayer');
        if (handlesLayer) label.parentNode.insertBefore(label, handlesLayer);
        else label.parentNode.appendChild(label);
      }
      }
    });

    // Also highlight transit stops (buildings) associated with the active bus/rail line(s)
    highlightedStreetIdsForStops = (group.streetIds || []).slice();
    computeStopHighlightIds();
    applyStopHighlightClasses();

  }

  function zoomToAnalyticsGroup(groupKey){
    const group = analyticsGroups[groupKey];
    if (!group) return;

    const minX = group.minX;
    const maxX = group.maxX;
    const minY = group.minY;
    const maxY = group.maxY;
    if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minY) || !isFinite(maxY)) return;

    // Raw width/height of the group in world units
    let w = maxX - minX;
    let h = maxY - minY;

    // Enforce a minimum footprint so tiny groups still zoom to something visible
    const MIN_SIZE = 40;
    if (w < MIN_SIZE) w = MIN_SIZE;
    if (h < MIN_SIZE) h = MIN_SIZE;

    // Use a single span so the box is roughly square. This makes the
    // zoom robust to any 90°/180° world rotation: whichever way the
    // street is oriented, we reserve enough vertical space.
    let span = Math.max(w, h);
    const MIN_SPAN = 80;
    if (span < MIN_SPAN) span = MIN_SPAN;

    // Padding around the span (world units)
    const padBase = 140;
    const padFraction = 0.25; // 25% of span
    const pad = Math.max(padBase, span * padFraction);

    // Center of the group
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;

    // Axis-aligned box we want to fit (before aspect correction)
    let boxW = span + 2 * pad;
    let boxH = span + 2 * pad;

    const rect = svg.getBoundingClientRect();
    if (!rect.width || !rect.height) return;
    const aspect = rect.width / rect.height;

    let newW = boxW;
    let newH = boxH;

    // Expand one dimension to match the viewport aspect, never shrink.
    if (newW / newH > aspect){
      // box wider than viewport: grow height
      newH = newW / aspect;
    } else {
      // box taller than viewport: grow width
      newW = newH * aspect;
    }

    // Center the view on the group
    const vx = cx - newW / 2;
    const vy = cy - newH / 2;

    svg.setAttribute('viewBox', `${vx} ${vy} ${newW} ${newH}`);
    applyWorldRotation();
  }




  function handleStreetSelectedFromMap(id){
    const key = streetIdToGroupKey[id];
    if (!key) return;
    analyticsActiveKey = key;
    highlightAnalyticsGroup(key);
    renderAnalyticsLists();
  }

  const __originalRenderAll = renderAll;
  renderAll = function(){
    __originalRenderAll();
    buildAnalyticsFromState();
    if (analyticsActiveKey && analyticsGroups && analyticsGroups[analyticsActiveKey]) {
      highlightAnalyticsGroup(analyticsActiveKey);
    }
  };

  const __originalSelectStreet = selectStreet;
  selectStreet = function(id){
    __originalSelectStreet(id);

    // Only sync into analytics when this wasn't a “map click” selection
    if (!suppressAnalyticsFromSelectStreet) {
      handleStreetSelectedFromMap(id);
    }
  };

  // initial analytics build for initial state
  buildAnalyticsFromState();


// Apply saved positions/sizes on load
    applyWindowState('mapPanel');
    applyWindowState('infoPanel');
    applyWindowState('analyticsPanel');
    applyWindowState('controlsPanel');

    // Ensure map tools grid columns match the current controls panel width
    (function(){
      const controlsPanelEl = document.getElementById('controlsPanel');
      const mapToolsGrid = document.getElementById('mapToolsGrid');
      if (controlsPanelEl && mapToolsGrid) {
        const rect = controlsPanelEl.getBoundingClientRect();
        if (rect.width < 260) {
          mapToolsGrid.style.gridTemplateColumns = 'repeat(2,minmax(0,1fr))';
        } else {
          mapToolsGrid.style.gridTemplateColumns = 'repeat(4,minmax(0,1fr))';
        }
      }
    })();


  })();
  init();

})();
</script>
<script>
(function(){
  const nameEl = document.getElementById('mapNameDisplay');
  const fileInput = document.getElementById('fileInput');
  if (fileInput && nameEl) {
    fileInput.addEventListener('change', (e) => {
      const f = e.target && e.target.files && e.target.files[0];
      if (f) {
        const nice = f.name.replace(/\.[^.]+$/, '');
        nameEl.textContent = nice || f.name;
      }
    });
  }
  try {
    if (window.MAP_META && window.MAP_META.name && nameEl) {
      nameEl.textContent = String(window.MAP_META.name || '').replace(/\.[^.]+$/, '') || window.MAP_META.name;
    }
  } catch(_) {}
})();
</script>

<script>
(function(){
  const loadBtn = document.getElementById('loadBtn');
  const fileInput = document.getElementById('fileInput');
  if (loadBtn && fileInput) {
    loadBtn.addEventListener('click', () => fileInput.click());
  }
})();
</script>


<script>
/* MOBILE_LAYOUT_PATCH_v2 */
(function(){
  const mq = window.matchMedia('(max-width: 900px)');

  let quickOriginalParent = null;
  let quickOriginalNext = null;

  function addClose(panelId, titleText, bodyClass){
    const panel = document.getElementById(panelId);
    if (!panel) return;

    let handle = null;
    try { handle = panel.querySelector(':scope > .window-drag-handle'); } catch(_) {}
    if (!handle) handle = panel.querySelector('.window-drag-handle');
    if (!handle) return;

    // Ensure there's a title on the left
    let titleSpan = handle.querySelector('span');
    if (!titleSpan){
      titleSpan = document.createElement('span');
      titleSpan.textContent = titleText;
      handle.appendChild(titleSpan);
    } else if (!String(titleSpan.textContent || '').trim()){
      titleSpan.textContent = titleText;
    }

    // Mobile headers shouldn't be draggable
    handle.style.justifyContent = 'space-between';
    handle.style.cursor = 'default';

    if (handle.querySelector('.mobile-close')) return;

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'tool-btn muted-btn mobile-close';
    btn.textContent = 'Back';
    btn.style.margin = '0';
    btn.style.padding = '6px 10px';
    btn.style.minHeight = '30px';
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      document.body.classList.remove(bodyClass);
    });

    handle.appendChild(btn);
  }

  function ensureMobileInfoBar(){
    const quick = document.getElementById('quickEditBar');
    if (!quick) return;

    if (!quickOriginalParent){
      quickOriginalParent = quick.parentElement;
      quickOriginalNext = quick.nextElementSibling;
    }

    // Desktop: keep the quick edit UI out of the way.
    if (!mq.matches){
      if (quickOriginalParent && quick.parentElement !== quickOriginalParent){
        if (quickOriginalNext && quickOriginalNext.parentElement === quickOriginalParent){
          quickOriginalParent.insertBefore(quick, quickOriginalNext);
        } else {
          quickOriginalParent.appendChild(quick);
        }
      }
      const bar = document.getElementById('mobileInfoBar');
      if (bar) bar.style.display = 'none';
      document.body.classList.remove('mobile-pane-info','mobile-pane-analytics');
      return;
    }

    // Mobile: dock quick edit bar at the bottom of the screen.
    let bar = document.getElementById('mobileInfoBar');
    if (!bar){
      bar = document.createElement('div');
      bar.id = 'mobileInfoBar';
      document.body.appendChild(bar);
    }
    if (quick.parentElement !== bar){
      bar.appendChild(quick);
    }
    bar.style.display = 'block';
  }

  function ensureOverlayButtons(){
    if (!mq.matches) return;

    // Routes (Lines & Routes) overlay: add a Back button so you can return to the map
    addClose('analyticsPanel', 'Lines & Routes', 'mobile-pane-analytics');

    // Safety: if anything ever opens the inspector overlay on mobile, make it closable too
    addClose('infoPanel', 'Inspector', 'mobile-pane-info');
  }

  function sync(){
    ensureMobileInfoBar();
    ensureOverlayButtons();
  }

  sync();
  mq.addEventListener('change', sync);
})();
</script>


</body>
</html>
